<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Skynet on 流浪花</title>
    <link>https://zfunnily.github.io/categories/Skynet/</link>
    <description>Recent content in Skynet on 流浪花</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Thu, 21 Oct 2021 10:06:39 +0800</lastBuildDate><atom:link href="https://zfunnily.github.io/categories/Skynet/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Skynet源码赏析四 | 消息调度</title>
      <link>https://zfunnily.github.io/post/skynet/skynet%E5%9B%9B/</link>
      <pubDate>Thu, 21 Oct 2021 10:06:39 +0800</pubDate>
      
      <guid>https://zfunnily.github.io/post/skynet/skynet%E5%9B%9B/</guid>
      <description>服务间消息流转 发送消息 数据结构message_queue *q是次级消息队列，每个服务都有与之绑定的唯一一个次级消息队列。当我们在lua层，调用skynet.send(...), 或者调用skynet.call(...)函数发送消息，其实调用的都是c.send(...),实际上调用的</description>
    </item>
    
    <item>
      <title>Skynet源码赏析三 | 服务启动</title>
      <link>https://zfunnily.github.io/post/skynet/skynet%E4%B8%89/</link>
      <pubDate>Wed, 20 Oct 2021 11:26:07 +0800</pubDate>
      
      <guid>https://zfunnily.github.io/post/skynet/skynet%E4%B8%89/</guid>
      <description>skynet启动一个C服务 查看怎么启动C服务的最好的办法是打断点，看源码。 启动logger日志服务 我拿日志服务来举例子，怎么启动日志服务的呢？ 传参数name = &amp;quot;logger&amp;quot;, param = null， struct skynet_context *ctx = skynet_context_new(config-&amp;gt;logservice, config-&amp;gt;logger);; 从modules服务模块中取出名字为 logger的服务, struct skynet_module * result = _query(name);; 如果找不到则从cpath目</description>
    </item>
    
    <item>
      <title>Skynet源码赏析二 | 基础数据结构</title>
      <link>https://zfunnily.github.io/post/skynet/skynet%E4%BA%8C/</link>
      <pubDate>Tue, 19 Oct 2021 18:47:45 +0800</pubDate>
      
      <guid>https://zfunnily.github.io/post/skynet/skynet%E4%BA%8C/</guid>
      <description>module管理模块 我们所写的C服务编译成.so文件后放在cpath变量路径下，程序会加载路径cpath = root..&amp;quot;cservice/?.so&amp;quot;下的.so文件，通过static void * _try_open(struct modules *m, const char * name)函数第一次打开，然后被加载到全局变量static struct modules *</description>
    </item>
    
    <item>
      <title>Skynet源码赏析一 | 启动初始化的过程</title>
      <link>https://zfunnily.github.io/post/skynet/skynet%E4%B8%80/</link>
      <pubDate>Tue, 19 Oct 2021 17:28:45 +0800</pubDate>
      
      <guid>https://zfunnily.github.io/post/skynet/skynet%E4%B8%80/</guid>
      <description>入口文件 skynet_main.c 加载配置 1 2 3 4 5 6 7 8 9 struct skynet_config config; config.thread = optint(&amp;#34;thread&amp;#34;,8); config.module_path = optstring(&amp;#34;cpath&amp;#34;,&amp;#34;./cservice/?.so&amp;#34;); config.harbor = optint(&amp;#34;harbor&amp;#34;, 1); config.bootstrap = optstring(&amp;#34;bootstrap&amp;#34;,&amp;#34;snlua bootstrap&amp;#34;); config.daemon = optstring(&amp;#34;daemon&amp;#34;, NULL); config.logger = optstring(&amp;#34;logger&amp;#34;, NULL); config.logservice = optstring(&amp;#34;logservice&amp;#34;, &amp;#34;logger&amp;#34;); config.profile = optboolean(&amp;#34;profile&amp;#34;, 1); 从上述代码可以看到，配置都已经加载到变量struct skynet_config config;中了。 初始化 初始化skynet_context管理模块, skynet_handle_init(config-&amp;gt;harbor);; 初始化static struct global_queue *Q消息队列, skynet_mq_init();; 初始化stat</description>
    </item>
    
    <item>
      <title>lua解决百元买鸡的问题</title>
      <link>https://zfunnily.github.io/post/csdn/lua%E8%A7%A3%E5%86%B3%E7%99%BE%E5%85%83%E4%B9%B0%E9%B8%A1%E7%9A%84%E9%97%AE%E9%A2%98/</link>
      <pubDate>Wed, 24 Feb 2021 17:51:46 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/post/csdn/lua%E8%A7%A3%E5%86%B3%E7%99%BE%E5%85%83%E4%B9%B0%E9%B8%A1%E7%9A%84%E9%97%AE%E9%A2%98/</guid>
      <description>问题 编写lua程序求解百鸡百钱问题。公鸡5元一只，母鸡3元一只，小鸡一元3只，问100元钱买100只鸡，可买公鸡、母鸡、小鸡各多少只？ 代码 ----------------------------------------------------------------------------- --公鸡5元一只，母鸡3元一只，小鸡一元3只，问100元钱买100只鸡，可买公鸡、母鸡、小鸡各多少只？ ----------------------------------------------------------------------------- local maxprice = 100 --总价 local maxnum = 100 --总数量 local</description>
    </item>
    
    <item>
      <title>Lua调用C/C&#43;&#43;的动态库</title>
      <link>https://zfunnily.github.io/post/csdn/Lua%E8%B0%83%E7%94%A8C-C&#43;&#43;%E7%9A%84%E5%8A%A8%E6%80%81%E5%BA%93/</link>
      <pubDate>Sat, 20 Feb 2021 11:11:51 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/post/csdn/Lua%E8%B0%83%E7%94%A8C-C&#43;&#43;%E7%9A%84%E5%8A%A8%E6%80%81%E5%BA%93/</guid>
      <description>概述 最近在学习 云风的skynet库，想自定义一个模块，目标是使用lua调用C/C++所编写的库。 当我们需要在Lua里面调用c/c++函数时，所有的函数都必须满足以下函数签名： typedef int (*lua_CFunction) (lua_State *L); 换句话说，所有的函数必须接收一个lua_State作为参数，同时返回一个整数值。因为这个函数使用</description>
    </item>
    
    <item>
      <title>在skynet中使用lua-protobuf库</title>
      <link>https://zfunnily.github.io/post/csdn/%E5%9C%A8skynet%E4%B8%AD%E4%BD%BF%E7%94%A8lua-protobuf%E5%BA%93/</link>
      <pubDate>Mon, 25 Jan 2021 14:25:07 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/post/csdn/%E5%9C%A8skynet%E4%B8%AD%E4%BD%BF%E7%94%A8lua-protobuf%E5%BA%93/</guid>
      <description>概述 在最新的skynet中我使用的是云风的pbc库来解析protobuf，该项目中的一个文件protobuf.lua 使用了module语法在lua5.1版本中已经删除，最新的skynet是lua5.4版本，于是我找到了解析protobuf的lua库–lua-protobuf。在最</description>
    </item>
    
    <item>
      <title>skynet框架入门--写一个echo服务</title>
      <link>https://zfunnily.github.io/post/csdn/skynet%E6%A1%86%E6%9E%B6%E5%85%A5%E9%97%A8-%E5%86%99%E4%B8%80%E4%B8%AAecho%E6%9C%8D%E5%8A%A1/</link>
      <pubDate>Fri, 15 Jan 2021 16:07:51 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/post/csdn/skynet%E6%A1%86%E6%9E%B6%E5%85%A5%E9%97%A8-%E5%86%99%E4%B8%80%E4%B8%AAecho%E6%9C%8D%E5%8A%A1/</guid>
      <description>概述 引用云风博客的话：“skynet 是一个为网络游戏服务器设计的轻量框架。但它本身并没有任何为网络游戏业务而特别设计的部分，所以尽可以把它用于其它领域。skynet 并不是一个开箱即用的引擎，使用它需要先对框架本身的结构有所了解，理解框架到底帮助开发者解决怎样的问题。如果你希望使用</description>
    </item>
    
  </channel>
</rss>
