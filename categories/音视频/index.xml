<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>音视频 on 留白</title>
    <link>https://zfunnily.github.io/categories/%E9%9F%B3%E8%A7%86%E9%A2%91/</link>
    <description>Recent content in 音视频 on 留白</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Mon, 15 Nov 2021 11:23:24 +0800</lastBuildDate><atom:link href="https://zfunnily.github.io/categories/%E9%9F%B3%E8%A7%86%E9%A2%91/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Webrtc二 | 共享桌面</title>
      <link>https://zfunnily.github.io/2021/11/webrtcdesk/</link>
      <pubDate>Mon, 15 Nov 2021 11:23:24 +0800</pubDate>
      
      <guid>https://zfunnily.github.io/2021/11/webrtcdesk/</guid>
      <description>环境 Ubuntu18.04 webrtc M84 改造peerconnection例子，用来实现桌面共享 改造类CapturerTrackSource 增加桌面的数据源类RcrtcDesktopCapturerTrackSource 继承webr</description>
    </item>
    
    <item>
      <title>Webrtc一 | peerconnection</title>
      <link>https://zfunnily.github.io/2021/11/webrtcpeerconnection/</link>
      <pubDate>Sun, 14 Nov 2021 16:20:31 +0800</pubDate>
      
      <guid>https://zfunnily.github.io/2021/11/webrtcpeerconnection/</guid>
      <description>环境 Ubuntu18.04 webrtc M84 国内镜像：https://webrtc.org.cn/mirror/ webrtc交互过程 通过peerconnection的例子来分析webrtc的交互流程 peer_connection 解析 为了便于管理，如编码，回显等，</description>
    </item>
    
    <item>
      <title>FFmpeg | 画中画和视频多宫格处理</title>
      <link>https://zfunnily.github.io/2020/09/ffmpegpicture/</link>
      <pubDate>Mon, 14 Sep 2020 18:29:33 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2020/09/ffmpegpicture/</guid>
      <description>FFmpeg生成画中画 静态画中画 将视频sub.mp4视频文件缩放成宽 480 、高 320 的视频,然后显示在 视频 input.mp4,x坐标为0,y 坐标为0 的位置 ffmpeg -re -i input.mp4 -vf &amp;quot;movie=sub.mp4, scale=480x320[test]; [in][test]overlay [out]&amp;quot; -vcodec libx264 output.flv 显示在画面的右下角，则需要用到</description>
    </item>
    
    <item>
      <title>FFmpeg | 给视频加文字和图片水印</title>
      <link>https://zfunnily.github.io/2020/09/ffmpegvideo/</link>
      <pubDate>Sat, 12 Sep 2020 12:47:57 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2020/09/ffmpegvideo/</guid>
      <description>FFmpeg给视频加上logo ffmpeg从视频中截取图像帧 ffmpeg -i inputfile.avi -r 1 -f image2 image-%05d.jpeg ffmpeg -i inputfile.avi -r 1 -s 4cif -f image2 image-%05d.jpeg ffmpeg -i inputfile.avi -r 1 -t 4 -f image2 image-%05d.jpeg ffmpeg -i inputfile.avi -r 1 -ss 01:30:14 -f image2 image-%05d.jpeg ffmpeg -i inputfile.avi -r 1 -ss 01:30:14 -vframes 120 4cif -f image2 image-%05d.jpeg -r 指定抽取的帧率，即从视频中每秒钟抽取</description>
    </item>
    
    <item>
      <title>FFmpeg | 录制摄像头和桌面数据windows</title>
      <link>https://zfunnily.github.io/2020/09/ffmpegvideow/</link>
      <pubDate>Wed, 09 Sep 2020 09:36:49 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2020/09/ffmpegvideow/</guid>
      <description>概述 FFmpeg Windows 设备操作 Windows 采集设备的主要方式是 dshow vfwcap gdigrab 其中 dshow 可以用来抓 取摄像头、采集卡、麦克风等，- vfwcap 主要用来采集摄像头类设备，- gdigrab 则是抓取 Windows 窗口程序 FFmpeg 使用 dshow 采集音视频设备 使用 dshow 枚举设备 ffmpeg -f dshow -list_devices true -i dymmy 输出 [dshow @ 000002622302e340]</description>
    </item>
    
    <item>
      <title>FFmpeg | 录制摄像头和桌面数据mac</title>
      <link>https://zfunnily.github.io/2020/08/macffmpeg/</link>
      <pubDate>Sat, 29 Aug 2020 17:20:40 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2020/08/macffmpeg/</guid>
      <description>设备枚举 查看设备列表 $ ffmpeg -hide_banner -devices Devices: D. = Demuxing supported .E = Muxing supported -- D avfoundation AVFoundation input device D lavfi Libavfilter virtual input device E sdl,sdl2 SDL2 output device 可以看到输入设备有：avfoundation，lavfi 输出设备有：sdl `` 设备采集举例： $ ffmpeg -f avfoundation -list_devices true -i &amp;quot; &amp;quot; 看到了 如下设</description>
    </item>
    
    <item>
      <title>Owt-server | owt-client-javascript</title>
      <link>https://zfunnily.github.io/2020/08/owt-client-javascript/</link>
      <pubDate>Sun, 16 Aug 2020 23:04:13 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2020/08/owt-client-javascript/</guid>
      <description>概述 天气燥热，不易出门。遂研究一下owt-server，从owt-client-javascript的流程开始吧。 获取一个会议室 owt-client-javascript的时候有一个初始化房间的过程 ///owt-client-javascript/src/samples/conference/samplertcservice.js</description>
    </item>
    
    <item>
      <title>Licod | 安装和配置</title>
      <link>https://zfunnily.github.io/2020/08/licode/</link>
      <pubDate>Sun, 09 Aug 2020 09:34:36 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2020/08/licode/</guid>
      <description>拉取docker镜像并运行 licode官方提供了配置好的docker镜像，使用以下命令拉下来跑就行。 docker run --name licode -p 3000:3000 -p $MIN_PORT-$MAX_PORT:30000-30050/udp -p 3001:3001 -p 8080:8080 -e &amp;quot;MIN_PORT=30000&amp;quot; -e &amp;quot;MAX_PORT=30050&amp;quot; -e &amp;quot;PUBLIC_IP=your_ip_address&amp;quot; lynckia/licode 注意命令里的PUBLIC_IP要改为服务器的公网IP。 配置好之</description>
    </item>
    
    <item>
      <title>Owt-server | 编译运行</title>
      <link>https://zfunnily.github.io/2020/08/owtservercomplie/</link>
      <pubDate>Wed, 05 Aug 2020 09:47:22 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2020/08/owtservercomplie/</guid>
      <description>概述 owt是一套完整的webrtc视频会议系统。包含的功能模块有： 视频会议1. p2p 服务器是owt-server通过nodejs编写的webrtc信令。依赖是licode。licode依赖webrtc。 客</description>
    </item>
    
  </channel>
</rss>
