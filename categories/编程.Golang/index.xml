<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>编程.Golang on Zzz记忆</title>
    <link>https://zfunnily.github.io/categories/%E7%BC%96%E7%A8%8B.Golang/</link>
    <description>Recent content in 编程.Golang on Zzz记忆</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Tue, 01 Mar 2022 11:33:22 +0800</lastBuildDate><atom:link href="https://zfunnily.github.io/categories/%E7%BC%96%E7%A8%8B.Golang/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Goang | plugin热更</title>
      <link>https://zfunnily.github.io/2022/03/reload/</link>
      <pubDate>Tue, 01 Mar 2022 11:33:22 +0800</pubDate>
      
      <guid>https://zfunnily.github.io/2022/03/reload/</guid>
      <description>热更新 动态脚本更新 (php) 短链接无状态服务器热更 (http) 长连接有状态，数据跟逻辑分离 golang Plugin热更 (.so 动态库更新) &amp;mdash;-逻辑热更 长连接有状态,在运维层面, 利用容器部署热更(docker, k8s) 服务不接受新</description>
    </item>
    
    <item>
      <title>Grpc | Token认证和自定义认证</title>
      <link>https://zfunnily.github.io/2022/02/jwt/</link>
      <pubDate>Tue, 22 Feb 2022 15:39:30 +0800</pubDate>
      
      <guid>https://zfunnily.github.io/2022/02/jwt/</guid>
      <description>概述 现在有个需求，需要在grpc的拦截器中，通过token进行身份认证。如果认证不通过则返回错误; 认证通过，则放行; TLS是用作加密通讯通道的，与该需求无关。 Token认证 具体流程 客户端通过账号密码登</description>
    </item>
    
    <item>
      <title>Grpc ｜ 通过SSL/TLS建立安全连接</title>
      <link>https://zfunnily.github.io/2022/02/san/</link>
      <pubDate>Tue, 22 Feb 2022 14:22:41 +0800</pubDate>
      
      <guid>https://zfunnily.github.io/2022/02/san/</guid>
      <description>使用golang的grpc库作为例子 grpc使用TLS建立安全连接需要有SAN证书， go 1.15 版本开始废弃 CommonName。 什么是SAN证书 SAN(Subject Alternative Name) 是 SSL 标准 x509 中定义的一个扩展。使用了 SAN 字段的 SSL 证书，可以扩</description>
    </item>
    
    <item>
      <title>Golang | 调用带有后台进程shell脚本可能会被挂起</title>
      <link>https://zfunnily.github.io/2021/10/shell/</link>
      <pubDate>Wed, 13 Oct 2021 17:15:45 +0800</pubDate>
      
      <guid>https://zfunnily.github.io/2021/10/shell/</guid>
      <description>起因 今天用Golang写一个调用外部shell脚本的程序，使用 exec.Command方法，这段脚本代码中包含了一个后台任务语句。 结果发生了一个问题：cmd.Output 始终不会返回，一直挂起。导致我</description>
    </item>
    
    <item>
      <title>Golang | redis实现分布式锁</title>
      <link>https://zfunnily.github.io/2021/06/distribute/</link>
      <pubDate>Thu, 03 Jun 2021 16:12:21 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2021/06/distribute/</guid>
      <description>概述 网上有很多Golang操作redis的例子，我使用github.com/gomodule/redigo/redis包写一个关于redis分布式锁的问题。 redis分布式锁 锁需要的几个组件 获取锁- 删</description>
    </item>
    
    <item>
      <title>Golang | redis</title>
      <link>https://zfunnily.github.io/2021/06/goredis/</link>
      <pubDate>Thu, 03 Jun 2021 15:57:14 +0800</pubDate>
      
      <guid>https://zfunnily.github.io/2021/06/goredis/</guid>
      <description>概述 网上有很多golang操作redis的例子，我使用github.com/gomodule/redigo/redis包写一个关于redis分布式锁的问题。 redis分布式锁 锁需要的几个组件 获取锁 删除</description>
    </item>
    
    <item>
      <title>Golang | gomod拉取私有仓库</title>
      <link>https://zfunnily.github.io/2021/03/gomod/</link>
      <pubDate>Tue, 23 Mar 2021 16:10:02 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2021/03/gomod/</guid>
      <description>概述 在使用go mod的过程中，依赖的包往往是第三方库，当我们自定义一个包并且放在github.com私有仓库时候，按照原来的方法则会有如下问题。 get &amp;#34;gitlab.com/xxx/zz&amp;#34;: found meta tag get.metaImport{Prefix:&amp;#34;gitlab.com/xxx/zz&amp;#34;, VCS:&amp;#34;git&amp;#34;, RepoRoot:&amp;#34;https://gitlab.com/xxx/zz.git&amp;#34;} at //gitlab.com/xxx/zz?go-get=1 verifying gitlab.com/xxx/zz@v0.0.1: gitlab.com/xxx/zz@v0.0.1: reading https://sum.golang.org/lookup/gitlab.com/xxx/zz@v0.0.1: 410 Gone 这个错误是因为新版本g</description>
    </item>
    
    <item>
      <title>Golang | 定时器</title>
      <link>https://zfunnily.github.io/2021/02/timer/</link>
      <pubDate>Thu, 25 Feb 2021 16:02:13 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2021/02/timer/</guid>
      <description>概述 golang有三种方式实现定时器： ticker timer select Ticker 通过 time.NewTicker(d)的方式实现定时器 d := time.Duration(time.Second * 2) t1 := time.NewTicker(d) defer t1.Stop() go func() { for { &amp;lt;- t1.C fmt.Println(&amp;#34;NewTicker...&amp;#34;) } }() Timer 通过 time.NewTimer(d)的方式实现定时器 t2 := time.NewTimer(d)</description>
    </item>
    
    <item>
      <title>Golang | JWT身份认证</title>
      <link>https://zfunnily.github.io/2021/02/JWT/</link>
      <pubDate>Wed, 24 Feb 2021 14:22:04 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2021/02/JWT/</guid>
      <description>概述 最近要在http接口上加一个token认证，但是接口很多，有没有一个省时省力的办法来解决。token的使用流程是： 用户使用帐号密码登陆到服务器1. 服务器验证登陆成功，根据帐号密码生成token。把</description>
    </item>
    
    <item>
      <title>Protobuf | 请求参数为空的案例</title>
      <link>https://zfunnily.github.io/2021/01/pbempty/</link>
      <pubDate>Fri, 22 Jan 2021 16:41:16 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2021/01/pbempty/</guid>
      <description>参数为空的grpc请求怎么定义 google protobuf已经提供了空参数 //empty.proto message Empty {&amp;lt;!-- --&amp;gt;} 使用方法，在proto文件中导入empty.proto, 定义一个请求参数和返回值为空的函数emptyfunction， 函数名字</description>
    </item>
    
    <item>
      <title>Golang | C数组转化为Golang的切片类型</title>
      <link>https://zfunnily.github.io/2021/01/goslience/</link>
      <pubDate>Fri, 22 Jan 2021 15:56:40 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2021/01/goslience/</guid>
      <description>概述 最近在巩固cgo的基础知识，在网上看到一篇Go和C之间 字符串数组、切片类型转换的文章，让我想到我之前写的一篇在go中遍历C结构体数组的文章，让我有新的方法来解决之前的问题，把C的数组转化为Go的切</description>
    </item>
    
    <item>
      <title>Cgo | 遍历C结构体数组</title>
      <link>https://zfunnily.github.io/2021/01/cgostruct/</link>
      <pubDate>Mon, 11 Jan 2021 17:18:35 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2021/01/cgostruct/</guid>
      <description>缘由 现在有个应用场景，我们要在go中获取C结构体数组中的值。在C语言中，对于结构体数组，我们可以利用指针的偏移量来获取我们想要的值的位置。在go中我们怎么使用C指针和偏移量进行运算呢？下面的文字中C指</description>
    </item>
    
    <item>
      <title>Golang | sync.Mutex详解</title>
      <link>https://zfunnily.github.io/2020/12/syncmutex/</link>
      <pubDate>Tue, 29 Dec 2020 13:17:18 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2020/12/syncmutex/</guid>
      <description>概述 自己做的一个golang项目需要优化，优化方向是减少gpu内存的使用。同一个模型被重复加载多次，使用更多的gpu内存，也增加 sync.Mutex的使用。 优化的方向是: 减少代码量的改动- 减少gpu内</description>
    </item>
    
    <item>
      <title>Golang | 用gocolly登录B站</title>
      <link>https://zfunnily.github.io/2020/12/gocolly/</link>
      <pubDate>Sun, 13 Dec 2020 14:51:53 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2020/12/gocolly/</guid>
      <description>概述 gocolly是golang语言开发的爬虫包，通过gocolly来进行模拟网站的登录， 目标已经确立，开始行动。 下载 $ go get -u github.com/gocolly/colly 获取cookie 登录网站：https://www.bilibili.co</description>
    </item>
    
    <item>
      <title>Protobuf | 沾包问题</title>
      <link>https://zfunnily.github.io/2020/12/tcp/</link>
      <pubDate>Sun, 13 Dec 2020 10:22:38 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2020/12/tcp/</guid>
      <description>缘由 最近在研究一款游戏的源码。发现里面的通信协议是protobuf定义的，但还是自己定义了协议头部，类似 head + body。先解析头部里所存储的整个包的数据长度，然后再解析包剩余的数据，这样做的目的是为了防</description>
    </item>
    
    <item>
      <title>Grpc | 概述</title>
      <link>https://zfunnily.github.io/2020/12/grpc/</link>
      <pubDate>Sun, 13 Dec 2020 09:10:42 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2020/12/grpc/</guid>
      <description>OverView gRPC是由Google主导开发的RPC框架，使用HTTP/2协议并用ProtoBuf作为序列化工具。其客户端提供Objective-C、Java接口，服务器侧则有Java、Golang、C++等接</description>
    </item>
    
    <item>
      <title>Cgo | 使用libevent库实现一个定时器</title>
      <link>https://zfunnily.github.io/2020/11/cgo%E4%BD%BF%E7%94%A8libevent%E5%BA%93%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%AE%9A%E6%97%B6%E5%99%A8/</link>
      <pubDate>Fri, 13 Nov 2020 16:40:42 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2020/11/cgo%E4%BD%BF%E7%94%A8libevent%E5%BA%93%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%AE%9A%E6%97%B6%E5%99%A8/</guid>
      <description>使用libevent库作为例子 下载 &amp;amp; 编译 &amp;amp; 安装libevent $ git clone https://github.com.cnpmjs.org/libevent/libevent.git $ cd libevent &amp;amp;&amp;amp; mkdir build &amp;amp;&amp;amp; cd build $ cmake .. $ make libevent实现的定时器 // main.cpp #include &amp;#34;event.h&amp;#34; struct event ev; struct timeval tv; void time_cb(evutil_socket_t fd, short event, void *argc) { printf(&amp;#34;timer wakeup\n&amp;#34;); event_add(&amp;amp;ev, &amp;amp;tv); // reschedule timer } int main() { struct event_base *base = event_base_new(); tv.tv_sec = 2;</description>
    </item>
    
    <item>
      <title>Golang | 利用指针进行数据转换</title>
      <link>https://zfunnily.github.io/2020/11/Golang-%E5%88%A9%E7%94%A8%E6%8C%87%E9%92%88%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E8%BD%AC%E6%8D%A2/</link>
      <pubDate>Thu, 12 Nov 2020 17:19:07 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2020/11/Golang-%E5%88%A9%E7%94%A8%E6%8C%87%E9%92%88%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E8%BD%AC%E6%8D%A2/</guid>
      <description>概述 在Go语言中，Slice本质是什么呢？是一个reflect.SliceHeader结构体和这个结构体中Data字段所指向的内存。String本质是什么呢？是一个reflect.StringHead</description>
    </item>
    
    <item>
      <title>Golang | builds</title>
      <link>https://zfunnily.github.io/2020/11/go-builds/</link>
      <pubDate>Thu, 12 Nov 2020 17:15:17 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2020/11/go-builds/</guid>
      <description>概述 通常我们会给每个产品环境设置不同的配置，比如 redis 要在开发环境就连接 localhost:6379，测试环境可能连接某一个主机的 redis。 如果放在 go 里面是否可行？因为 go 是编译二进制包，也没有动态加载这</description>
    </item>
    
    <item>
      <title>Cgo | 简单使用</title>
      <link>https://zfunnily.github.io/2020/11/cgo%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Thu, 05 Nov 2020 09:45:23 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2020/11/cgo%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</guid>
      <description>使用自己的C函数 文件名：testC.go package main /* #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;stdlib.h&amp;gt; void c_print(char *str) { printf(&amp;#34;%s\n&amp;#34;, str); } */ import &amp;#34;C&amp;#34; //import “C” 必须单起一行，并且紧跟在注释行之后 import &amp;#34;unsafe&amp;#34; func main() { s := &amp;#34;Hello Cgo&amp;#34; cs := C.CString(s) //字符串映射 C.c_print(cs) //调用C函数 defer C.free(unsafe.Pointer(cs)) //释放内存 } 说明： 1、g</description>
    </item>
    
    <item>
      <title>Golang | 使用Lumberjack&#43;zap进行日志切割归档</title>
      <link>https://zfunnily.github.io/2020/11/%E4%BD%BF%E7%94%A8Lumberjack-zap%E8%BF%9B%E8%A1%8C%E6%97%A5%E5%BF%97%E5%88%87%E5%89%B2%E5%BD%92%E6%A1%A3/</link>
      <pubDate>Wed, 04 Nov 2020 12:44:03 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2020/11/%E4%BD%BF%E7%94%A8Lumberjack-zap%E8%BF%9B%E8%A1%8C%E6%97%A5%E5%BF%97%E5%88%87%E5%89%B2%E5%BD%92%E6%A1%A3/</guid>
      <description>使用Lumberjack+zap进行日志切割归档 为了添加日志切割归档功能，我们将使用第三方库Lumberjack来实现。 安装 执行下面的命令安装Lumberjack go get -u github.com/natefinch/lumberjack zap logger中加入Lumbe</description>
    </item>
    
  </channel>
</rss>
