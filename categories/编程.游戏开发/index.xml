<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>编程.游戏开发 on Zzz记忆</title><link>https://zfunnily.github.io/categories/%E7%BC%96%E7%A8%8B.%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/</link><description>Recent content in 编程.游戏开发 on Zzz记忆</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Sat, 13 Apr 2024 00:51:26 +0000</lastBuildDate><atom:link href="https://zfunnily.github.io/categories/%E7%BC%96%E7%A8%8B.%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/index.xml" rel="self" type="application/rss+xml"/><item><title>抽卡逻辑自述</title><link>https://zfunnily.github.io/2022/03/afk/</link><pubDate>Wed, 30 Mar 2022 10:50:11 +0800</pubDate><guid>https://zfunnily.github.io/2022/03/afk/</guid><description>抽卡逻辑自述 参考《剑与远征》 卡牌颜色以及合成 颜色 合成 绿色 可分解，得到粉尘和银瓜子, 最基础的卡 蓝 蓝+ 同样的三张蓝色可合成一张蓝+ 紫 同种族的三张蓝+可以合成一张紫(可以选择合成其中蓝+的某个紫色) 紫+ 同英</description></item><item><title>抽卡逻辑自述</title><link>https://zfunnily.github.io/2022/03/afk/</link><pubDate>Wed, 30 Mar 2022 10:50:11 +0800</pubDate><guid>https://zfunnily.github.io/2022/03/afk/</guid><description>抽卡逻辑自述 参考《剑与远征》 卡牌颜色以及合成 颜色 合成 绿色 可分解，得到粉尘和银瓜子, 最基础的卡 蓝 蓝+ 同样的三张蓝色可合成一张蓝+ 紫 同种族的三张蓝+可以合成一张紫(可以选择合成其中蓝+的某个紫色) 紫+ 同英</description></item><item><title>层级时间轮 ｜ skynet 定时器</title><link>https://zfunnily.github.io/2022/03/timerskynet/</link><pubDate>Sun, 27 Mar 2022 12:39:12 +0800</pubDate><guid>https://zfunnily.github.io/2022/03/timerskynet/</guid><description>skynet定时器 要解析一个程序代码，先了解数据结构，这是基础，再看函数。 拿skynet定时器举例子。 数据结构 //定时器事件 用于抛出定时器事件到消息队列里。理解这个数据结构需要先了解skynet的框架</description></item><item><title>层级时间轮 ｜ skynet 定时器</title><link>https://zfunnily.github.io/2022/03/timerskynet/</link><pubDate>Sun, 27 Mar 2022 12:39:12 +0800</pubDate><guid>https://zfunnily.github.io/2022/03/timerskynet/</guid><description>skynet定时器 要解析一个程序代码，先了解数据结构，这是基础，再看函数。 拿skynet定时器举例子。 数据结构 //定时器事件 用于抛出定时器事件到消息队列里。理解这个数据结构需要先了解skynet的框架</description></item><item><title>A*算法 | Lua版本</title><link>https://zfunnily.github.io/2021/12/astar/</link><pubDate>Thu, 23 Dec 2021 16:37:44 +0800</pubDate><guid>https://zfunnily.github.io/2021/12/astar/</guid><description>A*算法思路 寻路步骤 从起点A开始, 把它作为待处理的方格存入一个&amp;quot;开启列表&amp;quot;, 开启列表就是一个等待检查方格的列表. 寻找起点A周围可以到达的方格, 将它们放入&amp;quot;开启列表&amp;quo</description></item><item><title>Skynet源码赏析三 | 服务启动</title><link>https://zfunnily.github.io/2021/10/skynetthree/</link><pubDate>Wed, 20 Oct 2021 11:26:07 +0800</pubDate><guid>https://zfunnily.github.io/2021/10/skynetthree/</guid><description>skynet启动一个C服务 查看怎么启动C服务的最好的办法是打断点，看源码。 启动logger日志服务 我拿日志服务来举例子，怎么启动日志服务的呢？ 传参数name = &amp;quot;logger&amp;quot;, param = null， struct skynet_context *ctx = skynet_context_new(config-&amp;gt;logservice, config-&amp;gt;logger);; 从module</description></item><item><title>Skynet源码赏析二 | 基础数据结构</title><link>https://zfunnily.github.io/2021/10/skynettwo/</link><pubDate>Tue, 19 Oct 2021 18:47:45 +0800</pubDate><guid>https://zfunnily.github.io/2021/10/skynettwo/</guid><description>module管理模块 我们所写的C服务编译成.so文件后放在cpath变量路径下，程序会加载路径cpath = root..&amp;quot;cservice/?.so&amp;quot;下的.so文件，通过static</description></item><item><title>Skynet源码赏析一 | 启动初始化的过程</title><link>https://zfunnily.github.io/2021/10/skynetone/</link><pubDate>Tue, 19 Oct 2021 17:28:45 +0800</pubDate><guid>https://zfunnily.github.io/2021/10/skynetone/</guid><description>入口文件 skynet_main.c 加载配置 struct skynet_config config; config.thread = optint(&amp;#34;thread&amp;#34;,8); config.module_path = optstring(&amp;#34;cpath&amp;#34;,&amp;#34;./cservice/?.so&amp;#34;); config.harbor = optint(&amp;#34;harbor&amp;#34;, 1); config.bootstrap = optstring(&amp;#34;bootstrap&amp;#34;,&amp;#34;snlua bootstrap&amp;#34;); config.daemon = optstring(&amp;#34;daemon&amp;#34;, NULL); config.logger = optstring(&amp;#34;logger&amp;#34;, NULL); config.logservice = optstring(&amp;#34;logservice&amp;#34;, &amp;#34;logger&amp;#34;); config.profile = optboolean(&amp;#34;profile&amp;#34;, 1); 从上述代码可以看到，配置都已经加载到变量struct skynet_config config;中了。 初始化 初始化skynet_context管</description></item><item><title>FPS游戏 | 实现移动功能</title><link>https://zfunnily.github.io/2021/09/move/</link><pubDate>Sun, 12 Sep 2021 20:43:34 +0800</pubDate><guid>https://zfunnily.github.io/2021/09/move/</guid><description>三种实现FPS Controller的区别 Transform Translate 允许移动物理，但无物理碰撞 Rigid body + Capsule Collider 符合物理学 不会鬼穿墙 无法滞空运动 可与Physics Object 交互 Charactor Controller 不会鬼穿墙 提供的API相对多 无法与Physic objects</description></item><item><title>《仙剑奇侠传》编译运行</title><link>https://zfunnily.github.io/2021/03/gamexian/</link><pubDate>Sun, 21 Mar 2021 10:44:58 +0000</pubDate><guid>https://zfunnily.github.io/2021/03/gamexian/</guid><description>概述 今天在github上找到了《仙剑奇侠传》的rpg单机游戏sdlpal，sdlpal 是一个开源项目，基于sdl把仙剑奇侠传重写了一遍。 下面是我的编译过程总结。 环境 win10- sdl1.2- sdlpal- vs2017- DirectX SDK10 下载sdlpal $ git clone https://github.com.cnpmjs.org/sdlpal/sdlpal.git</description></item><item><title>Lastbattle | 游戏场景服务器SS解析</title><link>https://zfunnily.github.io/2021/01/lastbattle/</link><pubDate>Sat, 02 Jan 2021 23:19:58 +0000</pubDate><guid>https://zfunnily.github.io/2021/01/lastbattle/</guid><description>游戏场景服务器概况 指令对应的处理handle的文件：SSBattleMgr.cpp 创建战场 指令： eMsgToSSFromCS_CreateBattle GC服务器发往SS fromCS 收到中心服务器CS创建站场的指令，在函数INT32 CSSBattleMgr::OnMsgFromCS_CreateBattle(const char* pData, int n32DataLengt</description></item><item><title>LastBattle | 登录流程(LS &amp; BS &amp; GS)</title><link>https://zfunnily.github.io/2020/11/lastbattlelogin/</link><pubDate>Fri, 20 Nov 2020 17:27:08 +0000</pubDate><guid>https://zfunnily.github.io/2020/11/lastbattlelogin/</guid><description>登录流程 根据上一篇文章中的登录流程,我在工程中找到了相应的代码并记录了下来 登录服务代码解析 监听端口：49997 供BS服务连接 监听端口：49996 供客户端连接 CIocpCtrl：IOCP控制类 多线程循环</description></item><item><title>LastBattle | 服务架构</title><link>https://zfunnily.github.io/2020/11/lastbattleserver/</link><pubDate>Fri, 20 Nov 2020 17:24:32 +0000</pubDate><guid>https://zfunnily.github.io/2020/11/lastbattleserver/</guid><description>服务器架构简图如下: 连线说明： 实线：表示客户端登录流程，①②③④⑤表示登录流程，详细解释见下文。 虚线：表示服务器间的连接，虚线箭头指向监听方。 架构说明： |英文名称|简称|中文名称|功能简介|单个大区需</description></item><item><title>LastBattle | 安装部署笔记</title><link>https://zfunnily.github.io/2020/11/lastbattleone/</link><pubDate>Mon, 16 Nov 2020 06:49:49 +0000</pubDate><guid>https://zfunnily.github.io/2020/11/lastbattleone/</guid><description>环境准备 win10 服务器：vs2010 / 数据库 mysql5.7 清华大学mysql镜像网站:https://mirrors.tuna.tsinghua.edu.cn/mysql/downloads/MySQL-5.7/ 客户端</description></item></channel></rss>