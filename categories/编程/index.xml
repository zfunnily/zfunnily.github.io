<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>编程 on Zzz记忆</title>
    <link>https://blog.rakfree.tk/categories/%E7%BC%96%E7%A8%8B/</link>
    <description>Recent content in 编程 on Zzz记忆</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Sat, 09 Apr 2022 11:55:55 +0800</lastBuildDate><atom:link href="https://blog.rakfree.tk/categories/%E7%BC%96%E7%A8%8B/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>《Unity Shader入门精要》第二章 | 渲染流水线</title>
      <link>https://blog.rakfree.tk/2022/04/shader03/</link>
      <pubDate>Sat, 09 Apr 2022 11:55:55 +0800</pubDate>
      
      <guid>https://blog.rakfree.tk/2022/04/shader03/</guid>
      <description>渲染流水线 Render-Time Rendering, Third Edition》一书中将一个渲染流程分成3个阶段：应用阶段（Application Stage） 、几何阶段（Geometry Stage） 、光栅化阶段（Rasterizer Stage） 。 应</description>
    </item>
    
    <item>
      <title>shader初尝试 ｜ 给石头覆盖一层雪景(Hello World)</title>
      <link>https://blog.rakfree.tk/2022/04/shader02/</link>
      <pubDate>Sat, 09 Apr 2022 10:34:56 +0800</pubDate>
      
      <guid>https://blog.rakfree.tk/2022/04/shader02/</guid>
      <description>给石头覆盖一层雪景 资源准备 石头模型 Unity2021.2.3f1c1 Mac &amp;amp; Windows 在Unity中创建一个项目，导入石头模型，下面就开始利用shader给石头做一个雪景覆盖. 实现效果 未覆盖雪景的样子 覆盖了雪景的样子 开始代码 我在代码中标注了1，</description>
    </item>
    
    <item>
      <title>UnityShader基本概念</title>
      <link>https://blog.rakfree.tk/2022/04/shader01/</link>
      <pubDate>Wed, 06 Apr 2022 11:54:02 +0800</pubDate>
      
      <guid>https://blog.rakfree.tk/2022/04/shader01/</guid>
      <description>何为shader shader中文翻译为着色器，其实是一种用来渲染图形的技术，我们可以通过shader编程，来自定义显卡渲染画面的算法，显示我们所期望的结果。 shader种类 顶点着色器: 处理每个顶点，将</description>
    </item>
    
    <item>
      <title>抽卡逻辑自述</title>
      <link>https://blog.rakfree.tk/2022/03/afk/</link>
      <pubDate>Wed, 30 Mar 2022 10:50:11 +0800</pubDate>
      
      <guid>https://blog.rakfree.tk/2022/03/afk/</guid>
      <description>抽卡逻辑自述 参考《剑与远征》 卡牌颜色以及合成 颜色 合成 绿色 可分解，得到粉尘和银瓜子, 最基础的卡 蓝 蓝+ 同样的三张蓝色可合成一张蓝+ 紫 同种族的三张蓝+可以合成一张紫(可以选择合成其中蓝+的某个紫色) 紫+ 同英</description>
    </item>
    
    <item>
      <title>层级时间轮 ｜ skynet 定时器</title>
      <link>https://blog.rakfree.tk/2022/03/timerskynet/</link>
      <pubDate>Sun, 27 Mar 2022 12:39:12 +0800</pubDate>
      
      <guid>https://blog.rakfree.tk/2022/03/timerskynet/</guid>
      <description>skynet定时器 要解析一个程序代码，先了解数据结构，这是基础，再看函数。 拿skynet定时器举例子。 数据结构 //定时器事件 用于抛出定时器事件到消息队列里。理解这个数据结构需要先了解skynet的框架</description>
    </item>
    
    <item>
      <title>利用时间轮实现定时器</title>
      <link>https://blog.rakfree.tk/2022/03/timer/</link>
      <pubDate>Thu, 10 Mar 2022 14:38:23 +0800</pubDate>
      
      <guid>https://blog.rakfree.tk/2022/03/timer/</guid>
      <description>理解定时器 适用场景 定时任务(每隔1s钟打印一次数据) 超时控制(xx分钟没有动作就断开连接) 频率限制(最快只能每5s调用一次API) 定时器常用的数据结构有如下几种： 链表 双向有序链表 最小堆 时间轮 层级时间轮</description>
    </item>
    
    <item>
      <title>Nginx | 给网站添加证书</title>
      <link>https://blog.rakfree.tk/2022/03/https/</link>
      <pubDate>Thu, 03 Mar 2022 10:26:56 +0800</pubDate>
      
      <guid>https://blog.rakfree.tk/2022/03/https/</guid>
      <description>Https 最近在购买的云服务器上把个人博客搭建起来了，实际上是hugo生成静态网页，nginx加载静态网页。现在只能通过http访问，缺少个https。 要搭建一个https的网站需要证书。之前在网上找的教程太</description>
    </item>
    
    <item>
      <title>Golang | http注解路由</title>
      <link>https://blog.rakfree.tk/2022/03/http/</link>
      <pubDate>Wed, 02 Mar 2022 14:51:22 +0800</pubDate>
      
      <guid>https://blog.rakfree.tk/2022/03/http/</guid>
      <description>Http服务器 Golang有一个很强大的官方http库了，使用上很方便。也有一些很强大的三方http框架， 比如gin，beego等等。 自以为，框架在提供便利，提升开发效率的同时，也限制了我们的想象力。</description>
    </item>
    
    <item>
      <title>Goang | Plugin插件热更</title>
      <link>https://blog.rakfree.tk/2022/03/reload/</link>
      <pubDate>Tue, 01 Mar 2022 11:33:22 +0800</pubDate>
      
      <guid>https://blog.rakfree.tk/2022/03/reload/</guid>
      <description>热更新 动态脚本更新 (php) 短链接无状态服务器热更 (http) 长连接有状态，数据跟逻辑分离 golang Plugin热更 (.so 动态库更新) &amp;mdash;-逻辑热更 长连接有状态,在运维层面, 利用容器部署热更(docker, k8s) 服务不接受新</description>
    </item>
    
    <item>
      <title>Grpc | Token认证和自定义认证</title>
      <link>https://blog.rakfree.tk/2022/02/jwt/</link>
      <pubDate>Tue, 22 Feb 2022 15:39:30 +0800</pubDate>
      
      <guid>https://blog.rakfree.tk/2022/02/jwt/</guid>
      <description>概述 现在有个需求，需要在grpc的拦截器中，通过token进行身份认证。如果认证不通过则返回错误; 认证通过，则放行; TLS是用作加密通讯通道的，与该需求无关。 Token认证 具体流程 客户端通过账号密码登</description>
    </item>
    
    <item>
      <title>Grpc ｜ 通过SSL/TLS建立安全连接</title>
      <link>https://blog.rakfree.tk/2022/02/san/</link>
      <pubDate>Tue, 22 Feb 2022 14:22:41 +0800</pubDate>
      
      <guid>https://blog.rakfree.tk/2022/02/san/</guid>
      <description>使用golang的grpc库作为例子 grpc使用TLS建立安全连接需要有SAN证书， go 1.15 版本开始废弃 CommonName。 什么是SAN证书 SAN(Subject Alternative Name) 是 SSL 标准 x509 中定义的一个扩展。使用了 SAN 字段的 SSL 证书，可以扩</description>
    </item>
    
    <item>
      <title>Blog | 代码显示/隐藏</title>
      <link>https://blog.rakfree.tk/2021/12/shortcodes/</link>
      <pubDate>Wed, 29 Dec 2021 13:50:28 +0800</pubDate>
      
      <guid>https://blog.rakfree.tk/2021/12/shortcodes/</guid>
      <description>缘由 最近在写技术博客时，引入的代码太多，影响观感。 在尽力减少代码量，还是有些不可或缺的代码，代码量很惊人，已经占满整个屏幕. 因为个人博客是使用hugo生成的静态博客，我刚开始想的使用原生的js和css</description>
    </item>
    
    <item>
      <title>Nginx的一些配置</title>
      <link>https://blog.rakfree.tk/2021/12/nginx/</link>
      <pubDate>Tue, 28 Dec 2021 16:04:10 +0800</pubDate>
      
      <guid>https://blog.rakfree.tk/2021/12/nginx/</guid>
      <description>静态网站 应用场景 文件服务 静态网站 &amp;hellip; 静态网站的配置 配置如下: nginx.conf worker_processes 1; pid nginx.pid; events { worker_connections 1024; multi_accept on; } http { default_type application/octet-stream; sendfile on; keepalive_timeout 100; server { listen 80; charset utf-8,gbk; server_name localhost; location /{ root /opt/; autoindex on; autoindex_localtime on; } index index.html; # 显示首页 #静态文件访问 location ~* ^.+\.(jpg|jpeg|gif|png|ico|css|js|pdf|txt) { root /opt; } } } root: 表示网站根目录 autoindex: on 显</description>
    </item>
    
    <item>
      <title>A*算法 | Lua版本</title>
      <link>https://blog.rakfree.tk/2021/12/astar/</link>
      <pubDate>Thu, 23 Dec 2021 16:37:44 +0800</pubDate>
      
      <guid>https://blog.rakfree.tk/2021/12/astar/</guid>
      <description>A*算法思路 寻路步骤 从起点A开始, 把它作为待处理的方格存入一个&amp;quot;开启列表&amp;quot;, 开启列表就是一个等待检查方格的列表. 寻找起点A周围可以到达的方格, 将它们放入&amp;quot;开启列表&amp;quo</description>
    </item>
    
    <item>
      <title>Blog | 音乐播放器</title>
      <link>https://blog.rakfree.tk/2021/12/music/</link>
      <pubDate>Tue, 21 Dec 2021 16:55:23 +0800</pubDate>
      
      <guid>https://blog.rakfree.tk/2021/12/music/</guid>
      <description>概述 今天给我的个人博客加了个暗模式，这样可以在晚上阅读博客的时候不伤害眼睛。突然想到如果在阅读博客的时候可以听听音乐就更好了。 于是在github上找到了一个开源的项目MetingJS，看最后一次com</description>
    </item>
    
    <item>
      <title>Blog | 网站暗模式</title>
      <link>https://blog.rakfree.tk/2021/12/dark/</link>
      <pubDate>Tue, 21 Dec 2021 11:05:00 +0800</pubDate>
      
      <guid>https://blog.rakfree.tk/2021/12/dark/</guid>
      <description>Wordpress 如果你的网站是wordpress，则可以参考以Darkmode.js为基础的插件: blackout-darkmode-widget darkmode Nuxt.js 如果你正在使用Nuxt.js,则可以使用下面的模块 nuxtjs-darkmode-js-module 快速使用 使用Darkmode.js给网站快速部署上暗/浅色</description>
    </item>
    
    <item>
      <title>Openresty三 | 上传文件</title>
      <link>https://blog.rakfree.tk/2021/12/openresty-upload/</link>
      <pubDate>Wed, 08 Dec 2021 16:42:17 +0800</pubDate>
      
      <guid>https://blog.rakfree.tk/2021/12/openresty-upload/</guid>
      <description>上传文件接口 nginx.conf 的server 增加一个location: location /upload { resolver 8.8.8.8 ipv6=off; content_by_lua_file lua/upload.lua; } upload.lua lua -- upload.lua --========================================== -- 文件上传 --========================================== local chunk_size = 4096 local form, err = upload:new(chunk_size) if not form then ngx.log(ngx.ERR, &amp;#34;failed to new upload: &amp;#34;, err) ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR) end form:set_timeout(1000) -- 文件保存的根路径 local saveRootPath = &amp;#34;./download/&amp;#34; -- 保存的文件对象 local fileToSave --文件是否成</description>
    </item>
    
    <item>
      <title>Webrtc二 | 共享桌面</title>
      <link>https://blog.rakfree.tk/2021/11/webrtcdesk/</link>
      <pubDate>Mon, 15 Nov 2021 11:23:24 +0800</pubDate>
      
      <guid>https://blog.rakfree.tk/2021/11/webrtcdesk/</guid>
      <description>环境 Ubuntu18.04 webrtc M84 改造peerconnection例子，用来实现桌面共享 改造类CapturerTrackSource 增加桌面的数据源类RcrtcDesktopCapturerTrackSource 继承webr</description>
    </item>
    
    <item>
      <title>Webrtc一 | peerconnection</title>
      <link>https://blog.rakfree.tk/2021/11/webrtcpeerconnection/</link>
      <pubDate>Sun, 14 Nov 2021 16:20:31 +0800</pubDate>
      
      <guid>https://blog.rakfree.tk/2021/11/webrtcpeerconnection/</guid>
      <description>环境 Ubuntu18.04 webrtc M84 国内镜像：https://webrtc.org.cn/mirror/ webrtc交互过程 通过peerconnection的例子来分析webrtc的交互流程 peer_connection 解析 为了便于管理，如编码，回显等，</description>
    </item>
    
    <item>
      <title>Go-libp2p四 | 穿透NAT</title>
      <link>https://blog.rakfree.tk/2021/11/gop2pfour/</link>
      <pubDate>Sun, 07 Nov 2021 15:49:46 +0800</pubDate>
      
      <guid>https://blog.rakfree.tk/2021/11/gop2pfour/</guid>
      <description>本文目的 上文Go-libp2p三 | relay例子已经分析过relay例子，并解释了两个节点如果通过中继服务进行通信。本文改造relay例子 并让这个服务做如下两件事： 交换两个节点的在交换机上的信息，帮助</description>
    </item>
    
    <item>
      <title>Blog | 随机名人名言</title>
      <link>https://blog.rakfree.tk/2021/11/randomquotes/</link>
      <pubDate>Fri, 05 Nov 2021 15:50:16 +0800</pubDate>
      
      <guid>https://blog.rakfree.tk/2021/11/randomquotes/</guid>
      <description>本文目的 我的个人博客已经搭建好了，使用的hugo+飞雪的主题。我看到有些博客上有些随机的名人名言，但是这个主题没有。遂自己写一个。 根据飞雪的主题自定义 飞雪主题的github: https://github.com/flysnow-org/maupassant-hugo 复制主题里的文件them</description>
    </item>
    
    <item>
      <title>Go-libp2p三 | relay例子</title>
      <link>https://blog.rakfree.tk/2021/10/gop2pthree/</link>
      <pubDate>Sun, 31 Oct 2021 10:13:40 +0800</pubDate>
      
      <guid>https://blog.rakfree.tk/2021/10/gop2pthree/</guid>
      <description>我想做什么 chat和echo两个例子，说明了两个节点之间的通信需要两节点在同一个局域网内，或者有一个节点有公网。 如果我两个节点分别在两个NAT下面, 都在各自的局域网内，则需要有一个中继服务，这个服务做</description>
    </item>
    
    <item>
      <title>Go-libp2p二 | echo例子</title>
      <link>https://blog.rakfree.tk/2021/10/gop2ptwo/</link>
      <pubDate>Fri, 29 Oct 2021 11:15:42 +0800</pubDate>
      
      <guid>https://blog.rakfree.tk/2021/10/gop2ptwo/</guid>
      <description>go-libp2p的echo例子分析 进入目录go-libp2p/examples/echo/, 编译 go build 先看README.md， 可以了解到使用echo的方式: 终端B $ ./echo -l 3001 2021/10/28 11:25:33 I am /ip4/127.0.0.1/tcp/3001/p2p/QmTu8sxDi3fSjz9ZMvkAj3qA9YAoGskroEnyLz2ZvfTBhX 2021/10/28 11:25:33 listening for connections 2021/10/28 11:25:33 Now run &amp;#34;./echo</description>
    </item>
    
    <item>
      <title>Go-libp2p一 | chat例子</title>
      <link>https://blog.rakfree.tk/2021/10/gop2pone/</link>
      <pubDate>Thu, 28 Oct 2021 14:40:02 +0800</pubDate>
      
      <guid>https://blog.rakfree.tk/2021/10/gop2pone/</guid>
      <description>代码下载 git clone https://github.com/libp2p/go-libp2p.git chat实例分析 进入目录go-libp2p/examples/chat/, 编译 go build 先看README.md， 可以了解到使用chat的方式 在节点 B $ ./chat -sp 3001 2021/10/28 11:01:25 Run &amp;#39;./chat -d /ip4/127.0.0.1/tcp/3001/p2p/QmXgEXt4CiqmVmDhPPQnyVkoj3Bsx3Nggq57PPsk5tLNTs&amp;#39; on another console. 2021/10/28 11:01:25 You can replace 127.0.0.1 with public IP</description>
    </item>
    
    <item>
      <title>Skynet源码赏析四 | 消息调度</title>
      <link>https://blog.rakfree.tk/2021/10/four/</link>
      <pubDate>Thu, 21 Oct 2021 10:06:39 +0800</pubDate>
      
      <guid>https://blog.rakfree.tk/2021/10/four/</guid>
      <description>服务间消息流转 发送消息 数据结构message_queue *q是次级消息队列，每个服务都有与之绑定的唯一一个次级消息队列。当我们在lua层，调用skynet.send(...), 或者调用skynet.c</description>
    </item>
    
    <item>
      <title>Skynet源码赏析三 | 服务启动</title>
      <link>https://blog.rakfree.tk/2021/10/skynetthree/</link>
      <pubDate>Wed, 20 Oct 2021 11:26:07 +0800</pubDate>
      
      <guid>https://blog.rakfree.tk/2021/10/skynetthree/</guid>
      <description>skynet启动一个C服务 查看怎么启动C服务的最好的办法是打断点，看源码。 启动logger日志服务 我拿日志服务来举例子，怎么启动日志服务的呢？ 传参数name = &amp;quot;logger&amp;quot;, param = null， struct skynet_context *ctx = skynet_context_new(config-&amp;gt;logservice, config-&amp;gt;logger);; 从module</description>
    </item>
    
    <item>
      <title>Skynet源码赏析二 | 基础数据结构</title>
      <link>https://blog.rakfree.tk/2021/10/skynettwo/</link>
      <pubDate>Tue, 19 Oct 2021 18:47:45 +0800</pubDate>
      
      <guid>https://blog.rakfree.tk/2021/10/skynettwo/</guid>
      <description>module管理模块 我们所写的C服务编译成.so文件后放在cpath变量路径下，程序会加载路径cpath = root..&amp;quot;cservice/?.so&amp;quot;下的.so文件，通过static</description>
    </item>
    
    <item>
      <title>Skynet源码赏析一 | 启动初始化的过程</title>
      <link>https://blog.rakfree.tk/2021/10/skynetone/</link>
      <pubDate>Tue, 19 Oct 2021 17:28:45 +0800</pubDate>
      
      <guid>https://blog.rakfree.tk/2021/10/skynetone/</guid>
      <description>入口文件 skynet_main.c 加载配置 struct skynet_config config; config.thread = optint(&amp;#34;thread&amp;#34;,8); config.module_path = optstring(&amp;#34;cpath&amp;#34;,&amp;#34;./cservice/?.so&amp;#34;); config.harbor = optint(&amp;#34;harbor&amp;#34;, 1); config.bootstrap = optstring(&amp;#34;bootstrap&amp;#34;,&amp;#34;snlua bootstrap&amp;#34;); config.daemon = optstring(&amp;#34;daemon&amp;#34;, NULL); config.logger = optstring(&amp;#34;logger&amp;#34;, NULL); config.logservice = optstring(&amp;#34;logservice&amp;#34;, &amp;#34;logger&amp;#34;); config.profile = optboolean(&amp;#34;profile&amp;#34;, 1); 从上述代码可以看到，配置都已经加载到变量struct skynet_config config;中了。 初始化 初始化skynet_context管</description>
    </item>
    
    <item>
      <title>Golang | 调用带有后台进程shell脚本可能会被挂起</title>
      <link>https://blog.rakfree.tk/2021/10/shell/</link>
      <pubDate>Wed, 13 Oct 2021 17:15:45 +0800</pubDate>
      
      <guid>https://blog.rakfree.tk/2021/10/shell/</guid>
      <description>起因 今天用Golang写一个调用外部shell脚本的程序，使用 exec.Command方法，这段脚本代码中包含了一个后台任务语句。 结果发生了一个问题：cmd.Output 始终不会返回，一直挂起。导致我</description>
    </item>
    
    <item>
      <title>FPS游戏 | 实现移动功能</title>
      <link>https://blog.rakfree.tk/2021/09/move/</link>
      <pubDate>Sun, 12 Sep 2021 20:43:34 +0800</pubDate>
      
      <guid>https://blog.rakfree.tk/2021/09/move/</guid>
      <description>三种实现FPS Controller的区别 Transform Translate 允许移动物理，但无物理碰撞 Rigid body + Capsule Collider 符合物理学 不会鬼穿墙 无法滞空运动 可与Physics Object 交互 Charactor Controller 不会鬼穿墙 提供的API相对多 无法与Physic objects</description>
    </item>
    
    <item>
      <title>免费Music</title>
      <link>https://blog.rakfree.tk/2021/09/music/</link>
      <pubDate>Wed, 08 Sep 2021 14:47:14 +0800</pubDate>
      
      <guid>https://blog.rakfree.tk/2021/09/music/</guid>
      <description>介绍一个可以免费听音乐的方法 环境 docker mac 安装 $ docker run -d -p 264:264 -p 9000:9000 -v $dir_name:/var/www/html/cache --name music oldiy/music-player-docker $dir_name 是 你自己宿主机的目录。可以自定义 访问：127.0.0.1:264 就可以放心使用， 同事推荐的，贼好用。</description>
    </item>
    
    <item>
      <title>Unity3D | Transform类</title>
      <link>https://blog.rakfree.tk/2021/09/transform/</link>
      <pubDate>Tue, 07 Sep 2021 15:55:59 +0800</pubDate>
      
      <guid>https://blog.rakfree.tk/2021/09/transform/</guid>
      <description>Transform类 在unity中，把transform类理解为，transform类是在每个对象生成时自动附加的一个类。在Unity的视图中，点击Hierarchy中的对象，就可以在Inspecto</description>
    </item>
    
    <item>
      <title>Unity3D | UGUI</title>
      <link>https://blog.rakfree.tk/2021/08/ugui/</link>
      <pubDate>Fri, 20 Aug 2021 14:15:41 +0800</pubDate>
      
      <guid>https://blog.rakfree.tk/2021/08/ugui/</guid>
      <description>Text Text的属性 在 Unity 的 Hierarchy 面板上右键–&amp;gt;UI–&amp;gt;Text, 在 Inspector 面板上查看属性 属性 功能 Text 需要显示的文本 Font 显示文本的字体 如：微软雅黑，宋体等 Font Style 显示文本的样式，有普通，粗体，斜体，粗体和斜体四种</description>
    </item>
    
    <item>
      <title>Golang | redis实现分布式锁</title>
      <link>https://blog.rakfree.tk/2021/06/distribute/</link>
      <pubDate>Thu, 03 Jun 2021 16:12:21 +0000</pubDate>
      
      <guid>https://blog.rakfree.tk/2021/06/distribute/</guid>
      <description>概述 网上有很多Golang操作redis的例子，我使用github.com/gomodule/redigo/redis包写一个关于redis分布式锁的问题。 redis分布式锁 锁需要的几个组件 获取锁- 删</description>
    </item>
    
    <item>
      <title>Golang | redis</title>
      <link>https://blog.rakfree.tk/2021/06/goredis/</link>
      <pubDate>Thu, 03 Jun 2021 15:57:14 +0800</pubDate>
      
      <guid>https://blog.rakfree.tk/2021/06/goredis/</guid>
      <description>概述 网上有很多golang操作redis的例子，我使用github.com/gomodule/redigo/redis包写一个关于redis分布式锁的问题。 redis分布式锁 锁需要的几个组件 获取锁 删除</description>
    </item>
    
    <item>
      <title>Lua | next的使用</title>
      <link>https://blog.rakfree.tk/2021/05/lua_next/</link>
      <pubDate>Mon, 10 May 2021 16:39:50 +0800</pubDate>
      
      <guid>https://blog.rakfree.tk/2021/05/lua_next/</guid>
      <description>lua_next lua_next(L,index)：先把 表(lua栈 index所指的表), 的当前索引弹出，再把table 当前索引的值弹出，也就是先弹出 table的索引，再弹出table索引的值 举例： local t = { [&amp;#34;a&amp;#34;] = 1, [&amp;#34;b&amp;#34;]</description>
    </item>
    
    <item>
      <title>Lua | API</title>
      <link>https://blog.rakfree.tk/2021/05/settopandpop/</link>
      <pubDate>Mon, 10 May 2021 15:57:03 +0800</pubDate>
      
      <guid>https://blog.rakfree.tk/2021/05/settopandpop/</guid>
      <description>lua_pop和lua_settop lua_settop 我们直接来看lua_settop，文档解释 /* 设置栈的高度，如果之前的栈顶比新设置的更高，那么高出来的元素会被丢弃，反之压入nil来补足大小 假设栈里有2个元素。 如果</description>
    </item>
    
    <item>
      <title>Golang | gomod拉取私有仓库</title>
      <link>https://blog.rakfree.tk/2021/03/gomod/</link>
      <pubDate>Tue, 23 Mar 2021 16:10:02 +0000</pubDate>
      
      <guid>https://blog.rakfree.tk/2021/03/gomod/</guid>
      <description>概述 在使用go mod的过程中，依赖的包往往是第三方库，当我们自定义一个包并且放在github.com私有仓库时候，按照原来的方法则会有如下问题。 get &amp;#34;gitlab.com/xxx/zz&amp;#34;: found meta tag get.metaImport{Prefix:&amp;#34;gitlab.com/xxx/zz&amp;#34;, VCS:&amp;#34;git&amp;#34;, RepoRoot:&amp;#34;https://gitlab.com/xxx/zz.git&amp;#34;} at //gitlab.com/xxx/zz?go-get=1 verifying gitlab.com/xxx/zz@v0.0.1: gitlab.com/xxx/zz@v0.0.1: reading https://sum.golang.org/lookup/gitlab.com/xxx/zz@v0.0.1: 410 Gone 这个错误是因为新版本g</description>
    </item>
    
    <item>
      <title>八个基础排序</title>
      <link>https://blog.rakfree.tk/2021/03/sort/</link>
      <pubDate>Tue, 23 Mar 2021 10:13:31 +0000</pubDate>
      
      <guid>https://blog.rakfree.tk/2021/03/sort/</guid>
      <description>sort排序 std::sort( )函数是库函数提供的排序函数，必须包括头文件#include &amp;lt;algorithm&amp;gt;，它使用的排序方法是类似于快排的方法，时间复杂度为n*log2(n) Sort函数有三个参数：</description>
    </item>
    
    <item>
      <title>《仙剑奇侠传》编译运行</title>
      <link>https://blog.rakfree.tk/2021/03/gamexian/</link>
      <pubDate>Sun, 21 Mar 2021 10:44:58 +0000</pubDate>
      
      <guid>https://blog.rakfree.tk/2021/03/gamexian/</guid>
      <description>概述 今天在github上找到了《仙剑奇侠传》的rpg单机游戏sdlpal，sdlpal 是一个开源项目，基于sdl把仙剑奇侠传重写了一遍。 下面是我的编译过程总结。 环境 win10- sdl1.2- sdlpal- vs2017- DirectX SDK10 下载sdlpal $ git clone https://github.com.cnpmjs.org/sdlpal/sdlpal.git</description>
    </item>
    
    <item>
      <title>实现atoi和itoa函数</title>
      <link>https://blog.rakfree.tk/2021/03/atoianditoa/</link>
      <pubDate>Wed, 17 Mar 2021 16:43:20 +0000</pubDate>
      
      <guid>https://blog.rakfree.tk/2021/03/atoianditoa/</guid>
      <description>题目1： 把字符串转化为整数 有整数字符串，&amp;quot;13579&amp;quot;, 和 &amp;quot;246810&amp;quot;. 请写一个函数把这两个字符串转化为整数 步骤： 先判断正负 遍历字符串，转换字符为整数 //atoi.cc #include &amp;lt;stdio.h&amp;gt; int my_atoi(char *str) { bool bmin = false; int result = 0; //先判断正</description>
    </item>
    
    <item>
      <title>协程解析二 | 云风的coroutine</title>
      <link>https://blog.rakfree.tk/2021/03/coroutinetwo/</link>
      <pubDate>Wed, 10 Mar 2021 11:11:47 +0000</pubDate>
      
      <guid>https://blog.rakfree.tk/2021/03/coroutinetwo/</guid>
      <description>概述 云风的coroutine是通过ucontext来控制程序运行时上下文的，我们来根据该库提供的几个接口，和一个demo来解释协程的运行原理。如果不了解ucontext的，建议先了解ucontxt 环境</description>
    </item>
    
    <item>
      <title>协程解析一 | ucontext</title>
      <link>https://blog.rakfree.tk/2021/03/coroutineone/</link>
      <pubDate>Tue, 09 Mar 2021 09:43:00 +0000</pubDate>
      
      <guid>https://blog.rakfree.tk/2021/03/coroutineone/</guid>
      <description>概述 最近在研究协程的实现原理，看了云风的coroutine和腾讯的开源库libco后，原来要实现一个协程库也没那么难。我先来讲讲云风的coroutine库。他使用的是 uncontext来保存程序运行上</description>
    </item>
    
    <item>
      <title>Golang | 定时器</title>
      <link>https://blog.rakfree.tk/2021/02/timer/</link>
      <pubDate>Thu, 25 Feb 2021 16:02:13 +0000</pubDate>
      
      <guid>https://blog.rakfree.tk/2021/02/timer/</guid>
      <description>概述 golang有三种方式实现定时器： ticker timer select Ticker 通过 time.NewTicker(d)的方式实现定时器 d := time.Duration(time.Second * 2) t1 := time.NewTicker(d) defer t1.Stop() go func() { for { &amp;lt;- t1.C fmt.Println(&amp;#34;NewTicker...&amp;#34;) } }() Timer 通过 time.NewTimer(d)的方式实现定时器 t2 := time.NewTimer(d)</description>
    </item>
    
    <item>
      <title>Lua | 解决百元买鸡的问题</title>
      <link>https://blog.rakfree.tk/2021/02/chicken/</link>
      <pubDate>Wed, 24 Feb 2021 17:51:46 +0000</pubDate>
      
      <guid>https://blog.rakfree.tk/2021/02/chicken/</guid>
      <description>问题 编写lua程序求解百鸡百钱问题。公鸡5元一只，母鸡3元一只，小鸡一元3只，问100元钱买100只鸡，可买公鸡、母鸡、小鸡各多少只？ 代码 ----------------------------------------------------------------------------- --公鸡5元一只，母鸡3元一只，小鸡一元3只，问100元钱买</description>
    </item>
    
    <item>
      <title>Golang | JWT身份认证</title>
      <link>https://blog.rakfree.tk/2021/02/JWT/</link>
      <pubDate>Wed, 24 Feb 2021 14:22:04 +0000</pubDate>
      
      <guid>https://blog.rakfree.tk/2021/02/JWT/</guid>
      <description>概述 最近要在http接口上加一个token认证，但是接口很多，有没有一个省时省力的办法来解决。token的使用流程是： 用户使用帐号密码登陆到服务器1. 服务器验证登陆成功，根据帐号密码生成token。把</description>
    </item>
    
    <item>
      <title>Lua | 调用C/C&#43;&#43;的动态库</title>
      <link>https://blog.rakfree.tk/2021/02/dynamic/</link>
      <pubDate>Sat, 20 Feb 2021 11:11:51 +0000</pubDate>
      
      <guid>https://blog.rakfree.tk/2021/02/dynamic/</guid>
      <description>概述 最近在学习 云风的skynet库，想自定义一个模块，目标是使用lua调用C/C++所编写的库。 当我们需要在Lua里面调用c/c++函数时，所有的函数都必须满足以下函数签名： typedef int (*lua_CFunction) (lua_State *L); 换句话说，所有的</description>
    </item>
    
    <item>
      <title>汇编 | C/C&#43;&#43;调用汇编</title>
      <link>https://blog.rakfree.tk/2021/02/compilation/</link>
      <pubDate>Mon, 01 Feb 2021 14:40:51 +0000</pubDate>
      
      <guid>https://blog.rakfree.tk/2021/02/compilation/</guid>
      <description>概述 我使用AT&amp;amp;T的规范，在linux上完成 C和汇编的互相调用，并使用gcc编译成可执行文件。 目标：汇编函数提供输出。类似C语言的函数 void hello_world(char* value) { printf(value); } 提供给C语言调用： int main() { hello_world(&amp;#34;hello world!\n&amp;#34;); } 搭建AT&amp;amp</description>
    </item>
    
    <item>
      <title>汇编 | AT&amp;T和Intel规范的区别</title>
      <link>https://blog.rakfree.tk/2021/01/attandintel/</link>
      <pubDate>Sun, 31 Jan 2021 11:25:39 +0000</pubDate>
      
      <guid>https://blog.rakfree.tk/2021/01/attandintel/</guid>
      <description>概述 常见的指令集以及汇编语言规范： x86(IA-32)、x86-64指令集(常见于PC端)，对应有2家公司发布的不同汇编语言规范： intel公司发布的汇编语言规范，称intel 汇编：Windows派系</description>
    </item>
    
    <item>
      <title>Skynet | lua-protobuf</title>
      <link>https://blog.rakfree.tk/2021/01/skynetprotobuf/</link>
      <pubDate>Mon, 25 Jan 2021 14:25:07 +0000</pubDate>
      
      <guid>https://blog.rakfree.tk/2021/01/skynetprotobuf/</guid>
      <description>概述 在最新的skynet中我使用的是云风的pbc库来解析protobuf，该项目中的一个文件protobuf.lua 使用了module语法在lua5.1版本中已经删除，最新的skynet是lua5.4</description>
    </item>
    
    <item>
      <title>Protobuf | 请求参数为空的案例</title>
      <link>https://blog.rakfree.tk/2021/01/pbempty/</link>
      <pubDate>Fri, 22 Jan 2021 16:41:16 +0000</pubDate>
      
      <guid>https://blog.rakfree.tk/2021/01/pbempty/</guid>
      <description>参数为空的grpc请求怎么定义 google protobuf已经提供了空参数 //empty.proto message Empty {&amp;lt;!-- --&amp;gt;} 使用方法，在proto文件中导入empty.proto, 定义一个请求参数和返回值为空的函数emptyfunction， 函数名字</description>
    </item>
    
    <item>
      <title>Golang | C数组转化为Golang的切片类型</title>
      <link>https://blog.rakfree.tk/2021/01/goslience/</link>
      <pubDate>Fri, 22 Jan 2021 15:56:40 +0000</pubDate>
      
      <guid>https://blog.rakfree.tk/2021/01/goslience/</guid>
      <description>概述 最近在巩固cgo的基础知识，在网上看到一篇Go和C之间 字符串数组、切片类型转换的文章，让我想到我之前写的一篇在go中遍历C结构体数组的文章，让我有新的方法来解决之前的问题，把C的数组转化为Go的切</description>
    </item>
    
    <item>
      <title>Skynet | echo服务</title>
      <link>https://blog.rakfree.tk/2021/01/skynetecho/</link>
      <pubDate>Fri, 15 Jan 2021 16:07:51 +0000</pubDate>
      
      <guid>https://blog.rakfree.tk/2021/01/skynetecho/</guid>
      <description>概述 引用云风博客的话：“skynet 是一个为网络游戏服务器设计的轻量框架。但它本身并没有任何为网络游戏业务而特别设计的部分，所以尽可以把它用于其它领域。skynet 并不是一个开箱即用的引擎，使用它需要</description>
    </item>
    
    <item>
      <title>Redis源码分析 | ziplist</title>
      <link>https://blog.rakfree.tk/2021/01/ziplist/</link>
      <pubDate>Wed, 13 Jan 2021 17:52:27 +0000</pubDate>
      
      <guid>https://blog.rakfree.tk/2021/01/ziplist/</guid>
      <description>概述 Redis中的List是一个有序（按加入的时序排序）的数据结构，一般有序我们会采用数组或者是双向链表，其中双向链表由于有前后指针实际上会很浪费内存。3.2版本之前采用两种数据结构作为底层实现： 压缩</description>
    </item>
    
    <item>
      <title>Redis源码解析 | VScode调试</title>
      <link>https://blog.rakfree.tk/2021/01/vscodedebugredis/</link>
      <pubDate>Tue, 12 Jan 2021 14:25:29 +0000</pubDate>
      
      <guid>https://blog.rakfree.tk/2021/01/vscodedebugredis/</guid>
      <description>环境 vscode- gcc5.4 ubuntu16.04 或者 ubuntu18.04 make 下载6.2版本. 我使用的是国内github镜像地址：github.com.cnpmjs.org，速度比较快。 $ git clone https://github.com.cnpmjs.org/redis/redis.git redis $ git checkout -b 6.2 remotes/origin/6.2 vscode不参与编译，只充当可视化的调试工具。 使用</description>
    </item>
    
    <item>
      <title>VScode | 调试Redis源码，指针显示的问题</title>
      <link>https://blog.rakfree.tk/2021/01/vscoderedis/</link>
      <pubDate>Tue, 12 Jan 2021 14:17:22 +0000</pubDate>
      
      <guid>https://blog.rakfree.tk/2021/01/vscoderedis/</guid>
      <description>缘由 使用VScode的时候，断点看到指针显示的是一串地址，而不是指针指向的对象的值。上网找了一圈，没看到vscode有对应的插件来解决这个问题。vscode有对应的语法来解决这个问题。 网上几乎都在说在</description>
    </item>
    
    <item>
      <title>Cgo | 遍历C结构体数组</title>
      <link>https://blog.rakfree.tk/2021/01/cgostruct/</link>
      <pubDate>Mon, 11 Jan 2021 17:18:35 +0000</pubDate>
      
      <guid>https://blog.rakfree.tk/2021/01/cgostruct/</guid>
      <description>缘由 现在有个应用场景，我们要在go中获取C结构体数组中的值。在C语言中，对于结构体数组，我们可以利用指针的偏移量来获取我们想要的值的位置。在go中我们怎么使用C指针和偏移量进行运算呢？下面的文字中C指</description>
    </item>
    
    <item>
      <title>Redis源码解析 | sds</title>
      <link>https://blog.rakfree.tk/2021/01/sds/</link>
      <pubDate>Wed, 06 Jan 2021 14:20:23 +0000</pubDate>
      
      <guid>https://blog.rakfree.tk/2021/01/sds/</guid>
      <description>SDS头文件及作用 sds.h: sds声明- sdsalloc.h： 为sds分配内存 源码文件sds.h中有这样一行代码 typedef char *sds; 很清晰、明了，sds其实就是char*。 最新的6.2分支的代码： struct __attribute__ ((__packed__)) sdshdr5 {&amp;lt;!-- --&amp;gt; unsigned char flags; /* 3 lsb of</description>
    </item>
    
    <item>
      <title>struct中使用char[]</title>
      <link>https://blog.rakfree.tk/2021/01/chararray/</link>
      <pubDate>Tue, 05 Jan 2021 15:45:36 +0000</pubDate>
      
      <guid>https://blog.rakfree.tk/2021/01/chararray/</guid>
      <description>缘由 最近在看redis的源码，刚开始看sds，看到这块代码 struct __attribute__ ((__packed__)) sdshdr5 { unsigned char flags; /* 3 lsb of type, and 5 msb of string length */ char buf[]; }; 好奇为什么使用 char buf[],而不用char *buf，找到答案记录一下。 struct中的char*</description>
    </item>
    
    <item>
      <title>Lastbattle | 游戏场景服务器SS解析</title>
      <link>https://blog.rakfree.tk/2021/01/lastbattle/</link>
      <pubDate>Sat, 02 Jan 2021 23:19:58 +0000</pubDate>
      
      <guid>https://blog.rakfree.tk/2021/01/lastbattle/</guid>
      <description>游戏场景服务器概况 指令对应的处理handle的文件：SSBattleMgr.cpp 创建战场 指令： eMsgToSSFromCS_CreateBattle GC服务器发往SS fromCS 收到中心服务器CS创建站场的指令，在函数INT32 CSSBattleMgr::OnMsgFromCS_CreateBattle(const char* pData, int n32DataLengt</description>
    </item>
    
    <item>
      <title>CCnet | 单线程reactor演变为多线程</title>
      <link>https://blog.rakfree.tk/2020/12/ccnet/</link>
      <pubDate>Wed, 30 Dec 2020 09:19:41 +0000</pubDate>
      
      <guid>https://blog.rakfree.tk/2020/12/ccnet/</guid>
      <description>ccnet从单线程演变为多线程 ccnet现状： epoll linux平台 事件循环 单线程 reactor 监听和新连接的事件都在主线程中 单线程的ccnet ccnet的单线程的角色： EventLoop: 整个事件循环。 EPollPoller: 负责事件的收集。 Channel</description>
    </item>
    
    <item>
      <title>Golang | sync.Mutex详解</title>
      <link>https://blog.rakfree.tk/2020/12/syncmutex/</link>
      <pubDate>Tue, 29 Dec 2020 13:17:18 +0000</pubDate>
      
      <guid>https://blog.rakfree.tk/2020/12/syncmutex/</guid>
      <description>概述 自己做的一个golang项目需要优化，优化方向是减少gpu内存的使用。同一个模型被重复加载多次，使用更多的gpu内存，也增加 sync.Mutex的使用。 优化的方向是: 减少代码量的改动- 减少gpu内</description>
    </item>
    
    <item>
      <title>五种网络IO模型总结</title>
      <link>https://blog.rakfree.tk/2020/12/iomodels/</link>
      <pubDate>Mon, 28 Dec 2020 11:57:04 +0000</pubDate>
      
      <guid>https://blog.rakfree.tk/2020/12/iomodels/</guid>
      <description>概述 在网络上看到很多关于阻塞IO、非阻塞IO、同步IO、异步IO的例子，总觉得写的过于复杂并且让人难以理解。于是我把我自己把这几个概念的理解写下来以供参考。 POSIX POSIX(可移植操作系统接口)把同步IO</description>
    </item>
    
    <item>
      <title>CCnet | 一个reactor单线程网络库</title>
      <link>https://blog.rakfree.tk/2020/12/ccnetone/</link>
      <pubDate>Sun, 27 Dec 2020 18:41:25 +0000</pubDate>
      
      <guid>https://blog.rakfree.tk/2020/12/ccnetone/</guid>
      <description>缘由 最近在研究陈硕的网络库muduo，是一个基于reactor架构的网络库。我对网络库的感觉是易用，但是内容庞大，依赖颇多。比如boost网络库里面的一些语法让人生畏。关于reactor和proact</description>
    </item>
    
    <item>
      <title>C&#43;&#43; | vector中的resize()函数 VS reserve()函数</title>
      <link>https://blog.rakfree.tk/2020/12/reserve/</link>
      <pubDate>Fri, 25 Dec 2020 11:04:29 +0000</pubDate>
      
      <guid>https://blog.rakfree.tk/2020/12/reserve/</guid>
      <description>reserve void reserve (size_type n); reserver函数用来给vector预分配存储区大小，即capacity的值 ，但是没有给这段内存进行初始化。reserve 的参数n是推荐预分配内存的大小，实际分配的可能等于或大于这个值，即</description>
    </item>
    
    <item>
      <title>Golang | 用gocolly登录B站</title>
      <link>https://blog.rakfree.tk/2020/12/gocolly/</link>
      <pubDate>Sun, 13 Dec 2020 14:51:53 +0000</pubDate>
      
      <guid>https://blog.rakfree.tk/2020/12/gocolly/</guid>
      <description>概述 gocolly是golang语言开发的爬虫包，通过gocolly来进行模拟网站的登录， 目标已经确立，开始行动。 下载 $ go get -u github.com/gocolly/colly 获取cookie 登录网站：https://www.bilibili.co</description>
    </item>
    
    <item>
      <title>Protobuf | 沾包问题</title>
      <link>https://blog.rakfree.tk/2020/12/tcp/</link>
      <pubDate>Sun, 13 Dec 2020 10:22:38 +0000</pubDate>
      
      <guid>https://blog.rakfree.tk/2020/12/tcp/</guid>
      <description>缘由 最近在研究一款游戏的源码。发现里面的通信协议是protobuf定义的，但还是自己定义了协议头部，类似 head + body。先解析头部里所存储的整个包的数据长度，然后再解析包剩余的数据，这样做的目的是为了防</description>
    </item>
    
    <item>
      <title>Grpc | 概述</title>
      <link>https://blog.rakfree.tk/2020/12/grpc/</link>
      <pubDate>Sun, 13 Dec 2020 09:10:42 +0000</pubDate>
      
      <guid>https://blog.rakfree.tk/2020/12/grpc/</guid>
      <description>OverView gRPC是由Google主导开发的RPC框架，使用HTTP/2协议并用ProtoBuf作为序列化工具。其客户端提供Objective-C、Java接口，服务器侧则有Java、Golang、C++等接</description>
    </item>
    
    <item>
      <title>Openresty二 | postman小工具</title>
      <link>https://blog.rakfree.tk/2020/11/%E4%BD%BF%E7%94%A8OpenResty%E5%81%9A%E4%B8%80%E4%B8%AApostman%E5%B0%8F%E5%B7%A5%E5%85%B7/</link>
      <pubDate>Wed, 25 Nov 2020 16:30:39 +0800</pubDate>
      
      <guid>https://blog.rakfree.tk/2020/11/%E4%BD%BF%E7%94%A8OpenResty%E5%81%9A%E4%B8%80%E4%B8%AApostman%E5%B0%8F%E5%B7%A5%E5%85%B7/</guid>
      <description>用到的知识点 mvc架构 模型渲染库：https://github.com/bungle/lua-resty-template resty http请求库： https://github.com/bungle/lua-resty-template 参照 mvc模型来做postman工具 配置文件说明 worker_processes 1; error_log logs/error.log; events</description>
    </item>
    
    <item>
      <title>Openresty一 | 初探</title>
      <link>https://blog.rakfree.tk/2020/11/OpenResty%E5%88%9D%E6%8E%A2/</link>
      <pubDate>Mon, 23 Nov 2020 16:21:34 +0800</pubDate>
      
      <guid>https://blog.rakfree.tk/2020/11/OpenResty%E5%88%9D%E6%8E%A2/</guid>
      <description>概述 OpenResty®是一个基于Nginx与 Lua 的高性能 Web 平台，其内部集成了大量精良的 Lua 库、第三方模块以及大多数的依赖项。用于方便地搭建能够处理超高并发、扩展性极高的动态 Web 应用、Web 服务和动态网关。</description>
    </item>
    
    <item>
      <title>LastBattle | 登录流程(LS &amp; BS &amp; GS)</title>
      <link>https://blog.rakfree.tk/2020/11/lastbattlelogin/</link>
      <pubDate>Fri, 20 Nov 2020 17:27:08 +0000</pubDate>
      
      <guid>https://blog.rakfree.tk/2020/11/lastbattlelogin/</guid>
      <description>登录流程 根据上一篇文章中的登录流程,我在工程中找到了相应的代码并记录了下来 登录服务代码解析 监听端口：49997 供BS服务连接 监听端口：49996 供客户端连接 CIocpCtrl：IOCP控制类 多线程循环</description>
    </item>
    
    <item>
      <title>LastBattle | 服务架构</title>
      <link>https://blog.rakfree.tk/2020/11/lastbattleserver/</link>
      <pubDate>Fri, 20 Nov 2020 17:24:32 +0000</pubDate>
      
      <guid>https://blog.rakfree.tk/2020/11/lastbattleserver/</guid>
      <description>服务器架构简图如下: 连线说明： 实线：表示客户端登录流程，①②③④⑤表示登录流程，详细解释见下文。 虚线：表示服务器间的连接，虚线箭头指向监听方。 架构说明： |英文名称|简称|中文名称|功能简介|单个大区需</description>
    </item>
    
    <item>
      <title>LastBattle | 安装部署笔记</title>
      <link>https://blog.rakfree.tk/2020/11/lastbattleone/</link>
      <pubDate>Mon, 16 Nov 2020 06:49:49 +0000</pubDate>
      
      <guid>https://blog.rakfree.tk/2020/11/lastbattleone/</guid>
      <description>环境准备 win10 服务器：vs2010 / 数据库 mysql5.7 清华大学mysql镜像网站:https://mirrors.tuna.tsinghua.edu.cn/mysql/downloads/MySQL-5.7/ 客户端</description>
    </item>
    
    <item>
      <title>Cgo | 使用libevent库实现一个定时器</title>
      <link>https://blog.rakfree.tk/2020/11/cgo%E4%BD%BF%E7%94%A8libevent%E5%BA%93%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%AE%9A%E6%97%B6%E5%99%A8/</link>
      <pubDate>Fri, 13 Nov 2020 16:40:42 +0000</pubDate>
      
      <guid>https://blog.rakfree.tk/2020/11/cgo%E4%BD%BF%E7%94%A8libevent%E5%BA%93%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%AE%9A%E6%97%B6%E5%99%A8/</guid>
      <description>使用libevent库作为例子 下载 &amp;amp; 编译 &amp;amp; 安装libevent $ git clone https://github.com.cnpmjs.org/libevent/libevent.git $ cd libevent &amp;amp;&amp;amp; mkdir build &amp;amp;&amp;amp; cd build $ cmake .. $ make libevent实现的定时器 // main.cpp #include &amp;#34;event.h&amp;#34; struct event ev; struct timeval tv; void time_cb(evutil_socket_t fd, short event, void *argc) { printf(&amp;#34;timer wakeup\n&amp;#34;); event_add(&amp;amp;ev, &amp;amp;tv); // reschedule timer } int main() { struct event_base *base = event_base_new(); tv.tv_sec = 2;</description>
    </item>
    
    <item>
      <title>Golang | 利用指针进行数据转换</title>
      <link>https://blog.rakfree.tk/2020/11/Golang-%E5%88%A9%E7%94%A8%E6%8C%87%E9%92%88%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E8%BD%AC%E6%8D%A2/</link>
      <pubDate>Thu, 12 Nov 2020 17:19:07 +0000</pubDate>
      
      <guid>https://blog.rakfree.tk/2020/11/Golang-%E5%88%A9%E7%94%A8%E6%8C%87%E9%92%88%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E8%BD%AC%E6%8D%A2/</guid>
      <description>概述 在Go语言中，Slice本质是什么呢？是一个reflect.SliceHeader结构体和这个结构体中Data字段所指向的内存。String本质是什么呢？是一个reflect.StringHead</description>
    </item>
    
    <item>
      <title>Golang | builds</title>
      <link>https://blog.rakfree.tk/2020/11/go-builds/</link>
      <pubDate>Thu, 12 Nov 2020 17:15:17 +0000</pubDate>
      
      <guid>https://blog.rakfree.tk/2020/11/go-builds/</guid>
      <description>概述 通常我们会给每个产品环境设置不同的配置，比如 redis 要在开发环境就连接 localhost:6379，测试环境可能连接某一个主机的 redis。 如果放在 go 里面是否可行？因为 go 是编译二进制包，也没有动态加载这</description>
    </item>
    
    <item>
      <title>Cgo | 简单使用</title>
      <link>https://blog.rakfree.tk/2020/11/cgo%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Thu, 05 Nov 2020 09:45:23 +0000</pubDate>
      
      <guid>https://blog.rakfree.tk/2020/11/cgo%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</guid>
      <description>使用自己的C函数 文件名：testC.go package main /* #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;stdlib.h&amp;gt; void c_print(char *str) { printf(&amp;#34;%s\n&amp;#34;, str); } */ import &amp;#34;C&amp;#34; //import “C” 必须单起一行，并且紧跟在注释行之后 import &amp;#34;unsafe&amp;#34; func main() { s := &amp;#34;Hello Cgo&amp;#34; cs := C.CString(s) //字符串映射 C.c_print(cs) //调用C函数 defer C.free(unsafe.Pointer(cs)) //释放内存 } 说明： 1、g</description>
    </item>
    
    <item>
      <title>Golang | 使用Lumberjack&#43;zap进行日志切割归档</title>
      <link>https://blog.rakfree.tk/2020/11/%E4%BD%BF%E7%94%A8Lumberjack-zap%E8%BF%9B%E8%A1%8C%E6%97%A5%E5%BF%97%E5%88%87%E5%89%B2%E5%BD%92%E6%A1%A3/</link>
      <pubDate>Wed, 04 Nov 2020 12:44:03 +0000</pubDate>
      
      <guid>https://blog.rakfree.tk/2020/11/%E4%BD%BF%E7%94%A8Lumberjack-zap%E8%BF%9B%E8%A1%8C%E6%97%A5%E5%BF%97%E5%88%87%E5%89%B2%E5%BD%92%E6%A1%A3/</guid>
      <description>使用Lumberjack+zap进行日志切割归档 为了添加日志切割归档功能，我们将使用第三方库Lumberjack来实现。 安装 执行下面的命令安装Lumberjack go get -u github.com/natefinch/lumberjack zap logger中加入Lumbe</description>
    </item>
    
    <item>
      <title>TCP/IP | 大量TIME_WAIT对线上业务的影响</title>
      <link>https://blog.rakfree.tk/2020/10/%E5%A4%A7%E9%87%8FTIME_WAIT%E5%AF%B9%E7%BA%BF%E4%B8%8A%E4%B8%9A%E5%8A%A1%E7%9A%84%E5%BD%B1%E5%93%8D/</link>
      <pubDate>Sat, 10 Oct 2020 16:46:34 +0000</pubDate>
      
      <guid>https://blog.rakfree.tk/2020/10/%E5%A4%A7%E9%87%8FTIME_WAIT%E5%AF%B9%E7%BA%BF%E4%B8%8A%E4%B8%9A%E5%8A%A1%E7%9A%84%E5%BD%B1%E5%93%8D/</guid>
      <description>TCP的三次握手和四次挥手 TIME_WAIT概述 TIME_WAIT 状态： TCP 连接中，主动关闭连接的一方出现的状态；（收到 FIN 命令，进入 TIME_WAIT 状态，并返回 ACK 命令） 保持 2 个 MSL 时间，即，4 分钟 ；（MSL 为 2 分钟） TCP 连接建立后，「主</description>
    </item>
    
    <item>
      <title>Libevent | 定时器</title>
      <link>https://blog.rakfree.tk/2020/09/libeventimer/</link>
      <pubDate>Wed, 16 Sep 2020 23:20:28 +0000</pubDate>
      
      <guid>https://blog.rakfree.tk/2020/09/libeventimer/</guid>
      <description>libevent 实现定时器流程 首先初始化libevent库，并保存返回的指针 struct event_base * base = event_init(); 实际上这一步相当于初始化一个Reactor实例；在初始化libevent后，就可以注册事件了。 初始化事件event，设置回调函</description>
    </item>
    
    <item>
      <title>FFmpeg | 画中画和视频多宫格处理</title>
      <link>https://blog.rakfree.tk/2020/09/ffmpegpicture/</link>
      <pubDate>Mon, 14 Sep 2020 18:29:33 +0000</pubDate>
      
      <guid>https://blog.rakfree.tk/2020/09/ffmpegpicture/</guid>
      <description>FFmpeg生成画中画 静态画中画 将视频sub.mp4视频文件缩放成宽 480 、高 320 的视频,然后显示在 视频 input.mp4,x坐标为0,y 坐标为0 的位置 ffmpeg -re -i input.mp4 -vf &amp;#34;movie=sub.mp4, scale=480x320[test]; [in][test]overlay [out]&amp;#34; -vcodec libx264 output.flv 显示在画面的右下角，则需要用到</description>
    </item>
    
    <item>
      <title>FFmpeg | 给视频加文字和图片水印</title>
      <link>https://blog.rakfree.tk/2020/09/ffmpegvideo/</link>
      <pubDate>Sat, 12 Sep 2020 12:47:57 +0000</pubDate>
      
      <guid>https://blog.rakfree.tk/2020/09/ffmpegvideo/</guid>
      <description>FFmpeg给视频加上logo ffmpeg从视频中截取图像帧 ffmpeg -i inputfile.avi -r 1 -f image2 image-%05d.jpeg ffmpeg -i inputfile.avi -r 1 -s 4cif -f image2 image-%05d.jpeg ffmpeg -i inputfile.avi -r 1 -t 4 -f image2 image-%05d.jpeg ffmpeg -i inputfile.avi -r 1 -ss 01:30:14 -f image2 image-%05d.jpeg ffmpeg -i inputfile.avi -r 1 -ss 01:30:14 -vframes 120 4cif -f image2 image-%05d.jpeg -r 指定抽取的帧率，即从视频中每秒钟抽取</description>
    </item>
    
    <item>
      <title>FFmpeg | 录制摄像头和桌面数据windows</title>
      <link>https://blog.rakfree.tk/2020/09/ffmpegvideow/</link>
      <pubDate>Wed, 09 Sep 2020 09:36:49 +0000</pubDate>
      
      <guid>https://blog.rakfree.tk/2020/09/ffmpegvideow/</guid>
      <description>概述 FFmpeg Windows 设备操作 Windows 采集设备的主要方式是 dshow vfwcap gdigrab 其中 dshow 可以用来抓 取摄像头、采集卡、麦克风等，- vfwcap 主要用来采集摄像头类设备，- gdigrab 则是抓取 Windows 窗口程序 FFmpeg 使用 dshow 采集音视频设备 使用 dshow 枚举设备 ffmpeg -f dshow -list_devices true -i dymmy 输出 [dshow @ 000002622302e340]</description>
    </item>
    
    <item>
      <title>FFmpeg | 录制摄像头和桌面数据mac</title>
      <link>https://blog.rakfree.tk/2020/08/macffmpeg/</link>
      <pubDate>Sat, 29 Aug 2020 17:20:40 +0000</pubDate>
      
      <guid>https://blog.rakfree.tk/2020/08/macffmpeg/</guid>
      <description>设备枚举 查看设备列表 $ ffmpeg -hide_banner -devices Devices: D. = Demuxing supported .E = Muxing supported -- D avfoundation AVFoundation input device D lavfi Libavfilter virtual input device E sdl,sdl2 SDL2 output device 可以看到输入设备有：avfoundation，lavfi 输出设备有：sdl `` 设备采集举例： $ ffmpeg -f avfoundation -list_devices true -i &amp;#34; &amp;#34; 看到了 如下设</description>
    </item>
    
    <item>
      <title>Owt-server | owt-client-javascript</title>
      <link>https://blog.rakfree.tk/2020/08/owt-client-javascript/</link>
      <pubDate>Sun, 16 Aug 2020 23:04:13 +0000</pubDate>
      
      <guid>https://blog.rakfree.tk/2020/08/owt-client-javascript/</guid>
      <description>概述 天气燥热，不易出门。遂研究一下owt-server，从owt-client-javascript的流程开始吧。 获取一个会议室 owt-client-javascript的时候有一个初始化房间的过程 ///owt-client-javascript/src/samples/conference/samplertcservice.js</description>
    </item>
    
    <item>
      <title>Licod | 安装和配置</title>
      <link>https://blog.rakfree.tk/2020/08/licode/</link>
      <pubDate>Sun, 09 Aug 2020 09:34:36 +0000</pubDate>
      
      <guid>https://blog.rakfree.tk/2020/08/licode/</guid>
      <description>拉取docker镜像并运行 licode官方提供了配置好的docker镜像，使用以下命令拉下来跑就行。 docker run --name licode -p 3000:3000 -p $MIN_PORT-$MAX_PORT:30000-30050/udp -p 3001:3001 -p 8080:8080 -e &amp;#34;MIN_PORT=30000&amp;#34; -e &amp;#34;MAX_PORT=30050&amp;#34; -e &amp;#34;PUBLIC_IP=your_ip_address&amp;#34; lynckia/licode 注意命令里的PUBLIC_IP要改为服务器的公网IP。 配置好之</description>
    </item>
    
    <item>
      <title>Owt-server | 编译运行</title>
      <link>https://blog.rakfree.tk/2020/08/owtservercomplie/</link>
      <pubDate>Wed, 05 Aug 2020 09:47:22 +0000</pubDate>
      
      <guid>https://blog.rakfree.tk/2020/08/owtservercomplie/</guid>
      <description>概述 owt是一套完整的webrtc视频会议系统。包含的功能模块有： 视频会议1. p2p 服务器是owt-server通过nodejs编写的webrtc信令。依赖是licode。licode依赖webrtc。 客</description>
    </item>
    
  </channel>
</rss>
