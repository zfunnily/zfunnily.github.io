<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>编程 on Zzz记忆</title>
    <link>https://zfunnily.github.io/categories/%E7%BC%96%E7%A8%8B/</link>
    <description>Recent content in 编程 on Zzz记忆</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Wed, 29 Dec 2021 13:50:28 +0800</lastBuildDate><atom:link href="https://zfunnily.github.io/categories/%E7%BC%96%E7%A8%8B/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Blog | 代码显示/隐藏</title>
      <link>https://zfunnily.github.io/2021/12/shortcodes/</link>
      <pubDate>Wed, 29 Dec 2021 13:50:28 +0800</pubDate>
      
      <guid>https://zfunnily.github.io/2021/12/shortcodes/</guid>
      <description>缘由 最近在写技术博客时，引入的代码太多，影响观感。 在尽力减少代码量，还是有些不可或缺的代码，代码量很惊人，已经占满整个屏幕. 因为个人博客是使用hugo生成的静态博客，我刚开始想的使用原生的js和css</description>
    </item>
    
    <item>
      <title>Nginx的一些配置</title>
      <link>https://zfunnily.github.io/2021/12/nginx/</link>
      <pubDate>Tue, 28 Dec 2021 16:04:10 +0800</pubDate>
      
      <guid>https://zfunnily.github.io/2021/12/nginx/</guid>
      <description>静态网站 应用场景 文件服务 静态网站 &amp;hellip; 静态网站的配置 配置如下: nginx.conf worker_processes 1; pid nginx.pid; events { worker_connections 1024; multi_accept on; } http { default_type application/octet-stream; sendfile on; keepalive_timeout 100; server { listen 80; charset utf-8,gbk; server_name localhost; location /{ root /opt/; autoindex on; autoindex_localtime on; } index index.html; # 显示首页 #静态文件访问 location ~* ^.+\.(jpg|jpeg|gif|png|ico|css|js|pdf|txt) { root /opt; } } } root: 表示网站根目录 autoindex: on 显</description>
    </item>
    
    <item>
      <title>Blog | 音乐播放器</title>
      <link>https://zfunnily.github.io/2021/12/music/</link>
      <pubDate>Tue, 21 Dec 2021 16:55:23 +0800</pubDate>
      
      <guid>https://zfunnily.github.io/2021/12/music/</guid>
      <description>概述 今天给我的个人博客加了个暗模式，这样可以在晚上阅读博客的时候不伤害眼睛。突然想到如果在阅读博客的时候可以听听音乐就更好了。 于是在github上找到了一个开源的项目MetingJS，看最后一次com</description>
    </item>
    
    <item>
      <title>Blog | 网站暗模式</title>
      <link>https://zfunnily.github.io/2021/12/dark/</link>
      <pubDate>Tue, 21 Dec 2021 11:05:00 +0800</pubDate>
      
      <guid>https://zfunnily.github.io/2021/12/dark/</guid>
      <description>Wordpress 如果你的网站是wordpress，则可以参考以Darkmode.js为基础的插件: blackout-darkmode-widget darkmode Nuxt.js 如果你正在使用Nuxt.js,则可以使用下面的模块 nuxtjs-darkmode-js-module 快速使用 使用Darkmode.js给网站快速部署上暗/浅色</description>
    </item>
    
    <item>
      <title>Openresty三 | 上传文件</title>
      <link>https://zfunnily.github.io/2021/12/openresty-upload/</link>
      <pubDate>Wed, 08 Dec 2021 16:42:17 +0800</pubDate>
      
      <guid>https://zfunnily.github.io/2021/12/openresty-upload/</guid>
      <description>上传文件接口 nginx.conf 的server 增加一个location: location /upload { resolver 8.8.8.8 ipv6=off; content_by_lua_file lua/upload.lua; } upload.lua lua -- upload.lua --========================================== -- 文件上传 --========================================== local chunk_size = 4096 local form, err = upload:new(chunk_size) if not form then ngx.log(ngx.ERR, &amp;#34;failed to new upload: &amp;#34;, err) ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR) end form:set_timeout(1000) -- 文件保存的根路径 local saveRootPath = &amp;#34;./download/&amp;#34; -- 保存的文件对象 local fileToSave --文件是否成</description>
    </item>
    
    <item>
      <title>Blog | 随机名人名言</title>
      <link>https://zfunnily.github.io/2021/11/randomquotes/</link>
      <pubDate>Fri, 05 Nov 2021 15:50:16 +0800</pubDate>
      
      <guid>https://zfunnily.github.io/2021/11/randomquotes/</guid>
      <description>本文目的 我的个人博客已经搭建好了，使用的hugo+飞雪的主题。我看到有些博客上有些随机的名人名言，但是这个主题没有。遂自己写一个。 根据飞雪的主题自定义 飞雪主题的github: https://github.com/flysnow-org/maupassant-hugo 复制主题里的文件them</description>
    </item>
    
    <item>
      <title>Skynet源码赏析四 | 消息调度</title>
      <link>https://zfunnily.github.io/2021/10/four/</link>
      <pubDate>Thu, 21 Oct 2021 10:06:39 +0800</pubDate>
      
      <guid>https://zfunnily.github.io/2021/10/four/</guid>
      <description>服务间消息流转 发送消息 数据结构message_queue *q是次级消息队列，每个服务都有与之绑定的唯一一个次级消息队列。当我们在lua层，调用skynet.send(...), 或者调用skynet.c</description>
    </item>
    
    <item>
      <title>Skynet源码赏析三 | 服务启动</title>
      <link>https://zfunnily.github.io/2021/10/skynetthree/</link>
      <pubDate>Wed, 20 Oct 2021 11:26:07 +0800</pubDate>
      
      <guid>https://zfunnily.github.io/2021/10/skynetthree/</guid>
      <description>skynet启动一个C服务 查看怎么启动C服务的最好的办法是打断点，看源码。 启动logger日志服务 我拿日志服务来举例子，怎么启动日志服务的呢？ 传参数name = &amp;quot;logger&amp;quot;, param = null， struct skynet_context *ctx = skynet_context_new(config-&amp;gt;logservice, config-&amp;gt;logger);; 从module</description>
    </item>
    
    <item>
      <title>Skynet源码赏析二 | 基础数据结构</title>
      <link>https://zfunnily.github.io/2021/10/skynettwo/</link>
      <pubDate>Tue, 19 Oct 2021 18:47:45 +0800</pubDate>
      
      <guid>https://zfunnily.github.io/2021/10/skynettwo/</guid>
      <description>module管理模块 我们所写的C服务编译成.so文件后放在cpath变量路径下，程序会加载路径cpath = root..&amp;quot;cservice/?.so&amp;quot;下的.so文件，通过static</description>
    </item>
    
    <item>
      <title>Skynet源码赏析一 | 启动初始化的过程</title>
      <link>https://zfunnily.github.io/2021/10/skynetone/</link>
      <pubDate>Tue, 19 Oct 2021 17:28:45 +0800</pubDate>
      
      <guid>https://zfunnily.github.io/2021/10/skynetone/</guid>
      <description>入口文件 skynet_main.c 加载配置 struct skynet_config config; config.thread = optint(&amp;#34;thread&amp;#34;,8); config.module_path = optstring(&amp;#34;cpath&amp;#34;,&amp;#34;./cservice/?.so&amp;#34;); config.harbor = optint(&amp;#34;harbor&amp;#34;, 1); config.bootstrap = optstring(&amp;#34;bootstrap&amp;#34;,&amp;#34;snlua bootstrap&amp;#34;); config.daemon = optstring(&amp;#34;daemon&amp;#34;, NULL); config.logger = optstring(&amp;#34;logger&amp;#34;, NULL); config.logservice = optstring(&amp;#34;logservice&amp;#34;, &amp;#34;logger&amp;#34;); config.profile = optboolean(&amp;#34;profile&amp;#34;, 1); 从上述代码可以看到，配置都已经加载到变量struct skynet_config config;中了。 初始化 初始化skynet_context管</description>
    </item>
    
    <item>
      <title>免费Music</title>
      <link>https://zfunnily.github.io/2021/09/music/</link>
      <pubDate>Wed, 08 Sep 2021 14:47:14 +0800</pubDate>
      
      <guid>https://zfunnily.github.io/2021/09/music/</guid>
      <description>介绍一个可以免费听音乐的方法 环境 docker mac 安装 $ docker run -d -p 264:264 -p 9000:9000 -v $dir_name:/var/www/html/cache --name music oldiy/music-player-docker $dir_name 是 你自己宿主机的目录。可以自定义 访问：127.0.0.1:264 就可以放心使用， 同事推荐的，贼好用。</description>
    </item>
    
    <item>
      <title>Skynet | lua-protobuf</title>
      <link>https://zfunnily.github.io/2021/01/skynetprotobuf/</link>
      <pubDate>Mon, 25 Jan 2021 14:25:07 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2021/01/skynetprotobuf/</guid>
      <description>概述 在最新的skynet中我使用的是云风的pbc库来解析protobuf，该项目中的一个文件protobuf.lua 使用了module语法在lua5.1版本中已经删除，最新的skynet是lua5.4</description>
    </item>
    
    <item>
      <title>Skynet | echo服务</title>
      <link>https://zfunnily.github.io/2021/01/skynetecho/</link>
      <pubDate>Fri, 15 Jan 2021 16:07:51 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2021/01/skynetecho/</guid>
      <description>概述 引用云风博客的话：“skynet 是一个为网络游戏服务器设计的轻量框架。但它本身并没有任何为网络游戏业务而特别设计的部分，所以尽可以把它用于其它领域。skynet 并不是一个开箱即用的引擎，使用它需要</description>
    </item>
    
    <item>
      <title>Redis源码分析 | ziplist</title>
      <link>https://zfunnily.github.io/2021/01/ziplist/</link>
      <pubDate>Wed, 13 Jan 2021 17:52:27 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2021/01/ziplist/</guid>
      <description>概述 Redis中的List是一个有序（按加入的时序排序）的数据结构，一般有序我们会采用数组或者是双向链表，其中双向链表由于有前后指针实际上会很浪费内存。3.2版本之前采用两种数据结构作为底层实现： 压缩</description>
    </item>
    
    <item>
      <title>Redis源码解析 | VScode调试</title>
      <link>https://zfunnily.github.io/2021/01/vscodedebugredis/</link>
      <pubDate>Tue, 12 Jan 2021 14:25:29 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2021/01/vscodedebugredis/</guid>
      <description>环境 vscode- gcc5.4 ubuntu16.04 或者 ubuntu18.04 make 下载6.2版本. 我使用的是国内github镜像地址：github.com.cnpmjs.org，速度比较快。 $ git clone https://github.com.cnpmjs.org/redis/redis.git redis $ git checkout -b 6.2 remotes/origin/6.2 vscode不参与编译，只充当可视化的调试工具。 使用</description>
    </item>
    
    <item>
      <title>VScode | 调试Redis源码，指针显示的问题</title>
      <link>https://zfunnily.github.io/2021/01/vscoderedis/</link>
      <pubDate>Tue, 12 Jan 2021 14:17:22 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2021/01/vscoderedis/</guid>
      <description>缘由 使用VScode的时候，断点看到指针显示的是一串地址，而不是指针指向的对象的值。上网找了一圈，没看到vscode有对应的插件来解决这个问题。vscode有对应的语法来解决这个问题。 网上几乎都在说在</description>
    </item>
    
    <item>
      <title>Redis源码解析 | sds</title>
      <link>https://zfunnily.github.io/2021/01/sds/</link>
      <pubDate>Wed, 06 Jan 2021 14:20:23 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2021/01/sds/</guid>
      <description>SDS头文件及作用 sds.h: sds声明- sdsalloc.h： 为sds分配内存 源码文件sds.h中有这样一行代码 typedef char *sds; 很清晰、明了，sds其实就是char*。 最新的6.2分支的代码： struct __attribute__ ((__packed__)) sdshdr5 {&amp;lt;!-- --&amp;gt; unsigned char flags; /* 3 lsb of</description>
    </item>
    
    <item>
      <title>Openresty二 | postman小工具</title>
      <link>https://zfunnily.github.io/2020/11/%E4%BD%BF%E7%94%A8OpenResty%E5%81%9A%E4%B8%80%E4%B8%AApostman%E5%B0%8F%E5%B7%A5%E5%85%B7/</link>
      <pubDate>Wed, 25 Nov 2020 16:30:39 +0800</pubDate>
      
      <guid>https://zfunnily.github.io/2020/11/%E4%BD%BF%E7%94%A8OpenResty%E5%81%9A%E4%B8%80%E4%B8%AApostman%E5%B0%8F%E5%B7%A5%E5%85%B7/</guid>
      <description>用到的知识点 mvc架构 模型渲染库：https://github.com/bungle/lua-resty-template resty http请求库： https://github.com/bungle/lua-resty-template 参照 mvc模型来做postman工具 配置文件说明 worker_processes 1; error_log logs/error.log; events</description>
    </item>
    
    <item>
      <title>Openresty一 | 初探</title>
      <link>https://zfunnily.github.io/2020/11/OpenResty%E5%88%9D%E6%8E%A2/</link>
      <pubDate>Mon, 23 Nov 2020 16:21:34 +0800</pubDate>
      
      <guid>https://zfunnily.github.io/2020/11/OpenResty%E5%88%9D%E6%8E%A2/</guid>
      <description>概述 OpenResty®是一个基于Nginx与 Lua 的高性能 Web 平台，其内部集成了大量精良的 Lua 库、第三方模块以及大多数的依赖项。用于方便地搭建能够处理超高并发、扩展性极高的动态 Web 应用、Web 服务和动态网关。</description>
    </item>
    
  </channel>
</rss>
