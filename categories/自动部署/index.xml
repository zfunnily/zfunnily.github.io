<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>自动部署 on Zzz记忆</title><link>https://zfunnily.github.io/categories/%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/</link><description>Recent content in 自动部署 on Zzz记忆</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Mon, 29 Jan 2024 01:00:44 +0000</lastBuildDate><atom:link href="https://zfunnily.github.io/categories/%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/index.xml" rel="self" type="application/rss+xml"/><item><title>WSL2改为桥接</title><link>https://zfunnily.github.io/2023/11/wsl2/</link><pubDate>Fri, 17 Nov 2023 15:45:00 +0800</pubDate><guid>https://zfunnily.github.io/2023/11/wsl2/</guid><description>需求 在docker容器内部程序自己获取的ip是172开头的。我需要跟宿主机同样网段的ip。 问题 win10系统wsl2 不支持桥接 更简单的解决方案 使用vmware虚拟机，直接启动一个linux镜像，然后使</description></item><item><title>Docker | Mysql 挂载目录一键部署</title><link>https://zfunnily.github.io/2023/11/mysql/</link><pubDate>Thu, 16 Nov 2023 11:36:44 +0800</pubDate><guid>https://zfunnily.github.io/2023/11/mysql/</guid><description>创建挂载文件 mkdir -p conf mkdir -p logs mkdir -p mysql 编辑配置文件 cd conf/ vi my.cnf # Copyright (c) 2014, 2016, Oracle and/or its affiliates. All rights reserved. # # This program is free software; you can redistribute it and/or modify # it under the terms of the GNU General Public License as published by # the Free Software Foundation; version 2 of the License. # # This program is distributed in the hope that it will be useful, # but WITHOUT ANY WARRANTY; without even the implied warranty of #</description></item><item><title>WSL2子系统迁移</title><link>https://zfunnily.github.io/2023/11/wsl/</link><pubDate>Mon, 13 Nov 2023 22:21:34 +0800</pubDate><guid>https://zfunnily.github.io/2023/11/wsl/</guid><description>wsl 安装 参考链接: https://learn.microsoft.com/zh-cn/windows/wsl/install 通过命令行安装 wsl --update wsl -v -l wsl --install wsl &amp;amp; docker 迁移 WSL发行版默认都是安装在C盘，在%LOCALAPPDATA%/Docker/wsl目录 docker的运行数据、镜像文件都存在%LOCALAPP</description></item><item><title>GithubAction</title><link>https://zfunnily.github.io/2023/11/gitaction/</link><pubDate>Mon, 13 Nov 2023 11:21:34 +0800</pubDate><guid>https://zfunnily.github.io/2023/11/gitaction/</guid><description>Github Token 生成 &amp;amp; 设置 github -&amp;gt; Settings -&amp;gt; Developer Settings -&amp;gt; Personal access tokens 新增 Tokens(classic) 点击Generate new token 点击你想使用Action的github仓库 Settings -&amp;gt; Secrets and variables -&amp;gt; Actions -&amp;gt; New respository secret. 填上名字ACTION_ACCESS_TOKEN和第一步生成的 token，</description></item><item><title>Gitlab | CI/CD简单实现</title><link>https://zfunnily.github.io/2022/06/cicd/</link><pubDate>Wed, 22 Jun 2022 14:26:25 +0800</pubDate><guid>https://zfunnily.github.io/2022/06/cicd/</guid><description>CI/CD 流水线 组件组成 stages job gitlab runner(可以与gitlab服务器独立, c/s架构. ) -------- -------- --------- |stage1| -&amp;gt; |stage2| -&amp;gt; | stage3| -------- -------- --------- ------ ------ ------- |job1| |job2| | job3| ------ ------ ------- --------- --------- --------- |runner1| |runner2| -&amp;gt; |runner3| --------- --------- --------- pipline: 包含多个stage， 顺序执行 stages: 一个stage可以包含多</description></item><item><title>Gitlab | CI/CD简单实现</title><link>https://zfunnily.github.io/2022/06/cicd/</link><pubDate>Wed, 22 Jun 2022 14:26:25 +0800</pubDate><guid>https://zfunnily.github.io/2022/06/cicd/</guid><description>CI/CD 流水线 组件组成 stages job gitlab runner(可以与gitlab服务器独立, c/s架构. ) -------- -------- --------- |stage1| -&amp;gt; |stage2| -&amp;gt; | stage3| -------- -------- --------- ------ ------ ------- |job1| |job2| | job3| ------ ------ ------- --------- --------- --------- |runner1| |runner2| -&amp;gt; |runner3| --------- --------- --------- pipline: 包含多个stage， 顺序执行 stages: 一个stage可以包含多</description></item><item><title>Docker | 容器退出码详解</title><link>https://zfunnily.github.io/2020/11/Docker%E5%AE%B9%E5%99%A8%E9%80%80%E5%87%BA%E7%A0%81%E8%AF%A6%E8%A7%A3/</link><pubDate>Sat, 28 Nov 2020 13:32:57 +0000</pubDate><guid>https://zfunnily.github.io/2020/11/Docker%E5%AE%B9%E5%99%A8%E9%80%80%E5%87%BA%E7%A0%81%E8%AF%A6%E8%A7%A3/</guid><description>docker查看退出码指令 $ docker ps --filter &amp;#34;status=exited&amp;#34; $ docker inspect container-id --format=&amp;#39;{&amp;lt;!-- --&amp;gt;{.State.ExitCode}}&amp;#39; 常见退出码 Exit Code 0 退出代码0表示特定容器没有附加前台进程。 该退出代码是所有其他后续退出代码的例外。 这不一定意味着发生了不好的事情。如果开发人员想要在容器完</description></item><item><title>K8S | Prometheus+Grafana监控</title><link>https://zfunnily.github.io/2020/08/prometheusgrafana/</link><pubDate>Mon, 17 Aug 2020 13:58:35 +0000</pubDate><guid>https://zfunnily.github.io/2020/08/prometheusgrafana/</guid><description>概述 作为应用与Kubernetes的监控体系，Prometheus具备诸多的优势，如： Kubernetes默认支持,非常适合容器和微服务- 无依赖，安装方便，上手容易- 社区活跃，它不仅仅是个工具，而是生</description></item><item><title>K8S | Ingress的基本使用</title><link>https://zfunnily.github.io/2020/08/ingress/</link><pubDate>Sat, 15 Aug 2020 00:05:15 +0000</pubDate><guid>https://zfunnily.github.io/2020/08/ingress/</guid><description>缘由 看了statefulset基础教程的基础教程，并且把环境搭建起来后。pod内部是可以连通了。但是我不知道怎么去从外部访问。在网上搜索一番，通过Ingress可以作为集群的入口。遂记录之。 结合Sta</description></item><item><title>K8S | Statefluset的持久存储PVC</title><link>https://zfunnily.github.io/2020/08/pvc/</link><pubDate>Fri, 14 Aug 2020 17:18:58 +0000</pubDate><guid>https://zfunnily.github.io/2020/08/pvc/</guid><description>缘由 在看statefluset基础教程的时候遇到pod状态为pending kubectl describe pod web-0 日志内容是 pod has unbound immediate PersistentVolumeClaims 于是就对PV和PVC进行研究。 有给出完整的 web.yaml查看最下面的完整示例。但是我建议先把PV</description></item><item><title>K8S | StatefulSet基本原理</title><link>https://zfunnily.github.io/2020/08/statefulset/</link><pubDate>Fri, 14 Aug 2020 16:03:41 +0000</pubDate><guid>https://zfunnily.github.io/2020/08/statefulset/</guid><description>背景 用户通过 Deployment、ReplicationController 可以方便地在 kubernetes 中部署一套高可用、可扩展的分布式无状态服务。这类应用不在本地存储数据，通过简单的负载均衡策略可实现请求分发。随</description></item><item><title>K8S | coreDNS的部署安装</title><link>https://zfunnily.github.io/2020/08/coredns/</link><pubDate>Thu, 13 Aug 2020 18:44:28 +0000</pubDate><guid>https://zfunnily.github.io/2020/08/coredns/</guid><description>概述 CoreDNS可以在具有标准的Kube-DNS的Kubernetes集群中运行。作为Kubernetes 的插件使用，CoreDNS将从 Kubernetes集群中读取区（zone）数据。它实现了为K</description></item><item><title>K8S | 创建第一个应用</title><link>https://zfunnily.github.io/2020/08/firstk8s/</link><pubDate>Thu, 13 Aug 2020 15:28:31 +0000</pubDate><guid>https://zfunnily.github.io/2020/08/firstk8s/</guid><description>使用k8s部署第一个应用 创建一个nginx.yaml文件 apiVersion: v1 kind: Pod metadata: name: nginx # 指定 label，便于检索 labels: app: nginx spec: containers: - name: nginx # 指定镜像 image: nginx:alpine # 指定暴露端口 ports: - containerPort: 80 --- # 创建网络服务 apiVersion: v1 kind: Service metadata: name: kube-node-service labels: name: kube-node-service spec: type: NodePort #这里代表</description></item><item><title>Docker | 远程访问加密</title><link>https://zfunnily.github.io/2020/08/dockersecret/</link><pubDate>Fri, 07 Aug 2020 07:56:52 +0000</pubDate><guid>https://zfunnily.github.io/2020/08/dockersecret/</guid><description>docker的远程访问 方法一 ：编辑docker.service文件 编辑docker.service文件 sudo vim /lib/systemd/system/docker.service 修改ExecStart行为下面内容 ExecStart=/usr/bin/dockerd -H tcp://0.0.0.0:2375 -H unix://var/run/docker.sock 重新加载docker配置 sudo systemctl daemon-reload // 1，加载dock</description></item><item><title>Docker | web管理界面portainer</title><link>https://zfunnily.github.io/2020/08/dockerweb/</link><pubDate>Fri, 07 Aug 2020 07:54:43 +0000</pubDate><guid>https://zfunnily.github.io/2020/08/dockerweb/</guid><description>拉取镜像 $ docker pull portainer/portainer 运行启动portainer docker run -d -p 9000:9000 -v /var/run/docker.sock:/var/run/docker.sock -v /home/docker/portainer:/data --name portainer --restart=always portainer/portainer admin bigant.cn 汉化 Portainer-CN.zip 百度云盘: https://pan.baidu.com/s/13ra6jXHR_7vajLLlf5GVEw 提取码: nzue 新建文件夹命名为public，把Portainer-CN.zip解压至里面。 2、public文件夹传</description></item><item><title>K8S | 集群资源监控 heapster</title><link>https://zfunnily.github.io/2020/08/heapster/</link><pubDate>Thu, 06 Aug 2020 09:06:05 +0000</pubDate><guid>https://zfunnily.github.io/2020/08/heapster/</guid><description>安装heapster的原因 查看dashboard状态 $ sudo kubectl get pods --all-namespaces | grep dashboard kubernetes-dashboard dashboard-metrics-scraper-6b4884c9d5-mvnb9 1/1 Running 0 40m kubernetes-dashboard kubernetes-dashboard-d7f7f565d-zhpsc 1/1 Running 0 40m 查看dashboard的日志 $ sudo kubectl logs -f -n kubernetes-dashboard kubernetes-dashboard-d7f7f565d-zhpsc 日志遇到这样的情况 No metric client provided. Skipping metrics. 2020/08/03 09:02:22 [2020-08-03T09:02:22Z] Outcoming response to 192.168.84.241:40086 with 200 status code 2020/08/03 09:02:23 Metric client health</description></item><item><title>K8S | Dashboard界面管理</title><link>https://zfunnily.github.io/2020/08/dashboard/</link><pubDate>Thu, 06 Aug 2020 09:04:14 +0000</pubDate><guid>https://zfunnily.github.io/2020/08/dashboard/</guid><description>安装部署Dashboard 通过一下命令来部署, recommended.yaml $ sudo kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v2.0.0/aio/deploy/recommended.yaml https://raw.githubusercontent.com/kubernetes/dashboard/v2.0.0/aio/depl</description></item><item><title>K8S | 安装</title><link>https://zfunnily.github.io/2020/08/k8sinstall/</link><pubDate>Wed, 05 Aug 2020 10:00:40 +0000</pubDate><guid>https://zfunnily.github.io/2020/08/k8sinstall/</guid><description>安装k8s前的准备工作 环境 ubuntu18.04 docker 关闭 swap 暂时关闭 $ swapoff -a 永久关闭 注释掉这一行 sudo vim /etc/fstab # /swapfile none swap sw 0 0 重启机器 sudo reboot docker 的配置 安装完成之后需要进行一些配置，包括 切换docker下载源为国内镜像站 以及 修改cgroups</description></item></channel></rss>