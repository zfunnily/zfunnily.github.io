<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>编程.C on Zzz记忆</title><link>https://zfunnily.github.io/categories/%E7%BC%96%E7%A8%8B.C/</link><description>Recent content in 编程.C on Zzz记忆</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Wed, 03 Apr 2024 01:00:22 +0000</lastBuildDate><atom:link href="https://zfunnily.github.io/categories/%E7%BC%96%E7%A8%8B.C/index.xml" rel="self" type="application/rss+xml"/><item><title>八个基础排序</title><link>https://zfunnily.github.io/2021/03/sort/</link><pubDate>Tue, 23 Mar 2021 10:13:31 +0000</pubDate><guid>https://zfunnily.github.io/2021/03/sort/</guid><description>sort排序 std::sort( )函数是库函数提供的排序函数，必须包括头文件#include &amp;lt;algorithm&amp;gt;，它使用的排序方法是类似于快排的方法，时间复杂度为n*log2(n) Sort函数有三个参数：</description></item><item><title>实现atoi和itoa函数</title><link>https://zfunnily.github.io/2021/03/atoianditoa/</link><pubDate>Wed, 17 Mar 2021 16:43:20 +0000</pubDate><guid>https://zfunnily.github.io/2021/03/atoianditoa/</guid><description>题目1： 把字符串转化为整数 有整数字符串，&amp;quot;13579&amp;quot;, 和 &amp;quot;246810&amp;quot;. 请写一个函数把这两个字符串转化为整数 步骤： 先判断正负 遍历字符串，转换字符为整数 //atoi.cc #include &amp;lt;stdio.h&amp;gt; int my_atoi(char *str) { bool bmin = false; int result = 0; //先判断正</description></item><item><title>协程解析二 | 云风的coroutine</title><link>https://zfunnily.github.io/2021/03/coroutinetwo/</link><pubDate>Wed, 10 Mar 2021 11:11:47 +0000</pubDate><guid>https://zfunnily.github.io/2021/03/coroutinetwo/</guid><description>概述 云风的coroutine是通过ucontext来控制程序运行时上下文的，我们来根据该库提供的几个接口，和一个demo来解释协程的运行原理。如果不了解ucontext的，建议先了解ucontxt 环境</description></item><item><title>协程解析一 | ucontext</title><link>https://zfunnily.github.io/2021/03/coroutineone/</link><pubDate>Tue, 09 Mar 2021 09:43:00 +0000</pubDate><guid>https://zfunnily.github.io/2021/03/coroutineone/</guid><description>概述 最近在研究协程的实现原理，看了云风的coroutine和腾讯的开源库libco后，原来要实现一个协程库也没那么难。我先来讲讲云风的coroutine库。他使用的是 uncontext来保存程序运行上</description></item><item><title>struct中使用char[]</title><link>https://zfunnily.github.io/2021/01/chararray/</link><pubDate>Tue, 05 Jan 2021 15:45:36 +0000</pubDate><guid>https://zfunnily.github.io/2021/01/chararray/</guid><description>缘由 最近在看redis的源码，刚开始看sds，看到这块代码 struct __attribute__ ((__packed__)) sdshdr5 { unsigned char flags; /* 3 lsb of type, and 5 msb of string length */ char buf[]; }; 好奇为什么使用 char buf[],而不用char *buf，找到答案记录一下。 struct中的char*</description></item><item><title>CCnet | 单线程reactor演变为多线程</title><link>https://zfunnily.github.io/2020/12/ccnet/</link><pubDate>Wed, 30 Dec 2020 09:19:41 +0000</pubDate><guid>https://zfunnily.github.io/2020/12/ccnet/</guid><description>ccnet从单线程演变为多线程 ccnet现状： epoll linux平台 事件循环 单线程 reactor 监听和新连接的事件都在主线程中 单线程的ccnet ccnet的单线程的角色： EventLoop: 整个事件循环。 EPollPoller: 负责事件的收集。 Channel</description></item><item><title>CCnet | 一个reactor单线程网络库</title><link>https://zfunnily.github.io/2020/12/ccnetone/</link><pubDate>Sun, 27 Dec 2020 18:41:25 +0000</pubDate><guid>https://zfunnily.github.io/2020/12/ccnetone/</guid><description>缘由 最近在研究陈硕的网络库muduo，是一个基于reactor架构的网络库。我对网络库的感觉是易用，但是内容庞大，依赖颇多。比如boost网络库里面的一些语法让人生畏。关于reactor和proact</description></item><item><title>C++ | vector中的resize()函数 VS reserve()函数</title><link>https://zfunnily.github.io/2020/12/reserve/</link><pubDate>Fri, 25 Dec 2020 11:04:29 +0000</pubDate><guid>https://zfunnily.github.io/2020/12/reserve/</guid><description>reserve void reserve (size_type n); reserver函数用来给vector预分配存储区大小，即capacity的值 ，但是没有给这段内存进行初始化。reserve 的参数n是推荐预分配内存的大小，实际分配的可能等于或大于这个值，即</description></item><item><title>Libevent | 定时器</title><link>https://zfunnily.github.io/2020/09/libeventimer/</link><pubDate>Wed, 16 Sep 2020 23:20:28 +0000</pubDate><guid>https://zfunnily.github.io/2020/09/libeventimer/</guid><description>libevent 实现定时器流程 首先初始化libevent库，并保存返回的指针 struct event_base * base = event_init(); 实际上这一步相当于初始化一个Reactor实例；在初始化libevent后，就可以注册事件了。 初始化事件event，设置回调函</description></item></channel></rss>