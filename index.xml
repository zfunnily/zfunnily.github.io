<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>流浪花</title>
    <link>https://zfunnily.github.io/</link>
    <description>Recent content on 流浪花</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Sun, 28 Feb 2021 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://zfunnily.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>go-libp2p的chat例子解析</title>
      <link>https://zfunnily.github.io/2021/10/gop2p%E4%B8%80/</link>
      <pubDate>Thu, 28 Oct 2021 14:40:02 +0800</pubDate>
      
      <guid>https://zfunnily.github.io/2021/10/gop2p%E4%B8%80/</guid>
      <description>代码下载 git clone https://github.com/libp2p/go-libp2p.git chat实例分析 进入目录go-libp2p/examples/chat/, 编译 go build 先看README.md， 可以了解到使用chat的方式 在节点 B 1 2 3 4 5 6 7 $ ./chat -sp 3001 2021/10/28 11:01:25 Run &amp;#39;./chat -d /ip4/127.0.0.1/tcp/3001/p2p/QmXgEXt4CiqmVmDhPPQnyVkoj3Bsx3Nggq57PPsk5tLNTs&amp;#39; on another console. 2021/10/28 11:01:25 You can replace 127.0.0.1 with public IP as well. 2021/10/28 11:01:25 Waiting for incoming connection 2021/10/28 11:01:25 2021/10/28 11:03:03 Got a new stream! &amp;gt; hello 在节点 A, 如果B有公网IP，则把</description>
    </item>
    
    <item>
      <title>go-libp2p的echo例子解析</title>
      <link>https://zfunnily.github.io/2021/10/gop2p%E4%BA%8C/</link>
      <pubDate>Thu, 28 Oct 2021 11:15:42 +0800</pubDate>
      
      <guid>https://zfunnily.github.io/2021/10/gop2p%E4%BA%8C/</guid>
      <description>go-libp2p的echo例子分析 进入目录go-libp2p/examples/echo/, 编译 go build 先看README.md， 可以了解到使用echo的方式: 终端B 1 2 3 4 5 6 7 $ ./echo -l 3001 2021/10/28 11:25:33 I am /ip4/127.0.0.1/tcp/3001/p2p/QmTu8sxDi3fSjz9ZMvkAj3qA9YAoGskroEnyLz2ZvfTBhX 2021/10/28 11:25:33 listening for connections 2021/10/28 11:25:33 Now run &amp;#34;./echo -l 3002 -d /ip4/127.0.0.1/tcp/3001/p2p/QmTu8sxDi3fSjz9ZMvkAj3qA9YAoGskroEnyLz2ZvfTBhX&amp;#34; on a different terminal 2021/10/28 11:25:59 listener received new stream 2021/10/28 11:25:59 read: Hello, world! 在另外一个终端输A入： 1 2 3</description>
    </item>
    
    <item>
      <title>csdn博客迁移到个人博客</title>
      <link>https://zfunnily.github.io/2021/10/blogmigration/</link>
      <pubDate>Fri, 22 Oct 2021 19:01:20 +0800</pubDate>
      
      <guid>https://zfunnily.github.io/2021/10/blogmigration/</guid>
      <description>迁移博客 我是从18年开始写一些东西，先写在看云笔记上，后面东西越来越多。写出来的东西比较零散. 20年下半年入职新公司，开始在csdn上写博客，今年我准备尝试使用个人博客，hugo和gitPage结合部署静态博客，csdn上没怎么更新. 这两天在研究skynet框架，顺手写了几篇博客</description>
    </item>
    
    <item>
      <title>Skynet源码赏析四 | 消息调度</title>
      <link>https://zfunnily.github.io/2021/10/skynet%E5%9B%9B/</link>
      <pubDate>Thu, 21 Oct 2021 10:06:39 +0800</pubDate>
      
      <guid>https://zfunnily.github.io/2021/10/skynet%E5%9B%9B/</guid>
      <description>服务间消息流转 发送消息 数据结构message_queue *q是次级消息队列，每个服务都有与之绑定的唯一一个次级消息队列。当我们在lua层，调用skynet.send(...), 或者调用skynet.call(...)函数发送消息，其实调用的都是c.send(...),实际上调用的</description>
    </item>
    
    <item>
      <title>Skynet源码赏析三 | 服务启动</title>
      <link>https://zfunnily.github.io/2021/10/skynet%E4%B8%89/</link>
      <pubDate>Wed, 20 Oct 2021 11:26:07 +0800</pubDate>
      
      <guid>https://zfunnily.github.io/2021/10/skynet%E4%B8%89/</guid>
      <description>skynet启动一个C服务 查看怎么启动C服务的最好的办法是打断点，看源码。 启动logger日志服务 我拿日志服务来举例子，怎么启动日志服务的呢？ 传参数name = &amp;quot;logger&amp;quot;, param = null， struct skynet_context *ctx = skynet_context_new(config-&amp;gt;logservice, config-&amp;gt;logger);; 从modules服务模块中取出名字为 logger的服务, struct skynet_module * result = _query(name);; 如果找不到则从cpath目</description>
    </item>
    
    <item>
      <title>Skynet源码赏析二 | 基础数据结构</title>
      <link>https://zfunnily.github.io/2021/10/skynet%E4%BA%8C/</link>
      <pubDate>Tue, 19 Oct 2021 18:47:45 +0800</pubDate>
      
      <guid>https://zfunnily.github.io/2021/10/skynet%E4%BA%8C/</guid>
      <description>module管理模块 我们所写的C服务编译成.so文件后放在cpath变量路径下，程序会加载路径cpath = root..&amp;quot;cservice/?.so&amp;quot;下的.so文件，通过static void * _try_open(struct modules *m, const char * name)函数第一次打开，然后被加载到全局变量static struct modules *</description>
    </item>
    
    <item>
      <title>Skynet源码赏析一 | 启动初始化的过程</title>
      <link>https://zfunnily.github.io/2021/10/skynet%E4%B8%80/</link>
      <pubDate>Tue, 19 Oct 2021 17:28:45 +0800</pubDate>
      
      <guid>https://zfunnily.github.io/2021/10/skynet%E4%B8%80/</guid>
      <description>入口文件 skynet_main.c 加载配置 1 2 3 4 5 6 7 8 9 struct skynet_config config; config.thread = optint(&amp;#34;thread&amp;#34;,8); config.module_path = optstring(&amp;#34;cpath&amp;#34;,&amp;#34;./cservice/?.so&amp;#34;); config.harbor = optint(&amp;#34;harbor&amp;#34;, 1); config.bootstrap = optstring(&amp;#34;bootstrap&amp;#34;,&amp;#34;snlua bootstrap&amp;#34;); config.daemon = optstring(&amp;#34;daemon&amp;#34;, NULL); config.logger = optstring(&amp;#34;logger&amp;#34;, NULL); config.logservice = optstring(&amp;#34;logservice&amp;#34;, &amp;#34;logger&amp;#34;); config.profile = optboolean(&amp;#34;profile&amp;#34;, 1); 从上述代码可以看到，配置都已经加载到变量struct skynet_config config;中了。 初始化 初始化skynet_context管理模块, skynet_handle_init(config-&amp;gt;harbor);; 初始化static struct global_queue *Q消息队列, skynet_mq_init();; 初始化stat</description>
    </item>
    
    <item>
      <title>Golang调用带有后台进程shell脚本可能会被挂起</title>
      <link>https://zfunnily.github.io/2021/10/shell/</link>
      <pubDate>Wed, 13 Oct 2021 17:15:45 +0800</pubDate>
      
      <guid>https://zfunnily.github.io/2021/10/shell/</guid>
      <description>起因 今天用Golang写一个调用外部shell脚本的程序，使用 exec.Command方法，这段脚本代码中包含了一个后台任务语句。 结果发生了一个问题：cmd.Output 始终不会返回，一直挂起。导致我的Go程序也挂起了。 问题还原 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 //main.go package main import ( &amp;#34;fmt&amp;#34; &amp;#34;os/exec&amp;#34; ) func</description>
    </item>
    
    <item>
      <title>FPS游戏 实现移动功能</title>
      <link>https://zfunnily.github.io/2021/09/move/</link>
      <pubDate>Sun, 12 Sep 2021 20:43:34 +0800</pubDate>
      
      <guid>https://zfunnily.github.io/2021/09/move/</guid>
      <description>三种实现FPS Controller的区别 Transform Translate 允许移动物理，但无物理碰撞 Rigid body + Capsule Collider 符合物理学 不会鬼穿墙 无法滞空运动 可与Physics Object 交互 Charactor Controller 不会鬼穿墙 提供的API相对多 无法与Physic objects互动 可以滞空运动(太空人) 提供多种运动效果例如 slopes steps 等 Rigid body + Capsule Collider 控制摄像头旋转 FPMouseLook.cs 跟</description>
    </item>
    
    <item>
      <title>免费Music</title>
      <link>https://zfunnily.github.io/2021/09/music/</link>
      <pubDate>Wed, 08 Sep 2021 14:47:14 +0800</pubDate>
      
      <guid>https://zfunnily.github.io/2021/09/music/</guid>
      <description>介绍一个可以免费听音乐的方法 环境 docker mac 安装 $ docker run -d -p 264:264 -p 9000:9000 -v $dir_name:/var/www/html/cache --name music oldiy/music-player-docker $dir_name 是 你自己宿主机的目录。可以自定义 访问：127.0.0.1:264 就可以放心使用， 同事推荐的，贼好用。</description>
    </item>
    
    <item>
      <title>idea和vscode结合vim 自动切换输入法</title>
      <link>https://zfunnily.github.io/2021/09/idea%E5%92%8Cvscode%E7%BB%93%E5%90%88vim-%E8%87%AA%E5%8A%A8%E5%88%87%E6%8D%A2%E8%BE%93%E5%85%A5%E6%B3%95/</link>
      <pubDate>Tue, 07 Sep 2021 14:41:02 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2021/09/idea%E5%92%8Cvscode%E7%BB%93%E5%90%88vim-%E8%87%AA%E5%8A%A8%E5%88%87%E6%8D%A2%E8%BE%93%E5%85%A5%E6%B3%95/</guid>
      <description>vim 在退出输入模式的时候切换为原来的输入法 在敲代码的时候使用我们使用的英文，当遇到问题，我们需要搜索引擎的时候需要中文输入法，这个时候，自动切换输入法可以帮助我们节省手动切换输入法的时间。 跟编辑器结合，主要是两种编辑器，一个是 idea 一个是 vscode 在idea中使用 vim 插件： IdeaVim- IdeaVimExtension 我们需要在 用户目录</description>
    </item>
    
    <item>
      <title>U3D Transform类</title>
      <link>https://zfunnily.github.io/2021/09/transform%E7%B1%BB/</link>
      <pubDate>Tue, 07 Sep 2021 15:55:59 +0800</pubDate>
      
      <guid>https://zfunnily.github.io/2021/09/transform%E7%B1%BB/</guid>
      <description>Transform类 在unity中，把transform类理解为，transform类是在每个对象生成时自动附加的一个类。在Unity的视图中，点击Hierarchy中的对象，就可以在Inspector中可以看到存在Transform的组件。 属性 Position（坐标） Rotat</description>
    </item>
    
    <item>
      <title>Vim 输入模式 语言改变</title>
      <link>https://zfunnily.github.io/2021/09/vim_change_language/</link>
      <pubDate>Tue, 07 Sep 2021 10:46:58 +0800</pubDate>
      
      <guid>https://zfunnily.github.io/2021/09/vim_change_language/</guid>
      <description>vim 在退出输入模式的时候切换为原来的输入法 在敲代码的时候使用我们使用的英文，当遇到问题，我们需要搜索引擎的时候需要中文输入法，这个时候，自动切换输入法可以帮助我们节省手动切换输入法的时间。 跟编辑器结合，主要是两种编辑器，一个是 idea 一个是 vscode 在idea中使用 vim 插件： IdeaVim IdeaVimExtension 我们需要在 用户目录</description>
    </item>
    
    <item>
      <title>linue Screen</title>
      <link>https://zfunnily.github.io/2021/09/screen/</link>
      <pubDate>Tue, 07 Sep 2021 10:02:16 +0800</pubDate>
      
      <guid>https://zfunnily.github.io/2021/09/screen/</guid>
      <description>screen命令 screen 是一个非常有用的命令。应用场景： 单个 SSH 会话中使用多个 shell 窗口（会话）的能力 服务器开发，一个单独运行进程的窗口。可以避免单独再开一个窗口。 &amp;hellip; screen使用 创建一个窗口 1 $ screen -S name 执行自己需要的命令 $ ... 分离窗口 ctrl + A + D 重新连接到screen 如果只有一个会话可以直接使</description>
    </item>
    
    <item>
      <title>CentOS7.2 升级gcc</title>
      <link>https://zfunnily.github.io/2021/09/CentOS7.2-%E5%8D%87%E7%BA%A7gcc/</link>
      <pubDate>Wed, 01 Sep 2021 18:55:39 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2021/09/CentOS7.2-%E5%8D%87%E7%BA%A7gcc/</guid>
      <description>环境 CentOS 7.2.1511- Docker 我是用 docker 拉取镜像 CentOS 7.2.1511, 利用容器来作为我的开发环境。有条件的也可以用虚拟机或者实体机器。原理都一样。 $ docker $ yum update &amp;amp;&amp;amp; yum install gcc gcc-c++ make zlib-devel.x86_6 下载依赖包 升级 gcc， 下载安装包下载依赖。 $ wget http://ftp.gnu.org/gnu/gcc/gcc-4.9.3/gcc-4.9.3.tar.bz2 $ tar xfv gcc-4.9.3.tar.bz2 &amp;amp;&amp;amp; cd gcc-4.9.3 $ ./contrib/download_prerequisites 如果连接失败，无法下载的话，就打开此文件，手动下载下面5个文件，然后将文件放在gcc</description>
    </item>
    
    <item>
      <title>Centos7.2的gcc4.8升级为4.9</title>
      <link>https://zfunnily.github.io/2021/09/gcc%E5%8D%87%E7%BA%A7/</link>
      <pubDate>Wed, 01 Sep 2021 18:13:41 +0800</pubDate>
      
      <guid>https://zfunnily.github.io/2021/09/gcc%E5%8D%87%E7%BA%A7/</guid>
      <description>环境 CentOS 7.2.1511 Docker 我是用 docker 拉取镜像 CentOS 7.2.1511, 利用容器来作为我的开发环境。有条件的也可以用虚拟机或者实体机器。原理都一样。 1 2 $ docker $ yum update &amp;amp;&amp;amp; yum install gcc gcc-c++ make zlib-devel.x86_6 下载依赖包 升级 gcc， 下载安装包下载依赖。 1 2 3 $ wget http://ftp.gnu.org/gnu/gcc/gcc-4.9.3/gcc-4.9.3.tar.bz2 $ tar xfv gcc-4.9.3.tar.bz2 &amp;amp;&amp;amp; cd gcc-4.9.3 $ ./contrib/download_prerequisites 如果连接失败，无法下载的话，就打开此文件，手动下载下面5个文件，然后将文件</description>
    </item>
    
    <item>
      <title>shell-使用Except自动交互</title>
      <link>https://zfunnily.github.io/2021/08/shell-%E4%BD%BF%E7%94%A8Except%E8%87%AA%E5%8A%A8%E4%BA%A4%E4%BA%92/</link>
      <pubDate>Mon, 30 Aug 2021 17:20:38 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2021/08/shell-%E4%BD%BF%E7%94%A8Except%E8%87%AA%E5%8A%A8%E4%BA%A4%E4%BA%92/</guid>
      <description>Except 参数 spawn 交互程序开始后面跟命令或者指定程序 expect 获取匹配信息匹配成功则执行expect后面的程序动作 send exp_send 用于发送指定的字符串信息 exp_continue 在expect中多次匹配就需要用到 send_user 用来打印输出 相当于shell中的echo exit 退出expect脚本 eof expect执行结束 退出 set 定义变量 puts 输出变量 set timeout 设置超</description>
    </item>
    
    <item>
      <title>shell Except 使用</title>
      <link>https://zfunnily.github.io/2021/08/except/</link>
      <pubDate>Mon, 30 Aug 2021 17:13:33 +0800</pubDate>
      
      <guid>https://zfunnily.github.io/2021/08/except/</guid>
      <description>Except 参数 1 2 3 4 5 6 7 8 9 10 11 12 spawn 交互程序开始后面跟命令或者指定程序 expect 获取匹配信息匹配成功则执行expect后面的程序动作 send exp_send 用于发送指定的字符串信息 exp_continue 在expect中多次匹配就需要用到 send_user 用来打印输出 相当于shell中的echo exit 退出expect脚本 eof expect执行结束 退出 set 定义</description>
    </item>
    
    <item>
      <title>U3D UGUI</title>
      <link>https://zfunnily.github.io/2021/08/UGUI/</link>
      <pubDate>Fri, 20 Aug 2021 14:15:41 +0800</pubDate>
      
      <guid>https://zfunnily.github.io/2021/08/UGUI/</guid>
      <description>Text Text的属性 在 Unity 的 Hierarchy 面板上右键–&amp;gt;UI–&amp;gt;Text, 在 Inspector 面板上查看属性 属性 功能 Text 需要显示的文本 Font 显示文本的字体 如：微软雅黑，宋体等 Font Style 显示文本的样式，有普通，粗体，斜体，粗体和斜体四种选项 Font Size 显示字体的大小 Line Spacing 行与行之间的垂直距离 Alignment 文本的水平和垂直方向的对齐方式 Align</description>
    </item>
    
    <item>
      <title>Golang利用redis实现分布式锁</title>
      <link>https://zfunnily.github.io/2021/06/golang%E5%88%A9%E7%94%A8redis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</link>
      <pubDate>Thu, 03 Jun 2021 16:12:21 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2021/06/golang%E5%88%A9%E7%94%A8redis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</guid>
      <description>概述 网上有很多Golang操作redis的例子，我使用github.com/gomodule/redigo/redis包写一个关于redis分布式锁的问题。 redis分布式锁 锁需要的几个组件 获取锁- 删除锁 分布式锁还需要 给锁加上唯一id (只能获取和删除自己的锁)- 给锁加上过期时间 (</description>
    </item>
    
    <item>
      <title>Golang操作redis</title>
      <link>https://zfunnily.github.io/2021/06/go_redis/</link>
      <pubDate>Thu, 03 Jun 2021 15:57:14 +0800</pubDate>
      
      <guid>https://zfunnily.github.io/2021/06/go_redis/</guid>
      <description>概述 网上有很多golang操作redis的例子，我使用github.com/gomodule/redigo/redis包写一个关于redis分布式锁的问题。 redis分布式锁 锁需要的几个组件 获取锁 删除锁 分布式锁还需要 给锁加上唯一id (只能获取和删除自己的锁) 给锁加上过期时间 (防止</description>
    </item>
    
    <item>
      <title>Auto_findroad</title>
      <link>https://zfunnily.github.io/2021/05/auto_findroad/</link>
      <pubDate>Thu, 20 May 2021 17:39:34 +0800</pubDate>
      
      <guid>https://zfunnily.github.io/2021/05/auto_findroad/</guid>
      <description>自动寻路 有限状态机器 行为树</description>
    </item>
    
    <item>
      <title>Lua next 的使用</title>
      <link>https://zfunnily.github.io/2021/05/lua_next/</link>
      <pubDate>Mon, 10 May 2021 16:39:50 +0800</pubDate>
      
      <guid>https://zfunnily.github.io/2021/05/lua_next/</guid>
      <description>lua_next lua_next(L,index)：先把 表(lua栈 index所指的表), 的当前索引弹出，再把table 当前索引的值弹出，也就是先弹出 table的索引，再弹出table索引的值 举例： local t = { [&amp;quot;a&amp;quot;] = 1, [&amp;quot;b&amp;quot;] = 2, [&amp;quot;c&amp;quot;] = 3 } 使用lua_next遍历table t 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16</description>
    </item>
    
    <item>
      <title>Lua的api</title>
      <link>https://zfunnily.github.io/2021/05/lua_settop%E5%92%8Clua_pop/</link>
      <pubDate>Mon, 10 May 2021 15:57:03 +0800</pubDate>
      
      <guid>https://zfunnily.github.io/2021/05/lua_settop%E5%92%8Clua_pop/</guid>
      <description>lua_pop和lua_settop lua_settop 我们直接来看lua_settop，文档解释 /* 设置栈的高度，如果之前的栈顶比新设置的更高，那么高出来的元素会被丢弃，反之压入nil来补足大小 假设栈里有2个元素。 如果index=0，那么移除栈上所有元素 如果index=1，移除栈顶一个元素 如果in</description>
    </item>
    
    <item>
      <title>Hugo</title>
      <link>https://zfunnily.github.io/2021/04/hugo/</link>
      <pubDate>Sat, 17 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2021/04/hugo/</guid>
      <description>hugo 我用过的静态博客有hexo、jekyll和hugo，对比起来，hugo虽然没有hexo那样丰富的插件和主题，但是hugo生成文章的速度更快。我是一名go语言爱好者，而hugo是go语言开发的, jekyll是用ruby开发的。于是我选择了hugo。下面我把hugo的安装步骤记录下</description>
    </item>
    
    <item>
      <title>Go mod拉取私有仓库</title>
      <link>https://zfunnily.github.io/2021/03/Go-mod%E6%8B%89%E5%8F%96%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93/</link>
      <pubDate>Tue, 23 Mar 2021 16:10:02 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2021/03/Go-mod%E6%8B%89%E5%8F%96%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93/</guid>
      <description>概述 在使用go mod的过程中，依赖的包往往是第三方库，当我们自定义一个包并且放在github.com私有仓库时候，按照原来的方法则会有如下问题。 get &amp;quot;gitlab.com/xxx/zz&amp;quot;: found meta tag get.metaImport{Prefix:&amp;quot;gitlab.com/xxx/zz&amp;quot;, VCS:&amp;quot;git&amp;quot;, RepoRoot:&amp;quot;https://gitlab.com/xxx/zz.git&amp;quot;} at //gitlab.com/xxx/zz?go-get=1 verifying gitlab.com/xxx/zz@v0.0.1: gitlab.com/xxx/zz@v0.0.1: reading https://sum.golang.org/lookup/gitlab.com/xxx/zz@v0.0.1: 410 Gone 这个错误是因为新版本go mod会对依赖包进行checksum校验，但是私有仓库对sum.golang.</description>
    </item>
    
    <item>
      <title>插入排序</title>
      <link>https://zfunnily.github.io/2021/03/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Tue, 23 Mar 2021 13:57:07 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2021/03/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</guid>
      <description>概述 插入排序(InsertionSort)，一般也被称为直接插入排序。 对于少量元素的排序，它是一个有效的算法。插入排序是一种最简单的排序方法，它的基本思想是将一个记录插入到已经排好序的有序表中，从而一个新的、记录数增 1 的有序表。在其实现过程使用双层循环，外层循环对除了第一个元素之</description>
    </item>
    
    <item>
      <title>C&#43;&#43;  sort排序</title>
      <link>https://zfunnily.github.io/2021/03/C-sort%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Tue, 23 Mar 2021 13:40:22 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2021/03/C-sort%E6%8E%92%E5%BA%8F/</guid>
      <description>概述 std::sort( )函数是库函数提供的排序函数，必须包括头文件#include &amp;lt;algorithm&amp;gt;，它使用的排序方法是类似于快排的方法，时间复杂度为n*log2(n) Sort函数有三个参数：（第三个参数可不写） 第一个是要排序的数组的起始地址。- 第二个是结束的地址（最后一位要排序</description>
    </item>
    
    <item>
      <title>快速排序</title>
      <link>https://zfunnily.github.io/2021/03/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Tue, 23 Mar 2021 10:15:40 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2021/03/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</guid>
      <description>sort排序冒泡排序选择排序插入排序快速排序希尔排序堆排序归并排序 概述 分治法的基本思想是：将原问题分解为若干个规模更小但结构与原问题相似的子问题。递归地解这些子问题，然后将这些子问题的解组合为原问题的解。 使用递归，则需要找到递归点和递归出口： 递归点：如果数组的元素大于1，就需要再</description>
    </item>
    
    <item>
      <title>选择排序</title>
      <link>https://zfunnily.github.io/2021/03/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Tue, 23 Mar 2021 10:14:35 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2021/03/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</guid>
      <description>sort排序冒泡排序选择排序插入排序快速排序希尔排序堆排序归并排序 概述 选择排序法（以从小到大排序为例）算法思想：A.在未排序序列中找到最小（大）元素，存放到排序序列的起始位置B.从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾C.以此类推，直到所有元素均排序完毕</description>
    </item>
    
    <item>
      <title>冒泡排序</title>
      <link>https://zfunnily.github.io/2021/03/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Tue, 23 Mar 2021 10:13:31 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2021/03/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</guid>
      <description>sort排序冒泡排序选择排序插入排序快速排序希尔排序堆排序归并排序 概述 冒泡排序算法思想：1.比较相邻的元素。如果第一个比第二个大，就交换他们两个。2.对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数，然后将该数固定3.针对所有的元素重</description>
    </item>
    
    <item>
      <title>《仙剑奇侠传》编译运行</title>
      <link>https://zfunnily.github.io/2021/03/%E4%BB%99%E5%89%91%E5%A5%87%E4%BE%A0%E4%BC%A0%E7%BC%96%E8%AF%91%E8%BF%90%E8%A1%8C/</link>
      <pubDate>Sun, 21 Mar 2021 10:44:58 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2021/03/%E4%BB%99%E5%89%91%E5%A5%87%E4%BE%A0%E4%BC%A0%E7%BC%96%E8%AF%91%E8%BF%90%E8%A1%8C/</guid>
      <description>概述 今天在github上找到了《仙剑奇侠传》的rpg单机游戏sdlpal，sdlpal 是一个开源项目，基于sdl把仙剑奇侠传重写了一遍。 下面是我的编译过程总结。 环境 win10- sdl1.2- sdlpal- vs2017- DirectX SDK10 下载sdlpal $ git clone https://github.com.cnpmjs.org/sdlpal/sdlpal.git 下载sdl1.2 $ git clone https://github.com.cnpmjs.org/libsdl-org/SDL-1.2.git sdlpal/3rd/SDL/ 下载 DirectX SDK10， 双击安装即可 编译sdlpal 打开解决</description>
    </item>
    
    <item>
      <title>使用C/C&#43;&#43;实现atoi和itoa函数</title>
      <link>https://zfunnily.github.io/2021/03/%E4%BD%BF%E7%94%A8C-C-%E5%AE%9E%E7%8E%B0atoi%E5%92%8Citoa%E5%87%BD%E6%95%B0/</link>
      <pubDate>Wed, 17 Mar 2021 16:43:20 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2021/03/%E4%BD%BF%E7%94%A8C-C-%E5%AE%9E%E7%8E%B0atoi%E5%92%8Citoa%E5%87%BD%E6%95%B0/</guid>
      <description>题目1： 把字符串转化为整数 有整数字符串，&amp;quot;13579&amp;quot;, 和 &amp;quot;246810&amp;quot;. 请写一个函数把这两个字符串转化为整数步骤： 先判断正负- 遍历字符串，转换字符为整数 //atoi.cc #include &amp;lt;stdio.h&amp;gt; int my_atoi(char *str) { bool bmin = false; int result = 0; //先判断正负 if ((*str &amp;gt; &#39;9&#39; || *str &amp;lt; &#39;0&#39;) &amp;amp;&amp;amp; (*str == &#39;+&#39; || *str == &#39;-&#39;)) { if (*str == &#39;-&#39;) bmin = true; str++; } while (*str != &#39;\0&#39;) { if (*str &amp;gt; &#39;9&#39; || *str &amp;lt;</description>
    </item>
    
    <item>
      <title>协程解析二(云风的coroutine)</title>
      <link>https://zfunnily.github.io/2021/03/%E5%8D%8F%E7%A8%8B%E8%A7%A3%E6%9E%90%E4%BA%8C%E4%BA%91%E9%A3%8E%E7%9A%84coroutine/</link>
      <pubDate>Wed, 10 Mar 2021 11:11:47 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2021/03/%E5%8D%8F%E7%A8%8B%E8%A7%A3%E6%9E%90%E4%BA%8C%E4%BA%91%E9%A3%8E%E7%9A%84coroutine/</guid>
      <description>概述 云风的coroutine是通过ucontext来控制程序运行时上下文的，我们来根据该库提供的几个接口，和一个demo来解释协程的运行原理。如果不了解ucontext的，建议先了解ucontxt 环境 coroutine- Ubuntu16.04- gcc- make- vscode 下载代码 &amp;amp; 编译 $ git clone https://github.com/cloudwu/coroutine $ cd coroutine &amp;amp;&amp;amp; make 写一个生产者和消费者的demo //procus.c #include &amp;quot;coroutine.h&amp;quot; #include</description>
    </item>
    
    <item>
      <title>协程解析一(ucontext)</title>
      <link>https://zfunnily.github.io/2021/03/%E5%8D%8F%E7%A8%8B%E8%A7%A3%E6%9E%90%E4%B8%80ucontext/</link>
      <pubDate>Tue, 09 Mar 2021 09:43:00 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2021/03/%E5%8D%8F%E7%A8%8B%E8%A7%A3%E6%9E%90%E4%B8%80ucontext/</guid>
      <description>概述 最近在研究协程的实现原理，看了云风的coroutine和腾讯的开源库libco后，原来要实现一个协程库也没那么难。我先来讲讲云风的coroutine库。他使用的是 uncontext来保存程序运行上下文，进而实现协程库，这个库很值深入了解一番，吃透了这个库，协程的原理也就了解了</description>
    </item>
    
    <item>
      <title>关于我</title>
      <link>https://zfunnily.github.io/about/</link>
      <pubDate>Sun, 28 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/about/</guid>
      <description>我是谁 我是一名游戏从业者, 目前在一家公司做游戏后端的工作。 地址 浙江杭州滨江区 Email 582132116@qq.com 技能 skynet框架+lua脚本 &amp;ndash; 游戏后端 C/C++ &amp;ndash; IM服务器 Golang &amp;ndash; 后端</description>
    </item>
    
    <item>
      <title>Golang的定时器实现方式</title>
      <link>https://zfunnily.github.io/2021/02/golang%E7%9A%84%E5%AE%9A%E6%97%B6%E5%99%A8%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/</link>
      <pubDate>Thu, 25 Feb 2021 16:02:13 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2021/02/golang%E7%9A%84%E5%AE%9A%E6%97%B6%E5%99%A8%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/</guid>
      <description>概述 golang有三种方式实现定时器： ticker1. timer1. select Ticker 通过 time.NewTicker(d)的方式实现定时器 d := time.Duration(time.Second * 2) t1 := time.NewTicker(d) defer t1.Stop() go func() { for { &amp;lt;- t1.C fmt.Println(&amp;quot;NewTicker...&amp;quot;) } }() Timer 通过 time.NewTimer(d)的方式实现定时器 t2 := time.NewTimer(d) defer t2.Stop() go func() { for { &amp;lt;- t2.C fmt.Println(&amp;quot;NewTimer...&amp;quot;) } }() select 通过select的方式实现定时器： for { select { case &amp;lt;- time.After(d): fmt.Println(&amp;quot;select...&amp;quot;) } }</description>
    </item>
    
    <item>
      <title>lua解决百元买鸡的问题</title>
      <link>https://zfunnily.github.io/2021/02/lua%E8%A7%A3%E5%86%B3%E7%99%BE%E5%85%83%E4%B9%B0%E9%B8%A1%E7%9A%84%E9%97%AE%E9%A2%98/</link>
      <pubDate>Wed, 24 Feb 2021 17:51:46 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2021/02/lua%E8%A7%A3%E5%86%B3%E7%99%BE%E5%85%83%E4%B9%B0%E9%B8%A1%E7%9A%84%E9%97%AE%E9%A2%98/</guid>
      <description>问题 编写lua程序求解百鸡百钱问题。公鸡5元一只，母鸡3元一只，小鸡一元3只，问100元钱买100只鸡，可买公鸡、母鸡、小鸡各多少只？ 代码 ----------------------------------------------------------------------------- --公鸡5元一只，母鸡3元一只，小鸡一元3只，问100元钱买100只鸡，可买公鸡、母鸡、小鸡各多少只？ ----------------------------------------------------------------------------- local maxprice = 100 --总价 local maxnum = 100 --总数量 local</description>
    </item>
    
    <item>
      <title>Golang使用JWT身份认证</title>
      <link>https://zfunnily.github.io/2021/02/Golang%E4%BD%BF%E7%94%A8JWT%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/</link>
      <pubDate>Wed, 24 Feb 2021 14:22:04 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2021/02/Golang%E4%BD%BF%E7%94%A8JWT%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/</guid>
      <description>概述 最近要在http接口上加一个token认证，但是接口很多，有没有一个省时省力的办法来解决。token的使用流程是： 用户使用帐号密码登陆到服务器1. 服务器验证登陆成功，根据帐号密码生成token。把token返回给客户端1. 客户端请求接口时需要带上token。服务器需要验证to</description>
    </item>
    
    <item>
      <title>Lua调用C/C&#43;&#43;的动态库</title>
      <link>https://zfunnily.github.io/2021/02/Lua%E8%B0%83%E7%94%A8C-C-%E7%9A%84%E5%8A%A8%E6%80%81%E5%BA%93/</link>
      <pubDate>Sat, 20 Feb 2021 11:11:51 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2021/02/Lua%E8%B0%83%E7%94%A8C-C-%E7%9A%84%E5%8A%A8%E6%80%81%E5%BA%93/</guid>
      <description>概述 最近在学习 云风的skynet库，想自定义一个模块，目标是使用lua调用C/C++所编写的库。 当我们需要在Lua里面调用c/c++函数时，所有的函数都必须满足以下函数签名： typedef int (*lua_CFunction) (lua_State *L); 换句话说，所有的函数必须接收一个lua_State作为参数，同时返回一个整数值。因为这个函数使用</description>
    </item>
    
    <item>
      <title>C/C&#43;&#43;调用汇编函数</title>
      <link>https://zfunnily.github.io/2021/02/C-C-%E8%B0%83%E7%94%A8%E6%B1%87%E7%BC%96%E5%87%BD%E6%95%B0/</link>
      <pubDate>Mon, 01 Feb 2021 14:40:51 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2021/02/C-C-%E8%B0%83%E7%94%A8%E6%B1%87%E7%BC%96%E5%87%BD%E6%95%B0/</guid>
      <description>概述 我使用AT&amp;amp;T的规范，在linux上完成 C和汇编的互相调用，并使用gcc编译成可执行文件。目标：汇编函数提供输出。类似C语言的函数 void hello_world(char* value) { printf(value); } 提供给C语言调用： int main() { hello_world(&amp;quot;hello world!\n&amp;quot;); } 搭建AT&amp;amp;T的环境 ubuntu16.04 或 ubuntu18.04- vscode- 文件后缀： .s- gcc 下载vscode插件GNU Assembler Language Support C代码生成为汇编</description>
    </item>
    
    <item>
      <title>AT&amp;T和Intel规范的区别</title>
      <link>https://zfunnily.github.io/2021/01/ATT%E5%92%8CIntel%E8%A7%84%E8%8C%83%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Sun, 31 Jan 2021 11:25:39 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2021/01/ATT%E5%92%8CIntel%E8%A7%84%E8%8C%83%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description>概述 常见的指令集以及汇编语言规范： 表格如下： |AT&amp;amp;T格式|Intel格式|说明 |&amp;mdash;&amp;mdash; |pushl %eax|push eax|在AT&amp;amp;T汇编格式中，寄存器名要加上’ %&amp;lsquo;作为前缀；而在Intel汇编格式中，寄存器名不需要加前缀 |pushl $1|push 1|在AT&amp;amp;T汇编格式中，用’$&#39;前缀表示一个立</description>
    </item>
    
    <item>
      <title>在skynet中使用lua-protobuf库</title>
      <link>https://zfunnily.github.io/2021/01/%E5%9C%A8skynet%E4%B8%AD%E4%BD%BF%E7%94%A8lua-protobuf%E5%BA%93/</link>
      <pubDate>Mon, 25 Jan 2021 14:25:07 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2021/01/%E5%9C%A8skynet%E4%B8%AD%E4%BD%BF%E7%94%A8lua-protobuf%E5%BA%93/</guid>
      <description>概述 在最新的skynet中我使用的是云风的pbc库来解析protobuf，该项目中的一个文件protobuf.lua 使用了module语法在lua5.1版本中已经删除，最新的skynet是lua5.4版本，于是我找到了解析protobuf的lua库–lua-protobuf。在最</description>
    </item>
    
    <item>
      <title>Google Protobuf 请求参数为空的案例</title>
      <link>https://zfunnily.github.io/2021/01/Google-Protobuf-%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E4%B8%BA%E7%A9%BA%E7%9A%84%E6%A1%88%E4%BE%8B/</link>
      <pubDate>Fri, 22 Jan 2021 16:41:16 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2021/01/Google-Protobuf-%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E4%B8%BA%E7%A9%BA%E7%9A%84%E6%A1%88%E4%BE%8B/</guid>
      <description>参数为空的grpc请求怎么定义 google protobuf已经提供了空参数 //empty.proto message Empty {&amp;lt;!-- --&amp;gt;} 使用方法，在proto文件中导入empty.proto, 定义一个请求参数和返回值为空的函数emptyfunction， 函数名字可以自定义。 //server.proto import &amp;quot;google/protobuf/empty.proto&amp;quot;; service pbservice{ rpc emptyfunction(google.protobuf.Empty) return{google.protobuf.Empty} } 以golang语言为例子，在go中对应的函数为： func</description>
    </item>
    
    <item>
      <title>C数组转化为Golang的切片类型</title>
      <link>https://zfunnily.github.io/2021/01/C%E6%95%B0%E7%BB%84%E8%BD%AC%E5%8C%96%E4%B8%BAgo%E7%9A%84%E5%88%87%E7%89%87%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Fri, 22 Jan 2021 15:56:40 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2021/01/C%E6%95%B0%E7%BB%84%E8%BD%AC%E5%8C%96%E4%B8%BAgo%E7%9A%84%E5%88%87%E7%89%87%E7%B1%BB%E5%9E%8B/</guid>
      <description>概述 最近在巩固cgo的基础知识，在网上看到一篇Go和C之间 字符串数组、切片类型转换的文章，让我想到我之前写的一篇在go中遍历C结构体数组的文章，让我有新的方法来解决之前的问题，把C的数组转化为Go的切片，对于文章的方法我直接”拿来主义“。 数组、字符串和切片 我们将一段特定长度的内存</description>
    </item>
    
    <item>
      <title>skynet框架入门--写一个echo服务</title>
      <link>https://zfunnily.github.io/2021/01/skynet%E6%A1%86%E6%9E%B6%E5%85%A5%E9%97%A8-%E5%86%99%E4%B8%80%E4%B8%AAecho%E6%9C%8D%E5%8A%A1/</link>
      <pubDate>Fri, 15 Jan 2021 16:07:51 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2021/01/skynet%E6%A1%86%E6%9E%B6%E5%85%A5%E9%97%A8-%E5%86%99%E4%B8%80%E4%B8%AAecho%E6%9C%8D%E5%8A%A1/</guid>
      <description>概述 引用云风博客的话：“skynet 是一个为网络游戏服务器设计的轻量框架。但它本身并没有任何为网络游戏业务而特别设计的部分，所以尽可以把它用于其它领域。skynet 并不是一个开箱即用的引擎，使用它需要先对框架本身的结构有所了解，理解框架到底帮助开发者解决怎样的问题。如果你希望使用</description>
    </item>
    
    <item>
      <title>Redis源码分析-ziplist压缩列表</title>
      <link>https://zfunnily.github.io/2021/01/Redis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-ziplist%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8/</link>
      <pubDate>Wed, 13 Jan 2021 17:52:27 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2021/01/Redis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-ziplist%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8/</guid>
      <description>概述 Redis中的List是一个有序（按加入的时序排序）的数据结构，一般有序我们会采用数组或者是双向链表，其中双向链表由于有前后指针实际上会很浪费内存。3.2版本之前采用两种数据结构作为底层实现： 压缩列表ziplist- 双向链表linkedlist ziplist的结构 ziplis</description>
    </item>
    
    <item>
      <title>配置VScode调试Redis源码</title>
      <link>https://zfunnily.github.io/2021/01/%E9%85%8D%E7%BD%AEVScode%E8%B0%83%E8%AF%95Redis%E6%BA%90%E7%A0%81/</link>
      <pubDate>Tue, 12 Jan 2021 14:25:29 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2021/01/%E9%85%8D%E7%BD%AEVScode%E8%B0%83%E8%AF%95Redis%E6%BA%90%E7%A0%81/</guid>
      <description>环境 vscode- gcc5.4- ubuntu16.04 或者 ubuntu18.04- make 下载6.2版本. 我使用的是国内github镜像地址：github.com.cnpmjs.org，速度比较快。 $ git clone https://github.com.cnpmjs.org/redis/redis.git redis $ git checkout -b 6.2 remotes/origin/6.2 VScode不参与编译，只充当可视化的调试工具。 使用插件： C/C++ 先编译redis cd redis &amp;amp;&amp;amp; make -j4 打开redis目录后直接按F5，会出现选择启动</description>
    </item>
    
    <item>
      <title>VScode调试Redis源码，指针显示的问题</title>
      <link>https://zfunnily.github.io/2021/01/VScode%E8%B0%83%E8%AF%95Redis%E6%BA%90%E7%A0%81%E6%8C%87%E9%92%88%E6%98%BE%E7%A4%BA%E7%9A%84%E9%97%AE%E9%A2%98/</link>
      <pubDate>Tue, 12 Jan 2021 14:17:22 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2021/01/VScode%E8%B0%83%E8%AF%95Redis%E6%BA%90%E7%A0%81%E6%8C%87%E9%92%88%E6%98%BE%E7%A4%BA%E7%9A%84%E9%97%AE%E9%A2%98/</guid>
      <description>缘由 使用VScode的时候，断点看到指针显示的是一串地址，而不是指针指向的对象的值。上网找了一圈，没看到vscode有对应的插件来解决这个问题。vscode有对应的语法来解决这个问题。网上几乎都在说在监视栏添加下面的表达式可以解决问题， 可以查看int arr_name[10]的值：</description>
    </item>
    
    <item>
      <title>Golang利用cgo遍历C结构体数组</title>
      <link>https://zfunnily.github.io/2021/01/go%E5%88%A9%E7%94%A8cgo%E9%81%8D%E5%8E%86C%E7%BB%93%E6%9E%84%E4%BD%93%E6%95%B0%E7%BB%84/</link>
      <pubDate>Mon, 11 Jan 2021 17:18:35 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2021/01/go%E5%88%A9%E7%94%A8cgo%E9%81%8D%E5%8E%86C%E7%BB%93%E6%9E%84%E4%BD%93%E6%95%B0%E7%BB%84/</guid>
      <description>缘由 现在有个应用场景，我们要在go中获取C结构体数组中的值。在C语言中，对于结构体数组，我们可以利用指针的偏移量来获取我们想要的值的位置。在go中我们怎么使用C指针和偏移量进行运算呢？下面的文字中C指的是C语言 利用cgo作为桥梁，遍历C结构体数组 unsafe.Pointer在C语</description>
    </item>
    
    <item>
      <title>Redis源码解析-sds字符串分析</title>
      <link>https://zfunnily.github.io/2021/01/Redis%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-sds%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%86%E6%9E%90/</link>
      <pubDate>Wed, 06 Jan 2021 14:20:23 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2021/01/Redis%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-sds%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%86%E6%9E%90/</guid>
      <description>SDS头文件及作用 sds.h: sds声明- sdsalloc.h： 为sds分配内存 源码文件sds.h中有这样一行代码 typedef char *sds; 很清晰、明了，sds其实就是char*。最新的6.2分支的代码： struct __attribute__ ((__packed__)) sdshdr5 {&amp;lt;!-- --&amp;gt; unsigned char flags; /* 3 lsb of type, and 5 msb of string length */ char buf[]; }; struct __attribute__ ((__packed__)) sdshdr8 {&amp;lt;!-- --&amp;gt; uint8_t len; /* used */ uint8_t alloc; /* excluding the header and null terminator */ unsigned char flags; /* 3 lsb of type,</description>
    </item>
    
    <item>
      <title>struct中为什么使用char[]而不用char*</title>
      <link>https://zfunnily.github.io/2021/01/struct%E4%B8%AD%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8char%E8%80%8C%E4%B8%8D%E7%94%A8char/</link>
      <pubDate>Tue, 05 Jan 2021 15:45:36 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2021/01/struct%E4%B8%AD%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8char%E8%80%8C%E4%B8%8D%E7%94%A8char/</guid>
      <description>缘由 最近在看redis的源码，刚开始看sds，看到这块代码 struct __attribute__ ((__packed__)) sdshdr5 { unsigned char flags; /* 3 lsb of type, and 5 msb of string length */ char buf[]; }; 好奇为什么使用 char buf[],而不用char *buf，找到答案记录一下。 struct中的char*和char数组有什么区别 常用来构成缓冲区。比起指针，用空数组有这样的优势： 不需要</description>
    </item>
    
    <item>
      <title>最后一战-游戏场景服务器SS解析</title>
      <link>https://zfunnily.github.io/2021/01/%E6%9C%80%E5%90%8E%E4%B8%80%E6%88%98-%E6%B8%B8%E6%88%8F%E5%9C%BA%E6%99%AF%E6%9C%8D%E5%8A%A1%E5%99%A8SS%E8%A7%A3%E6%9E%90/</link>
      <pubDate>Sat, 02 Jan 2021 23:19:58 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2021/01/%E6%9C%80%E5%90%8E%E4%B8%80%E6%88%98-%E6%B8%B8%E6%88%8F%E5%9C%BA%E6%99%AF%E6%9C%8D%E5%8A%A1%E5%99%A8SS%E8%A7%A3%E6%9E%90/</guid>
      <description>游戏场景服务器概况 指令对应的处理handle的文件：SSBattleMgr.cpp 创建战场 指令： eMsgToSSFromCS_CreateBattle- GC服务器发往SS fromCS 收到中心服务器CS创建站场的指令，在函数INT32 CSSBattleMgr::OnMsgFromCS_CreateBattle(const char* pData, int n32DataLength)中创建站场成功后，加入到战场管理器中: m_cAllBattleMap[pBattle-&amp;gt;GetBattleID()] = pBattle; 发送创建结果给CS服务器 CSSWorkThreadMgr::GetInstance().PostMsgToCS(sMsg, sMsg.mgsid()); 发送</description>
    </item>
    
    <item>
      <title>单线程reactor网络库ccnet演变为多线程</title>
      <link>https://zfunnily.github.io/2020/12/%E5%8D%95%E7%BA%BF%E7%A8%8Breactor%E7%BD%91%E7%BB%9C%E5%BA%93ccnet%E6%BC%94%E5%8F%98%E4%B8%BA%E5%A4%9A%E7%BA%BF%E7%A8%8B/</link>
      <pubDate>Wed, 30 Dec 2020 09:19:41 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2020/12/%E5%8D%95%E7%BA%BF%E7%A8%8Breactor%E7%BD%91%E7%BB%9C%E5%BA%93ccnet%E6%BC%94%E5%8F%98%E4%B8%BA%E5%A4%9A%E7%BA%BF%E7%A8%8B/</guid>
      <description>ccnet从单线程演变为多线程 ccnet现状： epoll- linux平台- 事件循环- 单线程- reactor- 监听和新连接的事件都在主线程中 单线程的ccnet ccnet的单线程的角色： EventLoop: 整个事件循环。1. EPollPoller: 负责事件的收集。1. Channel：负责事件的分发。1. Acceptor：处理客户端新连接，绑定监听</description>
    </item>
    
    <item>
      <title>Go sync.Mutex详解</title>
      <link>https://zfunnily.github.io/2020/12/Go-sync.Mutex%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Tue, 29 Dec 2020 13:17:18 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2020/12/Go-sync.Mutex%E8%AF%A6%E8%A7%A3/</guid>
      <description>概述 自己做的一个golang项目需要优化，优化方向是减少gpu内存的使用。同一个模型被重复加载多次，使用更多的gpu内存，也增加 sync.Mutex的使用。优化的方向是: 减少代码量的改动- 减少gpu内存的使用，同一个模型只用加载一次 涉及的问题： sync.Mutex是传值还是传引用</description>
    </item>
    
    <item>
      <title>五种网络IO模型总结</title>
      <link>https://zfunnily.github.io/2020/12/%E4%BA%94%E7%A7%8D%E7%BD%91%E7%BB%9CIO%E6%A8%A1%E5%9E%8B%E6%80%BB%E7%BB%93/</link>
      <pubDate>Mon, 28 Dec 2020 11:57:04 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2020/12/%E4%BA%94%E7%A7%8D%E7%BD%91%E7%BB%9CIO%E6%A8%A1%E5%9E%8B%E6%80%BB%E7%BB%93/</guid>
      <description>概述 在网络上看到很多关于阻塞IO、非阻塞IO、同步IO、异步IO的例子，总觉得写的过于复杂并且让人难以理解。于是我把我自己把这几个概念的理解写下来以供参考。 POSIX POSIX(可移植操作系统接口)把同步IO操作定义为导致进程阻塞直到IO完成的操作，反之则是异步IOI/O 操作一般分为两个</description>
    </item>
    
    <item>
      <title>一个reactor单线程网络库ccnet</title>
      <link>https://zfunnily.github.io/2020/12/%E4%B8%80%E4%B8%AAreactor%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%BD%91%E7%BB%9C%E5%BA%93ccnet/</link>
      <pubDate>Sun, 27 Dec 2020 18:41:25 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2020/12/%E4%B8%80%E4%B8%AAreactor%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%BD%91%E7%BB%9C%E5%BA%93ccnet/</guid>
      <description>缘由 最近在研究陈硕的网络库muduo，是一个基于reactor架构的网络库。我对网络库的感觉是易用，但是内容庞大，依赖颇多。比如boost网络库里面的一些语法让人生畏。关于reactor和proactor架构，还有select/poll/epoll网络模型方面的基础理论知识已经掌</description>
    </item>
    
    <item>
      <title>C&#43;&#43;：vector中的resize()函数 VS reserve()函数</title>
      <link>https://zfunnily.github.io/2020/12/C-vector%E4%B8%AD%E7%9A%84resize%E5%87%BD%E6%95%B0-VS-reserve%E5%87%BD%E6%95%B0/</link>
      <pubDate>Fri, 25 Dec 2020 11:04:29 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2020/12/C-vector%E4%B8%AD%E7%9A%84resize%E5%87%BD%E6%95%B0-VS-reserve%E5%87%BD%E6%95%B0/</guid>
      <description>reserve void reserve (size_type n); reserver函数用来给vector预分配存储区大小，即capacity的值 ，但是没有给这段内存进行初始化。reserve 的参数n是推荐预分配内存的大小，实际分配的可能等于或大于这个值，即n大于capacity的值，就会reallocate内存 capacity的值会大</description>
    </item>
    
    <item>
      <title>用gocolly登录B站</title>
      <link>https://zfunnily.github.io/2020/12/%E7%94%A8gocolly%E7%99%BB%E5%BD%95B%E7%AB%99/</link>
      <pubDate>Sun, 13 Dec 2020 14:51:53 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2020/12/%E7%94%A8gocolly%E7%99%BB%E5%BD%95B%E7%AB%99/</guid>
      <description>概述 gocolly是golang语言开发的爬虫包，通过gocolly来进行模拟网站的登录，目标已经确立，开始行动。 下载 go get -u github.com/gocolly/colly 获取cookie 登录网站：https://www.bilibili.com/获取cookie： google浏览器访问bilibili- 按F12- 查看Net</description>
    </item>
    
    <item>
      <title>自定义头和protobuf解决沾包问题</title>
      <link>https://zfunnily.github.io/2020/12/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%A4%B4%E5%92%8Cprotobuf%E8%A7%A3%E5%86%B3%E6%B2%BE%E5%8C%85%E9%97%AE%E9%A2%98/</link>
      <pubDate>Sun, 13 Dec 2020 10:22:38 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2020/12/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%A4%B4%E5%92%8Cprotobuf%E8%A7%A3%E5%86%B3%E6%B2%BE%E5%8C%85%E9%97%AE%E9%A2%98/</guid>
      <description>缘由 最近在研究一款游戏的源码。发现里面的通信协议是protobuf定义的，但还是自己定义了协议头部，类似 head + body。先解析头部里所存储的整个包的数据长度，然后再解析包剩余的数据，这样做的目的是为了防止沾包。我在想都用了protobuf了为啥不直接用grpc呢。一时想不出，于是我</description>
    </item>
    
    <item>
      <title>Golang的grpc</title>
      <link>https://zfunnily.github.io/2020/12/Golang%E7%9A%84grpc/</link>
      <pubDate>Sun, 13 Dec 2020 09:10:42 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2020/12/Golang%E7%9A%84grpc/</guid>
      <description>OverView gRPC是由Google主导开发的RPC框架，使用HTTP/2协议并用ProtoBuf作为序列化工具。其客户端提供Objective-C、Java接口，服务器侧则有Java、Golang、C++等接口，从而为移动端（iOS/Androi）到服务器端通讯提供了一种解决方案。 当然在</description>
    </item>
    
    <item>
      <title>Ubuntu16.04.6安装Cinnamon3.0</title>
      <link>https://zfunnily.github.io/2020/12/Ubuntu16.04.6%E5%AE%89%E8%A3%85Cinnamon3.0/</link>
      <pubDate>Tue, 01 Dec 2020 15:43:58 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2020/12/Ubuntu16.04.6%E5%AE%89%E8%A3%85Cinnamon3.0/</guid>
      <description>概述 Cinnamon[1]是Linux Mint[2]的默认桌面环境。不同于 Ubuntu 的 Unity 桌面环境，Cinnamon 是一个更加传统而优雅的桌面环境，其带有底部面板和应用菜单。由于 Cinnamon 桌面以及它类 Windows 的用户界面，许多桌面用户相较于 Ubuntu 更喜欢 Linux Mint[3]。 现在你无需安装 Linux Mint[4]就能够体验</description>
    </item>
    
    <item>
      <title>Ubuntu下version `GLIBC_2.27‘ not found错误</title>
      <link>https://zfunnily.github.io/2020/11/Ubuntu%E4%B8%8Bversion-GLIBC_2.27-not-found%E9%94%99%E8%AF%AF/</link>
      <pubDate>Sat, 28 Nov 2020 15:03:04 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2020/11/Ubuntu%E4%B8%8Bversion-GLIBC_2.27-not-found%E9%94%99%E8%AF%AF/</guid>
      <description>version `GLIBC_2.27’ not found错误 执行strings /lib/x86_64-linux-gnu/libc.so.6 | grep GLIBC_ 结果显示如下： GLIBC_2.2.5 GLIBC_2.2.6 GLIBC_2.3 GLIBC_2.3.2 GLIBC_2.3.3 GLIBC_2.3.4 GLIBC_2.4 GLIBC_2.5 GLIBC_2.6 GLIBC_2.7 GLIBC_2.8 GLIBC_2.9 GLIBC_2.10 GLIBC_2.11 GLIBC_2.12 GLIBC_2.13 GLIBC_2.14 GLIBC_2.15 GLIBC_2.16 GLIBC_2.17 GLIBC_2.18 GLIBC_2.22 GLIBC_2.23 GLIBC_2.24 GLIBC_PRIVATE 去清华开源站点下载glibc： https://mirrors.tuna.tsinghua.edu.cn/gnu/libc/下载好文件后解压 tar -zxvf glibc-2.27.tar.gz 进入</description>
    </item>
    
    <item>
      <title>Docker容器退出码详解</title>
      <link>https://zfunnily.github.io/2020/11/Docker%E5%AE%B9%E5%99%A8%E9%80%80%E5%87%BA%E7%A0%81%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Sat, 28 Nov 2020 13:32:57 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2020/11/Docker%E5%AE%B9%E5%99%A8%E9%80%80%E5%87%BA%E7%A0%81%E8%AF%A6%E8%A7%A3/</guid>
      <description>docker查看退出码指令 $ docker ps --filter &amp;quot;status=exited&amp;quot; $ docker inspect container-id --format=&#39;{&amp;lt;!-- --&amp;gt;{.State.ExitCode}}&#39; 常见退出码 Exit Code 0 退出代码0表示特定容器没有附加前台进程。- 该退出代码是所有其他后续退出代码的例外。- 这不一定意味着发生了不好的事情。如果开发人员想要在容器完成其工作后自动停止其容器，则使用此退出代码。 Exit Code 1 程序错误，或者Docker</description>
    </item>
    
    <item>
      <title>使用OpenResty做一个postman小工具</title>
      <link>https://zfunnily.github.io/2020/11/%E4%BD%BF%E7%94%A8OpenResty%E5%81%9A%E4%B8%80%E4%B8%AApostman%E5%B0%8F%E5%B7%A5%E5%85%B7/</link>
      <pubDate>Wed, 25 Nov 2020 16:30:39 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2020/11/%E4%BD%BF%E7%94%A8OpenResty%E5%81%9A%E4%B8%80%E4%B8%AApostman%E5%B0%8F%E5%B7%A5%E5%85%B7/</guid>
      <description>用到的知识点 mvc架构模型渲染库：https://github.com/bungle/lua-resty-templateresty http请求库： https://github.com/bungle/lua-resty-template 参照 mvc模型来做postman工具 配置文件说明 worker_processes 1; error_log logs/error.log; events { worker_connections 1024; } http { lua_package_path &amp;quot;/open_resty/lualib/?.lua;/usr/local/openresty/lualib/?.lua;&amp;quot;; server { listen 8080; default_type &#39;application/json;charset=utf8&#39;; lua_code_cache off; location / { content_by_lua_file mvc.lua; } location ~ ^/js/|^/css/|\.html { root static; } } } lua_code_cache off; 是为了</description>
    </item>
    
    <item>
      <title>OpenResty初探</title>
      <link>https://zfunnily.github.io/2020/11/OpenResty%E5%88%9D%E6%8E%A2/</link>
      <pubDate>Mon, 23 Nov 2020 16:21:34 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2020/11/OpenResty%E5%88%9D%E6%8E%A2/</guid>
      <description>概述 OpenResty®是一个基于Nginx与 Lua 的高性能 Web 平台，其内部集成了大量精良的 Lua 库、第三方模块以及大多数的依赖项。用于方便地搭建能够处理超高并发、扩展性极高的动态 Web 应用、Web 服务和动态网关。 OpenResty®通过汇聚各种设计精良的Nginx模块（主要由 OpenResty 团队自主开发）</description>
    </item>
    
    <item>
      <title>最后一站源码分析(LastBattle)-登录流程(LS &amp; BS &amp; GS)</title>
      <link>https://zfunnily.github.io/2020/11/%E6%9C%80%E5%90%8E%E4%B8%80%E7%AB%99%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90LastBattle-%E7%99%BB%E5%BD%95%E6%B5%81%E7%A8%8BLS-BS-GS/</link>
      <pubDate>Fri, 20 Nov 2020 17:27:08 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2020/11/%E6%9C%80%E5%90%8E%E4%B8%80%E7%AB%99%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90LastBattle-%E7%99%BB%E5%BD%95%E6%B5%81%E7%A8%8BLS-BS-GS/</guid>
      <description>登录流程 根据上一篇文章中的登录流程,我在工程中找到了相应的代码并记录了下来 登录服务代码解析 监听端口：49997 供BS服务连接监听端口：49996 供客户端连接 CIocpCtrl：IOCP控制类 多线程循环查询IOCP内部的网络事件,并分派处理.这里多个工作线程仅仅是将所有的网络事件放</description>
    </item>
    
    <item>
      <title>最后一站源码分析(LastBattle)-服务架构</title>
      <link>https://zfunnily.github.io/2020/11/%E6%9C%80%E5%90%8E%E4%B8%80%E7%AB%99%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90LastBattle-%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84/</link>
      <pubDate>Fri, 20 Nov 2020 17:24:32 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2020/11/%E6%9C%80%E5%90%8E%E4%B8%80%E7%AB%99%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90LastBattle-%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84/</guid>
      <description>服务器架构简图如下: 连线说明： 实线：表示客户端登录流程，①②③④⑤表示登录流程，详细解释见下文。- 虚线：表示服务器间的连接，虚线箭头指向监听方。 架构说明： |英文名称|简称|中文名称|功能简介|单个大区需求数量|数量说明 |&amp;mdash;&amp;mdash; |GameClient|GC|游戏客户端|不解释|n|不超服</description>
    </item>
    
    <item>
      <title>最后一战安装部署笔记</title>
      <link>https://zfunnily.github.io/2020/11/%E6%9C%80%E5%90%8E%E4%B8%80%E6%88%98%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Mon, 16 Nov 2020 06:49:49 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2020/11/%E6%9C%80%E5%90%8E%E4%B8%80%E6%88%98%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2%E7%AC%94%E8%AE%B0/</guid>
      <description>环境准备 win10服务器：vs2010 / 数据库 mysql5.7清华大学mysql镜像网站:https://mirrors.tuna.tsinghua.edu.cn/mysql/downloads/MySQL-5.7/客户端：unity3d 4.6 ,破解补丁 编译客户端 建议不要有其他的un</description>
    </item>
    
    <item>
      <title>cgo使用libevent库实现一个定时器</title>
      <link>https://zfunnily.github.io/2020/11/cgo%E4%BD%BF%E7%94%A8libevent%E5%BA%93%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%AE%9A%E6%97%B6%E5%99%A8/</link>
      <pubDate>Fri, 13 Nov 2020 16:40:42 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2020/11/cgo%E4%BD%BF%E7%94%A8libevent%E5%BA%93%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%AE%9A%E6%97%B6%E5%99%A8/</guid>
      <description>使用libevent库作为例子 下载 &amp;amp; 编译 &amp;amp; 安装libevent $ git clone https://github.com.cnpmjs.org/libevent/libevent.git $ cd libevent &amp;amp;&amp;amp; mkdir build &amp;amp;&amp;amp; cd build $ cmake .. $ make libevent实现的定时器 // main.cpp #include &amp;quot;event.h&amp;quot; struct event ev; struct timeval tv; void time_cb(evutil_socket_t fd, short event, void *argc) { printf(&amp;quot;timer wakeup\n&amp;quot;); event_add(&amp;amp;ev, &amp;amp;tv); // reschedule timer } int main() { struct event_base *base = event_base_new(); tv.tv_sec = 2; tv.tv_usec = 0; evtimer_set(&amp;amp;ev, time_cb, NULL); event_base_set(base, &amp;amp;ev); event_add(&amp;amp;ev, &amp;amp;tv); event_base_dispatch(base); event_base_free(base); } go调用libevent实现定时器 把编译好的头文件和库</description>
    </item>
    
    <item>
      <title>Golang 利用指针进行数据转换</title>
      <link>https://zfunnily.github.io/2020/11/Golang-%E5%88%A9%E7%94%A8%E6%8C%87%E9%92%88%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E8%BD%AC%E6%8D%A2/</link>
      <pubDate>Thu, 12 Nov 2020 17:19:07 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2020/11/Golang-%E5%88%A9%E7%94%A8%E6%8C%87%E9%92%88%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E8%BD%AC%E6%8D%A2/</guid>
      <description>概述 在Go语言中，Slice本质是什么呢？是一个reflect.SliceHeader结构体和这个结构体中Data字段所指向的内存。String本质是什么呢？是一个reflect.StringHeader结构体和这个结构体所指向的内存。 在Go语言中，指针的本质是什么呢？是unsa</description>
    </item>
    
    <item>
      <title>Golang builds</title>
      <link>https://zfunnily.github.io/2020/11/go-builds/</link>
      <pubDate>Thu, 12 Nov 2020 17:15:17 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2020/11/go-builds/</guid>
      <description>概述 通常我们会给每个产品环境设置不同的配置，比如 redis 要在开发环境就连接 localhost:6379，测试环境可能连接某一个主机的 redis。 如果放在 go 里面是否可行？因为 go 是编译二进制包，也没有动态加载这么一说，那怎么实现？ 有个方法可以解决，就是配置文件。我们也可以利用golang的</description>
    </item>
    
    <item>
      <title>cgo的简单使用</title>
      <link>https://zfunnily.github.io/2020/11/cgo%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Thu, 05 Nov 2020 09:45:23 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2020/11/cgo%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</guid>
      <description>使用自己的C函数 文件名：testC.go package main /* #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;stdlib.h&amp;gt; void c_print(char *str) { printf(&amp;quot;%s\n&amp;quot;, str); } */ import &amp;quot;C&amp;quot; //import “C” 必须单起一行，并且紧跟在注释行之后 import &amp;quot;unsafe&amp;quot; func main() { s := &amp;quot;Hello Cgo&amp;quot; cs := C.CString(s) //字符串映射 C.c_print(cs) //调用C函数 defer C.free(unsafe.Pointer(cs)) //释放内存 } 说明：1、go代码中的C代码，需要用注释包裹，块注释和行注释均可，其次import “C”是必</description>
    </item>
    
    <item>
      <title>使用Lumberjack&#43;zap进行日志切割归档</title>
      <link>https://zfunnily.github.io/2020/11/%E4%BD%BF%E7%94%A8Lumberjack-zap%E8%BF%9B%E8%A1%8C%E6%97%A5%E5%BF%97%E5%88%87%E5%89%B2%E5%BD%92%E6%A1%A3/</link>
      <pubDate>Wed, 04 Nov 2020 12:44:03 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2020/11/%E4%BD%BF%E7%94%A8Lumberjack-zap%E8%BF%9B%E8%A1%8C%E6%97%A5%E5%BF%97%E5%88%87%E5%89%B2%E5%BD%92%E6%A1%A3/</guid>
      <description>使用Lumberjack+zap进行日志切割归档 为了添加日志切割归档功能，我们将使用第三方库Lumberjack来实现。 安装 执行下面的命令安装Lumberjack go get -u github.com/natefinch/lumberjack zap logger中加入Lumberjack 要在zap中加入Lumberjack支持，我们需要修改WriteSyn</description>
    </item>
    
    <item>
      <title>vimplus快捷键</title>
      <link>https://zfunnily.github.io/2020/10/vimplus%E5%BF%AB%E6%8D%B7%E9%94%AE/</link>
      <pubDate>Wed, 28 Oct 2020 09:14:28 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2020/10/vimplus%E5%BF%AB%E6%8D%B7%E9%94%AE/</guid>
      <description>插件相关 |快捷键|说明 |&amp;mdash;&amp;mdash; |,|Leader Key |&amp;lt;leader&amp;gt;n|打开 / 关闭代码资源管理器 |&amp;lt;leader&amp;gt;t|打开 / 关闭函数列表 |&amp;lt;leader&amp;gt;a|.h .cpp 文件切换 |&amp;lt;leader&amp;gt;u|转到函数声明 |&amp;lt;leader&amp;gt;U|转到函数实现 |&amp;lt;leader&amp;gt;o|打开</description>
    </item>
    
    <item>
      <title>使用vim打造编C&#43;&#43;IDE</title>
      <link>https://zfunnily.github.io/2020/10/%E4%BD%BF%E7%94%A8vim%E6%89%93%E9%80%A0%E7%BC%96C-IDE/</link>
      <pubDate>Wed, 28 Oct 2020 09:11:32 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2020/10/%E4%BD%BF%E7%94%A8vim%E6%89%93%E9%80%A0%E7%BC%96C-IDE/</guid>
      <description>使用 vimplus 打造C++ IDE GitHub： https://github.com/chxuan/vimplus支持平台：macos/linux 安装vimplus // 原来的链接， 国内速度较慢 $ git clone https://github.com/chxuan/vimplus.git ~/.vimplus // github修改为镜像的链接 $ git clone --depth=1 https://github.com.cnpmjs.org/chxuan/vimplus.git ~/.vimplus $ cd ~/.vimplus //不加sudo $ ./install.sh 设置Nerd Font 为防止vimp</description>
    </item>
    
    <item>
      <title>linux系统删除大量文件指令--rsync</title>
      <link>https://zfunnily.github.io/2020/10/linux%E7%B3%BB%E7%BB%9F%E5%88%A0%E9%99%A4%E5%A4%A7%E9%87%8F%E6%96%87%E4%BB%B6%E6%8C%87%E4%BB%A4-rsync/</link>
      <pubDate>Tue, 13 Oct 2020 16:29:34 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2020/10/linux%E7%B3%BB%E7%BB%9F%E5%88%A0%E9%99%A4%E5%A4%A7%E9%87%8F%E6%96%87%E4%BB%B6%E6%8C%87%E4%BB%A4-rsync/</guid>
      <description>rsync的安装 rsync安装，有些系统默认安装有该命令ubuntu系统 sudo apt-get install rsync centos系统 sudo yum install rsync rsync参数详解 rsync提供了一些跟删除有关的参数 rsync --help | grep delete -del an alias for --delete-during --delete delete extraneous files from destination dirs --delete-before receiver deletes before transfer, not during --delete-during receiver deletes during transfer (default) --delete-delay find deletions during, delete after --delete-after receiver deletes after transfer, not during --delete-excluded also delete excluded files from destination dirs --ignore-errors delete even if there are I/O errors --max-delete=NUM don&#39;t</description>
    </item>
    
    <item>
      <title>CPU的核与线程-4核8线程</title>
      <link>https://zfunnily.github.io/2020/10/CPU%E7%9A%84%E6%A0%B8%E4%B8%8E%E7%BA%BF%E7%A8%8B-4%E6%A0%B88%E7%BA%BF%E7%A8%8B/</link>
      <pubDate>Mon, 12 Oct 2020 16:29:34 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2020/10/CPU%E7%9A%84%E6%A0%B8%E4%B8%8E%E7%BA%BF%E7%A8%8B-4%E6%A0%B88%E7%BA%BF%E7%A8%8B/</guid>
      <description>查看cpu信息 $ cat /proc/cpuinfo 物理CPU 物理CPU就是计算机上实际配置的CPU个数。在linux上可以打开cat /proc/cpuinfo 来查看，其中的physical id就是每个物理CPU的ID，能找到几个physical id就代表计算机实际有几个CPU。 在linux下可以通过指令 grep ‘physical id’ /proc/cpuinfo |</description>
    </item>
    
    <item>
      <title>大量TIME_WAIT对线上业务的影响</title>
      <link>https://zfunnily.github.io/2020/10/%E5%A4%A7%E9%87%8FTIME_WAIT%E5%AF%B9%E7%BA%BF%E4%B8%8A%E4%B8%9A%E5%8A%A1%E7%9A%84%E5%BD%B1%E5%93%8D/</link>
      <pubDate>Sat, 10 Oct 2020 16:46:34 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2020/10/%E5%A4%A7%E9%87%8FTIME_WAIT%E5%AF%B9%E7%BA%BF%E4%B8%8A%E4%B8%9A%E5%8A%A1%E7%9A%84%E5%BD%B1%E5%93%8D/</guid>
      <description>TCP的三次握手和四次挥手 TIME_WAIT概述 TIME_WAIT 状态： TCP 连接中，主动关闭连接的一方出现的状态；（收到 FIN 命令，进入 TIME_WAIT 状态，并返回 ACK 命令） - 保持 2 个 MSL时间，即，4 分钟 ；（MSL 为 2 分钟） TCP 连接建立后，「主动关闭连接」的一端，收到对方的 FIN 请求后，发送 ACK 响应，会处于 time_wait 状态； 在高并发</description>
    </item>
    
    <item>
      <title>Libevent定时器的实现</title>
      <link>https://zfunnily.github.io/2020/09/Libevent%E5%AE%9A%E6%97%B6%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Wed, 16 Sep 2020 23:20:28 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2020/09/Libevent%E5%AE%9A%E6%97%B6%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0/</guid>
      <description>libevent 实现定时器流程 首先初始化libevent库，并保存返回的指针 struct event_base * base = event_init(); 实际上这一步相当于初始化一个Reactor实例；在初始化libevent后，就可以注册事件了。 初始化事件event，设置回调函数和关注的事件 ,事实上这等价于调用event_set(&amp;amp;ev, -1, 0, timer_cb, NULL); evtimer_set(&amp;amp;ev,</description>
    </item>
    
    <item>
      <title>FFmpeg画中画和视频多宫格处理</title>
      <link>https://zfunnily.github.io/2020/09/FFmpeg%E7%94%BB%E4%B8%AD%E7%94%BB%E5%92%8C%E8%A7%86%E9%A2%91%E5%A4%9A%E5%AE%AB%E6%A0%BC%E5%A4%84%E7%90%86/</link>
      <pubDate>Mon, 14 Sep 2020 18:29:33 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2020/09/FFmpeg%E7%94%BB%E4%B8%AD%E7%94%BB%E5%92%8C%E8%A7%86%E9%A2%91%E5%A4%9A%E5%AE%AB%E6%A0%BC%E5%A4%84%E7%90%86/</guid>
      <description>FFmpeg生成画中画 静态画中画 将视频sub.mp4视频文件缩放成宽 480 、高 320 的视频,然后显示在 视频 input.mp4,x坐标为0,y 坐标为0 的位置 ffmpeg -re -i input.mp4 -vf &amp;quot;movie=sub.mp4, scale=480x320[test]; [in][test]overlay [out]&amp;quot; -vcodec libx264 output.flv 显示在画面的右下角，则需要用到 overlay 中x坐标与y坐标的内部变量： ffmpeg -re -i input.mp4 -vf &amp;quot;movie=sub.mp4, scale=480x320[test]; [in][test]overlay=x=main_w-480:y=main_h-320 [out]&amp;quot; -vcodec libx264 output.flv 根据命令行可以分析出，除了</description>
    </item>
    
    <item>
      <title>FFmpeg给视频加文字和图片水印</title>
      <link>https://zfunnily.github.io/2020/09/FFmpeg%E7%BB%99%E8%A7%86%E9%A2%91%E5%8A%A0%E6%96%87%E5%AD%97%E5%92%8C%E5%9B%BE%E7%89%87%E6%B0%B4%E5%8D%B0/</link>
      <pubDate>Sat, 12 Sep 2020 12:47:57 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2020/09/FFmpeg%E7%BB%99%E8%A7%86%E9%A2%91%E5%8A%A0%E6%96%87%E5%AD%97%E5%92%8C%E5%9B%BE%E7%89%87%E6%B0%B4%E5%8D%B0/</guid>
      <description>FFmpeg给视频加上logo ffmpeg从视频中截取图像帧 ffmpeg -i inputfile.avi -r 1 -f image2 image-%05d.jpeg ffmpeg -i inputfile.avi -r 1 -s 4cif -f image2 image-%05d.jpeg ffmpeg -i inputfile.avi -r 1 -t 4 -f image2 image-%05d.jpeg ffmpeg -i inputfile.avi -r 1 -ss 01:30:14 -f image2 image-%05d.jpeg ffmpeg -i inputfile.avi -r 1 -ss 01:30:14 -vframes 120 4cif -f image2 image-%05d.jpeg -r 指定抽取的帧率，即从视频中每秒钟抽取图片的数量。1代表每秒抽取一帧。-f 指定保存图片使用的格式，可忽略。image-</description>
    </item>
    
    <item>
      <title>在windows上使用ffmpeg命令行录制摄像头和桌面数据</title>
      <link>https://zfunnily.github.io/2020/09/%E5%9C%A8windows%E4%B8%8A%E4%BD%BF%E7%94%A8ffmpeg%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%BD%95%E5%88%B6%E6%91%84%E5%83%8F%E5%A4%B4%E5%92%8C%E6%A1%8C%E9%9D%A2%E6%95%B0%E6%8D%AE/</link>
      <pubDate>Wed, 09 Sep 2020 09:36:49 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2020/09/%E5%9C%A8windows%E4%B8%8A%E4%BD%BF%E7%94%A8ffmpeg%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%BD%95%E5%88%B6%E6%91%84%E5%83%8F%E5%A4%B4%E5%92%8C%E6%A1%8C%E9%9D%A2%E6%95%B0%E6%8D%AE/</guid>
      <description>概述 FFmpeg Windows 设备操作 Windows 采集设备的主要方式是 dshow vfwcap gdigrab 其中 dshow 可以用来抓 取摄像头、采集卡、麦克风等，- vfwcap 主要用来采集摄像头类设备，- gdigrab 则是抓取 Windows 窗口程序 FFmpeg 使用 dshow 采集音视频设备 使用 dshow 枚举设备 ffmpeg -f dshow -list_devices true -i dymmy 输出 [dshow @ 000002622302e340] DirectShow video devices (some may be both video and audio devices) [dshow @ 000002622302e340] &amp;quot;Altair USB2.0 Camera&amp;quot; [dshow @ 000002622302e340] Alternative name &amp;quot;@device_pnp_\\?\usb#vid_0ac8&amp;amp;pid_3450&amp;amp;mi_00#6&amp;amp;3b01315a&amp;amp;0&amp;amp;0000#{65e8773d-8f56-11d0-a3b9-00a0c9223196}\global&amp;quot; [dshow @ 000002622302e340] DirectShow audio devices ``使用 dshow 展示摄像头,</description>
    </item>
    
    <item>
      <title>在mac上使用ffmpeg命令行录制摄像头和桌面数据</title>
      <link>https://zfunnily.github.io/2020/08/%E5%9C%A8mac%E4%B8%8A%E4%BD%BF%E7%94%A8ffmpeg%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%BD%95%E5%88%B6%E6%91%84%E5%83%8F%E5%A4%B4%E5%92%8C%E6%A1%8C%E9%9D%A2%E6%95%B0%E6%8D%AE/</link>
      <pubDate>Sat, 29 Aug 2020 17:20:40 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2020/08/%E5%9C%A8mac%E4%B8%8A%E4%BD%BF%E7%94%A8ffmpeg%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%BD%95%E5%88%B6%E6%91%84%E5%83%8F%E5%A4%B4%E5%92%8C%E6%A1%8C%E9%9D%A2%E6%95%B0%E6%8D%AE/</guid>
      <description>设备枚举 查看设备列表 $ ffmpeg -hide_banner -devices Devices: D. = Demuxing supported .E = Muxing supported -- D avfoundation AVFoundation input device D lavfi Libavfilter virtual input device E sdl,sdl2 SDL2 output device 可以看到输入设备有：avfoundation，lavfi输出设备有：sdl``设备采集举例： $ ffmpeg -f avfoundation -list_devices true -i &amp;quot; &amp;quot; 看到了 如下设备 [AVFoundation input device @ 0x7fac75c048c0] AVFoundation video devices: [AVFoundation input device @ 0x7fac75c048c0] [0] FaceTime高清摄像头（内建） [AVFoundation input device @ 0x7fac75c048c0] [1] Capture</description>
    </item>
    
    <item>
      <title>监控Kubernetes——Prometheus&#43;Grafana</title>
      <link>https://zfunnily.github.io/2020/08/%E7%9B%91%E6%8E%A7KubernetesPrometheus-Grafana/</link>
      <pubDate>Mon, 17 Aug 2020 13:58:35 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2020/08/%E7%9B%91%E6%8E%A7KubernetesPrometheus-Grafana/</guid>
      <description>概述 作为应用与Kubernetes的监控体系，Prometheus具备诸多的优势，如： Kubernetes默认支持,非常适合容器和微服务- 无依赖，安装方便，上手容易- 社区活跃，它不仅仅是个工具，而是生态- 已有很多插件或者exporter，可以适应多种应用场景的数据收集需要- Gra</description>
    </item>
    
    <item>
      <title>owt-client-javascript</title>
      <link>https://zfunnily.github.io/2020/08/owt-client-javascript/</link>
      <pubDate>Sun, 16 Aug 2020 23:04:13 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2020/08/owt-client-javascript/</guid>
      <description>概述 天气燥热，不易出门。遂研究一下owt-server，从owt-client-javascript的流程开始吧。 获取一个会议室 owt-client-javascript的时候有一个初始化房间的过程 ///owt-client-javascript/src/samples/conference/samplertcservice.js (function initSampleRoom () { icsREST.API.getRooms(pageOption, function(rooms){ ... // 获取房间信息，如果有房间，直接跳出，如果没有房间则创建一个房间 if</description>
    </item>
    
    <item>
      <title>Ingress的基本使用</title>
      <link>https://zfunnily.github.io/2020/08/Ingress%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Sat, 15 Aug 2020 00:05:15 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2020/08/Ingress%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</guid>
      <description>缘由 看了statefulset基础教程的基础教程，并且把环境搭建起来后。pod内部是可以连通了。但是我不知道怎么去从外部访问。在网上搜索一番，通过Ingress可以作为集群的入口。遂记录之。结合Statefulset的示例进行配置。这是未配置Ingress之前的Statefuls</description>
    </item>
    
    <item>
      <title>Statefluset的持久存储PVC</title>
      <link>https://zfunnily.github.io/2020/08/Statefluset%E7%9A%84%E6%8C%81%E4%B9%85%E5%AD%98%E5%82%A8PVC/</link>
      <pubDate>Fri, 14 Aug 2020 17:18:58 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2020/08/Statefluset%E7%9A%84%E6%8C%81%E4%B9%85%E5%AD%98%E5%82%A8PVC/</guid>
      <description>缘由 在看statefluset基础教程的时候遇到pod状态为pending kubectl describe pod web-0 日志内容是 pod has unbound immediate PersistentVolumeClaims 于是就对PV和PVC进行研究。有给出完整的 web.yaml查看最下面的完整示例。但是我建议先把PV和PVC的概念弄懂了，还有学会查看pod的描述kubectl describe pod podname或</description>
    </item>
    
    <item>
      <title>nsf服务的搭建和使用</title>
      <link>https://zfunnily.github.io/2020/08/nsf%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%90%AD%E5%BB%BA%E5%92%8C%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Fri, 14 Aug 2020 17:17:54 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2020/08/nsf%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%90%AD%E5%BB%BA%E5%92%8C%E4%BD%BF%E7%94%A8/</guid>
      <description>搭建nsf服务 sudo apt install nfs-kernel-server 默认情况下，在Ubuntu 18.04上，NFS版本2是禁用的。版本3和版本4已启用。您可以通过运行以下cat命令来验证： sudo cat /proc/fs/nfsd/versions 写入 exports cat /etc/exports sudo echo /nfs/prometheus/data/ 192.168.84.75/24(rw,no_root_squash,no_all_squash,sync) &amp;gt;&amp;gt; /etc/exports sudo echo /nfs/prometheus/data/ 192.168.84.75/24(rw,no_root_squash,no_all_squash,sync) &amp;gt;&amp;gt; /etc/exports 可以设定的参数主要有以下这些： rw：可读写的权限； ro：只读的权限； no_root_squash：</description>
    </item>
    
    <item>
      <title>StatefulSet基本原理</title>
      <link>https://zfunnily.github.io/2020/08/StatefulSet%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/</link>
      <pubDate>Fri, 14 Aug 2020 16:03:41 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2020/08/StatefulSet%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/</guid>
      <description>背景 用户通过 Deployment、ReplicationController 可以方便地在 kubernetes 中部署一套高可用、可扩展的分布式无状态服务。这类应用不在本地存储数据，通过简单的负载均衡策略可实现请求分发。随着 k8s 的普及和云原生架构的兴起，越来越多的人希望把数据库这类有状态服务也通过 k8s 进行</description>
    </item>
    
    <item>
      <title>coreDNS的部署安装，对k8s来说很重要</title>
      <link>https://zfunnily.github.io/2020/08/coreDNS%E7%9A%84%E9%83%A8%E7%BD%B2%E5%AE%89%E8%A3%85%E5%AF%B9k8s%E6%9D%A5%E8%AF%B4%E5%BE%88%E9%87%8D%E8%A6%81/</link>
      <pubDate>Thu, 13 Aug 2020 18:44:28 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2020/08/coreDNS%E7%9A%84%E9%83%A8%E7%BD%B2%E5%AE%89%E8%A3%85%E5%AF%B9k8s%E6%9D%A5%E8%AF%B4%E5%BE%88%E9%87%8D%E8%A6%81/</guid>
      <description>概述 CoreDNS可以在具有标准的Kube-DNS的Kubernetes集群中运行。作为Kubernetes 的插件使用，CoreDNS将从 Kubernetes集群中读取区（zone）数据。它实现了为Kubernetes的DNS服务发现定义的规范：Kubernetes DNS-Based Service Disco</description>
    </item>
    
    <item>
      <title>使用k8s创建第一个应用</title>
      <link>https://zfunnily.github.io/2020/08/%E4%BD%BF%E7%94%A8k8s%E5%88%9B%E5%BB%BA%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%BA%94%E7%94%A8/</link>
      <pubDate>Thu, 13 Aug 2020 15:28:31 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2020/08/%E4%BD%BF%E7%94%A8k8s%E5%88%9B%E5%BB%BA%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%BA%94%E7%94%A8/</guid>
      <description>使用k8s部署第一个应用 创建一个nginx.yaml文件 apiVersion: v1 kind: Pod metadata: name: nginx # 指定 label，便于检索 labels: app: nginx spec: containers: - name: nginx # 指定镜像 image: nginx:alpine # 指定暴露端口 ports: - containerPort: 80 --- # 创建网络服务 apiVersion: v1 kind: Service metadata: name: kube-node-service labels: name: kube-node-service spec: type: NodePort #这里代表是NodePort类型的 ports: - port: 80 #这里的端口和clusterIP(10.97.1</description>
    </item>
    
    <item>
      <title>licod安装和配置</title>
      <link>https://zfunnily.github.io/2020/08/licod%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE/</link>
      <pubDate>Sun, 09 Aug 2020 09:34:36 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2020/08/licod%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE/</guid>
      <description>拉取docker镜像并运行 licode官方提供了配置好的docker镜像，使用以下命令拉下来跑就行。 docker run --name licode -p 3000:3000 -p $MIN_PORT-$MAX_PORT:30000-30050/udp -p 3001:3001 -p 8080:8080 -e &amp;quot;MIN_PORT=30000&amp;quot; -e &amp;quot;MAX_PORT=30050&amp;quot; -e &amp;quot;PUBLIC_IP=your_ip_address&amp;quot; lynckia/licode 注意命令里的PUBLIC_IP要改为服务器的公网IP。 配置好之后，在地址栏输入ip:3001回车，chrome就会弹出是否允许摄像头麦克风那个</description>
    </item>
    
    <item>
      <title>Docker远程访问加密</title>
      <link>https://zfunnily.github.io/2020/08/Docker%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AE%E5%8A%A0%E5%AF%86/</link>
      <pubDate>Fri, 07 Aug 2020 07:56:52 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2020/08/Docker%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AE%E5%8A%A0%E5%AF%86/</guid>
      <description>docker的远程访问 方法一 ：编辑docker.service文件 编辑docker.service文件 sudo vim /lib/systemd/system/docker.service 修改ExecStart行为下面内容 ExecStart=/usr/bin/dockerd -H tcp://0.0.0.0:2375 -H unix://var/run/docker.sock 重新加载docker配置 sudo systemctl daemon-reload // 1，加载docker守护线程 sudo systemctl restart docker // 2，重启docker `` 方法二：修改daemon.json的</description>
    </item>
    
    <item>
      <title>Docker的web管理界面，portainer</title>
      <link>https://zfunnily.github.io/2020/08/Docker%E7%9A%84web%E7%AE%A1%E7%90%86%E7%95%8C%E9%9D%A2portainer/</link>
      <pubDate>Fri, 07 Aug 2020 07:54:43 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2020/08/Docker%E7%9A%84web%E7%AE%A1%E7%90%86%E7%95%8C%E9%9D%A2portainer/</guid>
      <description>拉取镜像 $ docker pull portainer/portainer 运行启动portainer docker run -d -p 9000:9000 -v /var/run/docker.sock:/var/run/docker.sock -v /home/docker/portainer:/data --name portainer --restart=always portainer/portainer adminbigant.cn 汉化 Portainer-CN.zip百度云盘: https://pan.baidu.com/s/13ra6jXHR_7vajLLlf5GVEw 提取码: nzue新建文件夹命名为public，把Portainer-CN.zip解压至里面。 2、public文件夹传输至系统根目录 3、然后按需执行以下命令 x86-</description>
    </item>
    
    <item>
      <title>k8s集群资源监控 heapster</title>
      <link>https://zfunnily.github.io/2020/08/k8s%E9%9B%86%E7%BE%A4%E8%B5%84%E6%BA%90%E7%9B%91%E6%8E%A7-heapster/</link>
      <pubDate>Thu, 06 Aug 2020 09:06:05 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2020/08/k8s%E9%9B%86%E7%BE%A4%E8%B5%84%E6%BA%90%E7%9B%91%E6%8E%A7-heapster/</guid>
      <description>安装heapster的原因 查看dashboard状态 $ sudo kubectl get pods --all-namespaces | grep dashboard kubernetes-dashboard dashboard-metrics-scraper-6b4884c9d5-mvnb9 1/1 Running 0 40m kubernetes-dashboard kubernetes-dashboard-d7f7f565d-zhpsc 1/1 Running 0 40m 查看dashboard的日志 $ sudo kubectl logs -f -n kubernetes-dashboard kubernetes-dashboard-d7f7f565d-zhpsc 日志遇到这样的情况 No metric client provided. Skipping metrics. 2020/08/03 09:02:22 [2020-08-03T09:02:22Z] Outcoming response to 192.168.84.241:40086 with 200 status code 2020/08/03 09:02:23 Metric client health check failed: the server is currently unable to handle the request (get services dashboard-metrics-scraper). Retrying in 30 seconds. 下载heapster的代码 直接现在Githu</description>
    </item>
    
    <item>
      <title>k8s的界面管理 Dashboard</title>
      <link>https://zfunnily.github.io/2020/08/k8s%E7%9A%84%E7%95%8C%E9%9D%A2%E7%AE%A1%E7%90%86-Dashboard/</link>
      <pubDate>Thu, 06 Aug 2020 09:04:14 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2020/08/k8s%E7%9A%84%E7%95%8C%E9%9D%A2%E7%AE%A1%E7%90%86-Dashboard/</guid>
      <description>安装部署Dashboard 通过一下命令来部署, recommended.yaml $ sudo kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v2.0.0/aio/deploy/recommended.yaml https://raw.githubusercontent.com/kubernetes/dashboard/v2.0.0/aio/deploy/recommended.yaml这个地址却很难打开，如果能打开，直接执行即</description>
    </item>
    
    <item>
      <title>k8s的第一步，安装！</title>
      <link>https://zfunnily.github.io/2020/08/k8s%E7%9A%84%E7%AC%AC%E4%B8%80%E6%AD%A5%E5%AE%89%E8%A3%85/</link>
      <pubDate>Wed, 05 Aug 2020 10:00:40 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2020/08/k8s%E7%9A%84%E7%AC%AC%E4%B8%80%E6%AD%A5%E5%AE%89%E8%A3%85/</guid>
      <description>安装k8s前的准备工作 环境 ubuntu18.04- docker 关闭 swap 暂时关闭 $ swapoff -a 永久关闭 注释掉这一行 sudo vim /etc/fstab # /swapfile none swap sw 0 0 重启机器 sudo reboot docker 的配置 安装完成之后需要进行一些配置，包括 切换docker下载源为国内镜像站 以及 修改cgroups。cgroups是一个进程隔离工具 docker就是用它来实现容器的隔离的。doc</description>
    </item>
    
    <item>
      <title>owt-server编译运行</title>
      <link>https://zfunnily.github.io/2020/08/owt-server%E7%BC%96%E8%AF%91%E8%BF%90%E8%A1%8C/</link>
      <pubDate>Wed, 05 Aug 2020 09:47:22 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2020/08/owt-server%E7%BC%96%E8%AF%91%E8%BF%90%E8%A1%8C/</guid>
      <description>概述 owt是一套完整的webrtc视频会议系统。包含的功能模块有： 视频会议1. p2p 服务器是owt-server通过nodejs编写的webrtc信令。依赖是licode。licode依赖webrtc。客户端系列web/windows/linux/ios/android都有相应的sd</description>
    </item>
    
    <item>
      <title>归档</title>
      <link>https://zfunnily.github.io/archives/</link>
      <pubDate>Fri, 17 Apr 2020 20:43:57 +0800</pubDate>
      
      <guid>https://zfunnily.github.io/archives/</guid>
      <description></description>
    </item>
    
    <item>
      <title>搜索</title>
      <link>https://zfunnily.github.io/search/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/search/</guid>
      <description></description>
    </item>
    
  </channel>
</rss>