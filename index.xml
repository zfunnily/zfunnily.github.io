<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Zzz记忆</title><link>https://zfunnily.github.io/</link><description>Recent content on Zzz记忆</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Mon, 05 Feb 2024 01:02:07 +0000</lastBuildDate><atom:link href="https://zfunnily.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>11月</title><link>https://zfunnily.github.io/2023/12/30/</link><pubDate>Sat, 30 Dec 2023 15:45:00 +0800</pubDate><guid>https://zfunnily.github.io/2023/12/30/</guid><description>学习 银河城地图 搭建 ue5 paper2d 书籍 《游戏设计艺术》 电影 《复仇者联盟》4 游戏 《血污：夜之仪式》 《LOL》 番剧 其他</description></item><item><title>11月</title><link>https://zfunnily.github.io/2023/11/30/</link><pubDate>Thu, 30 Nov 2023 15:45:00 +0800</pubDate><guid>https://zfunnily.github.io/2023/11/30/</guid><description>学习 chatglm + langchain 知识库 docker搭建 ue5 paper2d的使用 wsl 子系统研究， win11 镜像模式. 电视剧 《繁城之下》 番剧 《反叛的鲁路修》 一季、二季 书籍 《置身事内》 电影 《复仇者联盟》3 游戏 《马里奥惊奇》已完结 《血污：夜之</description></item><item><title>WSL2改为桥接</title><link>https://zfunnily.github.io/2023/11/wsl2/</link><pubDate>Fri, 17 Nov 2023 15:45:00 +0800</pubDate><guid>https://zfunnily.github.io/2023/11/wsl2/</guid><description>需求 在docker容器内部程序自己获取的ip是172开头的。我需要跟宿主机同样网段的ip。 问题 win10系统wsl2 不支持桥接 更简单的解决方案 使用vmware虚拟机，直接启动一个linux镜像，然后使</description></item><item><title>Python3.7安装</title><link>https://zfunnily.github.io/2023/11/python/</link><pubDate>Thu, 16 Nov 2023 15:39:01 +0800</pubDate><guid>https://zfunnily.github.io/2023/11/python/</guid><description>环境 centos7 开始安装 安装扩展 $ yum -y install yum-utils 安装Centos开发工具 $ yum -y groupinstall development 安装python3依赖 $ yum -y install zlib-devel bzip2-devel openssl-devel openssl-static ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel libffi-devel lzma gcc 下载python3.7安装包 # 将python3.7安装包，下载到/usr/</description></item><item><title>Docker | Mysql 挂载目录一键部署</title><link>https://zfunnily.github.io/2023/11/mysql/</link><pubDate>Thu, 16 Nov 2023 11:36:44 +0800</pubDate><guid>https://zfunnily.github.io/2023/11/mysql/</guid><description>创建挂载文件 mkdir -p conf mkdir -p logs mkdir -p mysql 编辑配置文件 cd conf/ vi my.cnf # Copyright (c) 2014, 2016, Oracle and/or its affiliates. All rights reserved. # # This program is free software; you can redistribute it and/or modify # it under the terms of the GNU General Public License as published by # the Free Software Foundation; version 2 of the License. # # This program is distributed in the hope that it will be useful, # but WITHOUT ANY WARRANTY; without even the implied warranty of #</description></item><item><title>Svn</title><link>https://zfunnily.github.io/2023/11/svn/</link><pubDate>Tue, 14 Nov 2023 16:46:02 +0800</pubDate><guid>https://zfunnily.github.io/2023/11/svn/</guid><description>SVN 合并 从源svn分支合并到目标svn分支 在源svn项目下鼠标右键，TortoiseSVN -&amp;gt; Repo-browser, 拿到源项目svn地址 在目标svn项目下鼠标右键，TortoiseSVN -&amp;gt; Merge -&amp;gt;, 填入源项目svn地址 在show l</description></item><item><title>WSL2子系统迁移</title><link>https://zfunnily.github.io/2023/11/wsl/</link><pubDate>Mon, 13 Nov 2023 22:21:34 +0800</pubDate><guid>https://zfunnily.github.io/2023/11/wsl/</guid><description>wsl 安装 参考链接: https://learn.microsoft.com/zh-cn/windows/wsl/install 通过命令行安装 wsl --update wsl -v -l wsl --install wsl &amp;amp; docker 迁移 WSL发行版默认都是安装在C盘，在%LOCALAPPDATA%/Docker/wsl目录 docker的运行数据、镜像文件都存在%LOCALAPP</description></item><item><title>GithubAction</title><link>https://zfunnily.github.io/2023/11/gitaction/</link><pubDate>Mon, 13 Nov 2023 11:21:34 +0800</pubDate><guid>https://zfunnily.github.io/2023/11/gitaction/</guid><description>Github Token 生成 &amp;amp; 设置 github -&amp;gt; Settings -&amp;gt; Developer Settings -&amp;gt; Personal access tokens 新增 Tokens(classic) 点击Generate new token 点击你想使用Action的github仓库 Settings -&amp;gt; Secrets and variables -&amp;gt; Actions -&amp;gt; New respository secret. 填上名字ACTION_ACCESS_TOKEN和第一步生成的 token，</description></item><item><title>ChatGLM &amp; LangChain</title><link>https://zfunnily.github.io/2023/11/chatglm/</link><pubDate>Fri, 10 Nov 2023 11:21:34 +0800</pubDate><guid>https://zfunnily.github.io/2023/11/chatglm/</guid><description>参考： https://www.luckzym.com/posts/e95da08c/#more 环境准备 Win11 linux 子系统 wsl2 Ubuntu22.04子系统 Docker for windows ChatGLM 项目模型下载 显卡 4070 12G 内存 16G*2 cpu 13600kf nvidia-docker安装 https://juejin.cn/s/windows%20nvidia-docker%E5%AE%89%E8%A3%85 # Add the package repositories curl -s -L https://nvidia.github.io/nvidia-docker/gpgkey | \ sudo apt-key add - distribution=$(. /etc/os-release;echo $ID$VERSION_ID) curl -s -L https://nvidia.github.io/nvidia-docker/$distribution/nvidia-docker.list | \ sudo tee /etc/apt/sources.list.d/nvidia-docker.list sudo apt-get update # Install nvidia-docker2 and reload the Docker</description></item><item><title>DDNS配置</title><link>https://zfunnily.github.io/2023/10/DDNS/</link><pubDate>Mon, 30 Oct 2023 11:21:34 +0800</pubDate><guid>https://zfunnily.github.io/2023/10/DDNS/</guid><description>参考： https://www.sakamoto.blog/synology-nas-cloudflare-ddns/ Cloudflare 获取 区域 ID 创建 API 令牌 群晖设置 开启并登陆群晖NAS终端 下载 Cloudflare DDNS 脚本 下载 Cloudflare 的 DDNS 脚本文件,官方推荐存放于/sbin/cloudflareddns.sh并赋予执行权限. # 下载脚本 $ wget https://raw.githubusercontent.com/joshuaavalon/SynologyCloudflareDDNS/master/cloudflareddns.sh -O /sbin/cloudflareddns.sh # 赋予执行</description></item><item><title>粒子系统01-概述</title><link>https://zfunnily.github.io/2023/05/particlesystem01/</link><pubDate>Wed, 24 May 2023 11:21:34 +0800</pubDate><guid>https://zfunnily.github.io/2023/05/particlesystem01/</guid><description>参考视频 参考播客 一、两种解决方案 区别 Particle System(内置粒子系统) Visual Effect Graph(VFX Graph) 基于XX运行 CPU GPU 粒子数量 数千 数百万 渲染管线 支持全部渲染管线 不支持内置渲染管线 物理系统 可与Unity物理系统交互 特定元素交互 创作</description></item><item><title>Netch加速SWITCH</title><link>https://zfunnily.github.io/2022/10/netch/</link><pubDate>Thu, 27 Oct 2022 10:09:44 +0800</pubDate><guid>https://zfunnily.github.io/2022/10/netch/</guid><description>需求 对于有机场的用户，不用再花一份加速器的钱给Switch加速 前提条件 电脑通过(shadowrocks/v2ray)开启科学上网,使用端口 1080 电脑局域网IP 192.168.0.103 允许局域网设备连入 解决过程 switch的代理</description></item><item><title>Netch加速SWITCH</title><link>https://zfunnily.github.io/2022/10/netch/</link><pubDate>Thu, 27 Oct 2022 10:09:44 +0800</pubDate><guid>https://zfunnily.github.io/2022/10/netch/</guid><description>需求 对于有机场的用户，不用再花一份加速器的钱给Switch加速 前提条件 电脑通过(shadowrocks/v2ray)开启科学上网,使用端口 1080 电脑局域网IP 192.168.0.103 允许局域网设备连入 解决过程 switch的代理</description></item><item><title>adj</title><link>https://zfunnily.github.io/english/xdf/04_adj/</link><pubDate>Mon, 18 Jul 2022 09:45:29 +0800</pubDate><guid>https://zfunnily.github.io/english/xdf/04_adj/</guid><description>形容词在名词短语中的位置 前置修饰名词 单个形容词在名词短语中的位置 在一个名词短语中，若是单个形容词作定语修饰一个名词，其结构通常是“限定词＋形容词＋名词” 修饰something，anything，not</description></item><item><title>Gitlab | CI/CD简单实现</title><link>https://zfunnily.github.io/2022/06/cicd/</link><pubDate>Wed, 22 Jun 2022 14:26:25 +0800</pubDate><guid>https://zfunnily.github.io/2022/06/cicd/</guid><description>CI/CD 流水线 组件组成 stages job gitlab runner(可以与gitlab服务器独立, c/s架构. ) -------- -------- --------- |stage1| -&amp;gt; |stage2| -&amp;gt; | stage3| -------- -------- --------- ------ ------ ------- |job1| |job2| | job3| ------ ------ ------- --------- --------- --------- |runner1| |runner2| -&amp;gt; |runner3| --------- --------- --------- pipline: 包含多个stage， 顺序执行 stages: 一个stage可以包含多</description></item><item><title>Gitlab | CI/CD简单实现</title><link>https://zfunnily.github.io/2022/06/cicd/</link><pubDate>Wed, 22 Jun 2022 14:26:25 +0800</pubDate><guid>https://zfunnily.github.io/2022/06/cicd/</guid><description>CI/CD 流水线 组件组成 stages job gitlab runner(可以与gitlab服务器独立, c/s架构. ) -------- -------- --------- |stage1| -&amp;gt; |stage2| -&amp;gt; | stage3| -------- -------- --------- ------ ------ ------- |job1| |job2| | job3| ------ ------ ------- --------- --------- --------- |runner1| |runner2| -&amp;gt; |runner3| --------- --------- --------- pipline: 包含多个stage， 顺序执行 stages: 一个stage可以包含多</description></item><item><title>百度网盘不限速 | Aria2篇</title><link>https://zfunnily.github.io/2022/05/baidu/</link><pubDate>Tue, 17 May 2022 16:40:59 +0800</pubDate><guid>https://zfunnily.github.io/2022/05/baidu/</guid><description>环境 win10 chrome 油猴插件 aria2 Aria2 对于不想折腾的有懒人包. 实际上包里含有的是aria2软件和aria2 GUI。 下载链接如下: 懒人下载包 AriaNg Aria2 百度网盘简易下载助手 安装油猴脚本: 百度网盘简易下载助手 安装好上述脚本之后，可</description></item><item><title>百度网盘不限速 | Aria2篇</title><link>https://zfunnily.github.io/2022/05/baidu/</link><pubDate>Tue, 17 May 2022 16:40:59 +0800</pubDate><guid>https://zfunnily.github.io/2022/05/baidu/</guid><description>环境 win10 chrome 油猴插件 aria2 Aria2 对于不想折腾的有懒人包. 实际上包里含有的是aria2软件和aria2 GUI。 下载链接如下: 懒人下载包 AriaNg Aria2 百度网盘简易下载助手 安装油猴脚本: 百度网盘简易下载助手 安装好上述脚本之后，可</description></item><item><title>URP 不透明/半透明物体的折射</title><link>https://zfunnily.github.io/2022/05/refraction/</link><pubDate>Tue, 17 May 2022 11:30:48 +0800</pubDate><guid>https://zfunnily.github.io/2022/05/refraction/</guid><description>折射 应用场景 水池 玻璃 热空气(热扭曲) GrabPass + CubeMap 《Unity3D Shader入门精要》第十章介绍了，模拟实现折射效果有两种 使用cubemap: 我认为太麻烦.需要的贴图太多。也没有找到其他合适的使用场景，遂搁</description></item><item><title>URP 不透明/半透明物体的折射</title><link>https://zfunnily.github.io/2022/05/refraction/</link><pubDate>Tue, 17 May 2022 11:30:48 +0800</pubDate><guid>https://zfunnily.github.io/2022/05/refraction/</guid><description>折射 应用场景 水池 玻璃 热空气(热扭曲) GrabPass + CubeMap 《Unity3D Shader入门精要》第十章介绍了，模拟实现折射效果有两种 使用cubemap: 我认为太麻烦.需要的贴图太多。也没有找到其他合适的使用场景，遂搁</description></item><item><title>《Unity Shader入门精要》第八章笔记 | 透明度</title><link>https://zfunnily.github.io/2022/05/shaderalpha/</link><pubDate>Sat, 07 May 2022 17:17:18 +0800</pubDate><guid>https://zfunnily.github.io/2022/05/shaderalpha/</guid><description>渲染顺序 名称 队列索引号 描 述 Background 1000 这个渲染队列会在任何其他队列之前被渲染，我们通常使用该队列来渲染那些需要绘制在背景上的物体 Geometry 2000 默认的渲染队列，大多数物体都使用这个队列。不透明物体使用这个队列 AlphaTest 2450 需要透明</description></item><item><title>《Unity Shader入门精要》第八章笔记 | 透明度</title><link>https://zfunnily.github.io/2022/05/shaderalpha/</link><pubDate>Sat, 07 May 2022 17:17:18 +0800</pubDate><guid>https://zfunnily.github.io/2022/05/shaderalpha/</guid><description>渲染顺序 名称 队列索引号 描 述 Background 1000 这个渲染队列会在任何其他队列之前被渲染，我们通常使用该队列来渲染那些需要绘制在背景上的物体 Geometry 2000 默认的渲染队列，大多数物体都使用这个队列。不透明物体使用这个队列 AlphaTest 2450 需要透明</description></item><item><title>《Unity Shader入门精要》第六章笔记 | 基础光照</title><link>https://zfunnily.github.io/2022/05/shaderlighting/</link><pubDate>Sat, 07 May 2022 16:22:40 +0800</pubDate><guid>https://zfunnily.github.io/2022/05/shaderlighting/</guid><description>我们是如何看到这个世界的 光源: 在光学里，我们使用辐照度 （irradiance） 来量化光 物体的吸收和散射: 光线由光源发射出来后，就会与一些物体相交 着色: 根据材质属性（如漫反射属性等）、光源信息（如光源方</description></item><item><title>《Unity Shader入门精要》第六章笔记 | 基础光照</title><link>https://zfunnily.github.io/2022/05/shaderlighting/</link><pubDate>Sat, 07 May 2022 16:22:40 +0800</pubDate><guid>https://zfunnily.github.io/2022/05/shaderlighting/</guid><description>我们是如何看到这个世界的 光源: 在光学里，我们使用辐照度 （irradiance） 来量化光 物体的吸收和散射: 光线由光源发射出来后，就会与一些物体相交 着色: 根据材质属性（如漫反射属性等）、光源信息（如光源方</description></item><item><title>《Unity Shader入门精要》第五章笔记 | 开始shader练习</title><link>https://zfunnily.github.io/2022/05/shaderbase/</link><pubDate>Sat, 07 May 2022 10:22:33 +0800</pubDate><guid>https://zfunnily.github.io/2022/05/shaderbase/</guid><description>一个简单的顶点/片元着色器 代码 Shader &amp;#34;Unity Shaders Book/Chapter 5/Simple Shader&amp;#34; { Properties { // 声明一个Color类型的属性 _Color (&amp;#34;Color Tint&amp;#34;, Color) = (1.0,1.0,1.0,1.0) } SubShader { Pass { CGPROGRAM #pragma vertex vert #pragma fragment frag // 在Cg代码中，我们需要定义一个与属性名称和类型都匹配的变量 fixed4 _Color; // 使用一个结构体来定义</description></item><item><title>《Unity Shader入门精要》第五章笔记 | 开始shader练习</title><link>https://zfunnily.github.io/2022/05/shaderbase/</link><pubDate>Sat, 07 May 2022 10:22:33 +0800</pubDate><guid>https://zfunnily.github.io/2022/05/shaderbase/</guid><description>一个简单的顶点/片元着色器 代码 Shader &amp;#34;Unity Shaders Book/Chapter 5/Simple Shader&amp;#34; { Properties { // 声明一个Color类型的属性 _Color (&amp;#34;Color Tint&amp;#34;, Color) = (1.0,1.0,1.0,1.0) } SubShader { Pass { CGPROGRAM #pragma vertex vert #pragma fragment frag // 在Cg代码中，我们需要定义一个与属性名称和类型都匹配的变量 fixed4 _Color; // 使用一个结构体来定义</description></item><item><title>MAC平台几何着色器不生效</title><link>https://zfunnily.github.io/2022/05/geometry/</link><pubDate>Thu, 05 May 2022 16:49:29 +0800</pubDate><guid>https://zfunnily.github.io/2022/05/geometry/</guid><description>问题 MAC平台几何着色器不生效 解决步骤 unity shaderlab 怎么设置以至于支持几何着色器 找原因，设置 编译目标级别，#pragma target 4.0, 不管用 看到一句话，Unity 在 Metal 图形上支持曲面细分着色器，但 Metal 不支持几何着色器 找到ma</description></item><item><title>MAC平台几何着色器不生效</title><link>https://zfunnily.github.io/2022/05/geometry/</link><pubDate>Thu, 05 May 2022 16:49:29 +0800</pubDate><guid>https://zfunnily.github.io/2022/05/geometry/</guid><description>问题 MAC平台几何着色器不生效 解决步骤 unity shaderlab 怎么设置以至于支持几何着色器 找原因，设置 编译目标级别，#pragma target 4.0, 不管用 看到一句话，Unity 在 Metal 图形上支持曲面细分着色器，但 Metal 不支持几何着色器 找到ma</description></item><item><title>ShaderLab常用函数</title><link>https://zfunnily.github.io/2022/04/shaderfunc/</link><pubDate>Wed, 20 Apr 2022 15:41:29 +0800</pubDate><guid>https://zfunnily.github.io/2022/04/shaderfunc/</guid><description>数学函数 cg/hlsl函数 功能描述 dot(A,B) 点积, 点积结果为标量，主要用于求向量的夹角或b向量在a向量上的投影 cross(A,B) 叉积, 叉积结果为向量，结果与这两个向量组成的平面垂直。主要用于3D图形学 mul(M, N) 矩阵M和矩阵N的积 mul(M,</description></item><item><title>ShaderLab常用函数</title><link>https://zfunnily.github.io/2022/04/shaderfunc/</link><pubDate>Wed, 20 Apr 2022 15:41:29 +0800</pubDate><guid>https://zfunnily.github.io/2022/04/shaderfunc/</guid><description>数学函数 cg/hlsl函数 功能描述 dot(A,B) 点积, 点积结果为标量，主要用于求向量的夹角或b向量在a向量上的投影 cross(A,B) 叉积, 叉积结果为向量，结果与这两个向量组成的平面垂直。主要用于3D图形学 mul(M, N) 矩阵M和矩阵N的积 mul(M,</description></item><item><title>UnityCG.cginc中常用函数</title><link>https://zfunnily.github.io/2022/04/cginc/</link><pubDate>Wed, 20 Apr 2022 15:35:49 +0800</pubDate><guid>https://zfunnily.github.io/2022/04/cginc/</guid><description>摄像机方向 WorldSpaceViewDir 输入一个模型空间中的顶点坐标 -&amp;gt; 输出（世界空间）从这个点到摄像机的观察方向； WorldSpaceViewDir // 内部实现也是用UnityWorldSpaceViewDir // Computes world space view direction, from object space position // *Legacy* Please use UnityWorldSpaceViewDir instead inline float3 WorldSpaceViewDir( in float4 localPos ) { float3 worldPos</description></item><item><title>UnityCG.cginc中常用函数</title><link>https://zfunnily.github.io/2022/04/cginc/</link><pubDate>Wed, 20 Apr 2022 15:35:49 +0800</pubDate><guid>https://zfunnily.github.io/2022/04/cginc/</guid><description>摄像机方向 WorldSpaceViewDir 输入一个模型空间中的顶点坐标 -&amp;gt; 输出（世界空间）从这个点到摄像机的观察方向； WorldSpaceViewDir // 内部实现也是用UnityWorldSpaceViewDir // Computes world space view direction, from object space position // *Legacy* Please use UnityWorldSpaceViewDir instead inline float3 WorldSpaceViewDir( in float4 localPos ) { float3 worldPos</description></item><item><title>《Unity Shader入门精要》第四章笔记 | 学习Shader所需的数学基础</title><link>https://zfunnily.github.io/2022/04/shadermathematic/</link><pubDate>Sun, 10 Apr 2022 15:42:33 +0800</pubDate><guid>https://zfunnily.github.io/2022/04/shadermathematic/</guid><description>概述 在学习Shader的过程中，我们最常使用的就是矢量和矩阵（即数学的分支之一——线性代数）。 笛卡儿坐标系 我们使用数学绝大部分都是为了计算位置、距离和角度等变量。而这些计算大部分都是在笛卡儿坐标系 （C</description></item><item><title>《Unity Shader入门精要》第四章笔记 | 学习Shader所需的数学基础</title><link>https://zfunnily.github.io/2022/04/shadermathematic/</link><pubDate>Sun, 10 Apr 2022 15:42:33 +0800</pubDate><guid>https://zfunnily.github.io/2022/04/shadermathematic/</guid><description>概述 在学习Shader的过程中，我们最常使用的就是矢量和矩阵（即数学的分支之一——线性代数）。 笛卡儿坐标系 我们使用数学绝大部分都是为了计算位置、距离和角度等变量。而这些计算大部分都是在笛卡儿坐标系 （C</description></item><item><title>《Unity Shader入门精要》第三章笔记| UnityShader基础</title><link>https://zfunnily.github.io/2022/04/shaderbase/</link><pubDate>Sun, 10 Apr 2022 14:51:19 +0800</pubDate><guid>https://zfunnily.github.io/2022/04/shaderbase/</guid><description>材质 在Unity中我们需要配合使用材质 （Material） 和Unity Shader才能达到需要的效果。一个最常见的流程是 创建一个材质；活着导入一个材质 创建一个Unity Shader，并把它赋给上一步中</description></item><item><title>《Unity Shader入门精要》第三章笔记| UnityShader基础</title><link>https://zfunnily.github.io/2022/04/shaderbase/</link><pubDate>Sun, 10 Apr 2022 14:51:19 +0800</pubDate><guid>https://zfunnily.github.io/2022/04/shaderbase/</guid><description>材质 在Unity中我们需要配合使用材质 （Material） 和Unity Shader才能达到需要的效果。一个最常见的流程是 创建一个材质；活着导入一个材质 创建一个Unity Shader，并把它赋给上一步中</description></item><item><title>《Unity Shader入门精要》第二章笔记 | 渲染流水线</title><link>https://zfunnily.github.io/2022/04/shaderrenderpipline/</link><pubDate>Sat, 09 Apr 2022 11:55:55 +0800</pubDate><guid>https://zfunnily.github.io/2022/04/shaderrenderpipline/</guid><description>渲染流水线 Render-Time Rendering, Third Edition》一书中将一个渲染流程分成3个阶段：应用阶段（Application Stage） 、几何阶段（Geometry Stage） 、光栅化阶段（Rasterizer Stage） 。 应</description></item><item><title>《Unity Shader入门精要》第二章笔记 | 渲染流水线</title><link>https://zfunnily.github.io/2022/04/shaderrenderpipline/</link><pubDate>Sat, 09 Apr 2022 11:55:55 +0800</pubDate><guid>https://zfunnily.github.io/2022/04/shaderrenderpipline/</guid><description>渲染流水线 Render-Time Rendering, Third Edition》一书中将一个渲染流程分成3个阶段：应用阶段（Application Stage） 、几何阶段（Geometry Stage） 、光栅化阶段（Rasterizer Stage） 。 应</description></item><item><title>shader初尝试 ｜ 给石头覆盖一层雪景(Hello World)</title><link>https://zfunnily.github.io/2022/04/shaderhelloworld/</link><pubDate>Sat, 09 Apr 2022 10:34:56 +0800</pubDate><guid>https://zfunnily.github.io/2022/04/shaderhelloworld/</guid><description>给石头覆盖一层雪景 资源准备 石头模型 Unity2021.2.3f1c1 Mac &amp;amp; Windows 在Unity中创建一个项目，导入石头模型，下面就开始利用shader给石头做一个雪景覆盖. 实现效果 未覆盖雪景的样子 覆盖了雪景的样子 开始代码 我在代码中标注了1，</description></item><item><title>shader初尝试 ｜ 给石头覆盖一层雪景(Hello World)</title><link>https://zfunnily.github.io/2022/04/shaderhelloworld/</link><pubDate>Sat, 09 Apr 2022 10:34:56 +0800</pubDate><guid>https://zfunnily.github.io/2022/04/shaderhelloworld/</guid><description>给石头覆盖一层雪景 资源准备 石头模型 Unity2021.2.3f1c1 Mac &amp;amp; Windows 在Unity中创建一个项目，导入石头模型，下面就开始利用shader给石头做一个雪景覆盖. 实现效果 未覆盖雪景的样子 覆盖了雪景的样子 开始代码 我在代码中标注了1，</description></item><item><title>UnityShader基本概念</title><link>https://zfunnily.github.io/2022/04/shader01/</link><pubDate>Wed, 06 Apr 2022 11:54:02 +0800</pubDate><guid>https://zfunnily.github.io/2022/04/shader01/</guid><description>何为shader shader中文翻译为着色器，其实是一种用来渲染图形的技术，我们可以通过shader编程，来自定义显卡渲染画面的算法，显示我们所期望的结果。 shader种类 顶点着色器: 处理每个顶点，将</description></item><item><title>UnityShader基本概念</title><link>https://zfunnily.github.io/2022/04/shader01/</link><pubDate>Wed, 06 Apr 2022 11:54:02 +0800</pubDate><guid>https://zfunnily.github.io/2022/04/shader01/</guid><description>何为shader shader中文翻译为着色器，其实是一种用来渲染图形的技术，我们可以通过shader编程，来自定义显卡渲染画面的算法，显示我们所期望的结果。 shader种类 顶点着色器: 处理每个顶点，将</description></item><item><title>Graphics</title><link>https://zfunnily.github.io/2022/04/graphics/</link><pubDate>Mon, 04 Apr 2022 21:48:09 +0800</pubDate><guid>https://zfunnily.github.io/2022/04/graphics/</guid><description>Last Lecture What is Computer Graphics? Why study Computer Graphics? Course Topics Course Logistics Graphics&amp;rsquo;s Dependencies Basic mathematics Liner algebra, calculus, statistics. Basic physics Optics, Mechanics Misc Signal processing Numerical analysis 线性代数 Dot(scalar) Product Cross (vector) Product 向量之间的乘积不符合交换定律。 Cross product: Properties 右手螺旋定则 Cross product: Cartesian Formula Cross product in Graphics 判断左右 判断内外 判断向量b在向量a的左边 右手螺旋法则 向量</description></item><item><title>Graphics</title><link>https://zfunnily.github.io/2022/04/graphics/</link><pubDate>Mon, 04 Apr 2022 21:48:09 +0800</pubDate><guid>https://zfunnily.github.io/2022/04/graphics/</guid><description>Last Lecture What is Computer Graphics? Why study Computer Graphics? Course Topics Course Logistics Graphics&amp;rsquo;s Dependencies Basic mathematics Liner algebra, calculus, statistics. Basic physics Optics, Mechanics Misc Signal processing Numerical analysis 线性代数 Dot(scalar) Product Cross (vector) Product 向量之间的乘积不符合交换定律。 Cross product: Properties 右手螺旋定则 Cross product: Cartesian Formula Cross product in Graphics 判断左右 判断内外 判断向量b在向量a的左边 右手螺旋法则 向量</description></item><item><title>抽卡逻辑自述</title><link>https://zfunnily.github.io/2022/03/afk/</link><pubDate>Wed, 30 Mar 2022 10:50:11 +0800</pubDate><guid>https://zfunnily.github.io/2022/03/afk/</guid><description>抽卡逻辑自述 参考《剑与远征》 卡牌颜色以及合成 颜色 合成 绿色 可分解，得到粉尘和银瓜子, 最基础的卡 蓝 蓝+ 同样的三张蓝色可合成一张蓝+ 紫 同种族的三张蓝+可以合成一张紫(可以选择合成其中蓝+的某个紫色) 紫+ 同英</description></item><item><title>抽卡逻辑自述</title><link>https://zfunnily.github.io/2022/03/afk/</link><pubDate>Wed, 30 Mar 2022 10:50:11 +0800</pubDate><guid>https://zfunnily.github.io/2022/03/afk/</guid><description>抽卡逻辑自述 参考《剑与远征》 卡牌颜色以及合成 颜色 合成 绿色 可分解，得到粉尘和银瓜子, 最基础的卡 蓝 蓝+ 同样的三张蓝色可合成一张蓝+ 紫 同种族的三张蓝+可以合成一张紫(可以选择合成其中蓝+的某个紫色) 紫+ 同英</description></item><item><title>层级时间轮 ｜ skynet 定时器</title><link>https://zfunnily.github.io/2022/03/timerskynet/</link><pubDate>Sun, 27 Mar 2022 12:39:12 +0800</pubDate><guid>https://zfunnily.github.io/2022/03/timerskynet/</guid><description>skynet定时器 要解析一个程序代码，先了解数据结构，这是基础，再看函数。 拿skynet定时器举例子。 数据结构 //定时器事件 用于抛出定时器事件到消息队列里。理解这个数据结构需要先了解skynet的框架</description></item><item><title>层级时间轮 ｜ skynet 定时器</title><link>https://zfunnily.github.io/2022/03/timerskynet/</link><pubDate>Sun, 27 Mar 2022 12:39:12 +0800</pubDate><guid>https://zfunnily.github.io/2022/03/timerskynet/</guid><description>skynet定时器 要解析一个程序代码，先了解数据结构，这是基础，再看函数。 拿skynet定时器举例子。 数据结构 //定时器事件 用于抛出定时器事件到消息队列里。理解这个数据结构需要先了解skynet的框架</description></item><item><title>利用时间轮实现定时器</title><link>https://zfunnily.github.io/2022/03/timer/</link><pubDate>Thu, 10 Mar 2022 14:38:23 +0800</pubDate><guid>https://zfunnily.github.io/2022/03/timer/</guid><description>理解定时器 适用场景 定时任务(每隔1s钟打印一次数据) 超时控制(xx分钟没有动作就断开连接) 频率限制(最快只能每5s调用一次API) 定时器常用的数据结构有如下几种： 链表 双向有序链表 最小堆 时间轮 层级时间轮</description></item><item><title>利用时间轮实现定时器</title><link>https://zfunnily.github.io/2022/03/timer/</link><pubDate>Thu, 10 Mar 2022 14:38:23 +0800</pubDate><guid>https://zfunnily.github.io/2022/03/timer/</guid><description>理解定时器 适用场景 定时任务(每隔1s钟打印一次数据) 超时控制(xx分钟没有动作就断开连接) 频率限制(最快只能每5s调用一次API) 定时器常用的数据结构有如下几种： 链表 双向有序链表 最小堆 时间轮 层级时间轮</description></item><item><title>无聊 &amp; 痛苦</title><link>https://zfunnily.github.io/thinking/2022/03/shuowang/</link><pubDate>Wed, 09 Mar 2022 12:03:36 +0800</pubDate><guid>https://zfunnily.github.io/thinking/2022/03/shuowang/</guid><description>每天晚上我都睡得很晚，不是不困，而是不想睡，强迫自己不要睡。我似乎得了强迫症，我很忧郁。 因为我总觉得一天什么都没干就这么过去了，实在不甘心！于是我就尽量延长这一天的时间。我真是个有志气的人，我很欣慰。</description></item><item><title>爬楼有感</title><link>https://zfunnily.github.io/thinking/2022/03/think01/</link><pubDate>Tue, 08 Mar 2022 21:54:25 +0800</pubDate><guid>https://zfunnily.github.io/thinking/2022/03/think01/</guid><description>28楼 今天放弃了常用乘电梯回家，决定爬楼。28楼真高呀。我还记得上次是和阿芳一起爬的。 那会爬的很轻松，还有功夫教她 &amp;ldquo;核心收紧，抬腿的时候膝盖沿着脚尖方向歪曲&amp;rdquo;。 一个人爬楼让我又</description></item><item><title>老纪</title><link>https://zfunnily.github.io/thinking/2022/03/weekly01/</link><pubDate>Mon, 07 Mar 2022 21:36:05 +0800</pubDate><guid>https://zfunnily.github.io/thinking/2022/03/weekly01/</guid><description>周末看了《铁齿铜牙纪晓岚》，对这样经典的剧，百看不厌。 这个剧我来来回回看了很多遍了，剧集内容越来越熟悉，但是对里面的人物却又有不一样的理解。 以前觉得纪晓岚清官，好人。和珅贪官，坏人。 现在看到了那一集和</description></item><item><title>2021焦虑总结</title><link>https://zfunnily.github.io/thinking/2022/03/summarize/</link><pubDate>Fri, 04 Mar 2022 11:03:20 +0800</pubDate><guid>https://zfunnily.github.io/thinking/2022/03/summarize/</guid><description>2021 已经22年3月份了，这份总结才出来，我这是拖延症晚期了。 去年一年总的来说不错, 但还是有些计划性的东西没做 我结婚了，24岁 我转行做游戏了 买车了 读了3本书 健身 无 时间太快，从我19年开始记笔记开始，已经过</description></item><item><title>利用云服务器搭建个人博客</title><link>https://zfunnily.github.io/2022/03/blog/</link><pubDate>Thu, 03 Mar 2022 12:04:58 +0800</pubDate><guid>https://zfunnily.github.io/2022/03/blog/</guid><description>vps选择 最近关注了一个vps推广网站。价格合适，于是买了一个128元/年的云服务器。既可以用来做代理，又可以搭建个人博客 配置是2G/1M/40G(运存/带宽/硬盘) 使用技术 nginx: 静态博客 v2ray: 代理 https + nginx freenome: 域</description></item><item><title>利用云服务器搭建个人博客</title><link>https://zfunnily.github.io/2022/03/blog/</link><pubDate>Thu, 03 Mar 2022 12:04:58 +0800</pubDate><guid>https://zfunnily.github.io/2022/03/blog/</guid><description>vps选择 最近关注了一个vps推广网站。价格合适，于是买了一个128元/年的云服务器。既可以用来做代理，又可以搭建个人博客 配置是2G/1M/40G(运存/带宽/硬盘) 使用技术 nginx: 静态博客 v2ray: 代理 https + nginx freenome: 域</description></item><item><title>Nginx | 给网站添加证书</title><link>https://zfunnily.github.io/2022/03/https/</link><pubDate>Thu, 03 Mar 2022 10:26:56 +0800</pubDate><guid>https://zfunnily.github.io/2022/03/https/</guid><description>Https 最近在购买的云服务器上把个人博客搭建起来了，实际上是hugo生成静态网页，nginx加载静态网页。现在只能通过http访问，缺少个https。 要搭建一个https的网站需要证书。之前在网上找的教程太</description></item><item><title>Nginx | 给网站添加证书</title><link>https://zfunnily.github.io/2022/03/https/</link><pubDate>Thu, 03 Mar 2022 10:26:56 +0800</pubDate><guid>https://zfunnily.github.io/2022/03/https/</guid><description>Https 最近在购买的云服务器上把个人博客搭建起来了，实际上是hugo生成静态网页，nginx加载静态网页。现在只能通过http访问，缺少个https。 要搭建一个https的网站需要证书。之前在网上找的教程太</description></item><item><title>Golang | http注解路由</title><link>https://zfunnily.github.io/2022/03/http/</link><pubDate>Wed, 02 Mar 2022 14:51:22 +0800</pubDate><guid>https://zfunnily.github.io/2022/03/http/</guid><description>Http服务器 Golang有一个很强大的官方http库了，使用上很方便。也有一些很强大的三方http框架， 比如gin，beego等等。 自以为，框架在提供便利，提升开发效率的同时，也限制了我们的想象力。</description></item><item><title>Golang | http注解路由</title><link>https://zfunnily.github.io/2022/03/http/</link><pubDate>Wed, 02 Mar 2022 14:51:22 +0800</pubDate><guid>https://zfunnily.github.io/2022/03/http/</guid><description>Http服务器 Golang有一个很强大的官方http库了，使用上很方便。也有一些很强大的三方http框架， 比如gin，beego等等。 自以为，框架在提供便利，提升开发效率的同时，也限制了我们的想象力。</description></item><item><title>Goang | Plugin插件热更</title><link>https://zfunnily.github.io/2022/03/reload/</link><pubDate>Tue, 01 Mar 2022 11:33:22 +0800</pubDate><guid>https://zfunnily.github.io/2022/03/reload/</guid><description>热更新 动态脚本更新 (php) 短链接无状态服务器热更 (http) 长连接有状态，数据跟逻辑分离 golang Plugin热更 (.so 动态库更新) &amp;mdash;-逻辑热更 长连接有状态,在运维层面, 利用容器部署热更(docker, k8s) 服务不接受新</description></item><item><title>Goang | Plugin插件热更</title><link>https://zfunnily.github.io/2022/03/reload/</link><pubDate>Tue, 01 Mar 2022 11:33:22 +0800</pubDate><guid>https://zfunnily.github.io/2022/03/reload/</guid><description>热更新 动态脚本更新 (php) 短链接无状态服务器热更 (http) 长连接有状态，数据跟逻辑分离 golang Plugin热更 (.so 动态库更新) &amp;mdash;-逻辑热更 长连接有状态,在运维层面, 利用容器部署热更(docker, k8s) 服务不接受新</description></item><item><title>Grpc | Token认证和自定义认证</title><link>https://zfunnily.github.io/2022/02/jwt/</link><pubDate>Tue, 22 Feb 2022 15:39:30 +0800</pubDate><guid>https://zfunnily.github.io/2022/02/jwt/</guid><description>概述 现在有个需求，需要在grpc的拦截器中，通过token进行身份认证。如果认证不通过则返回错误; 认证通过，则放行; TLS是用作加密通讯通道的，与该需求无关。 Token认证 具体流程 客户端通过账号密码登</description></item><item><title>Grpc | Token认证和自定义认证</title><link>https://zfunnily.github.io/2022/02/jwt/</link><pubDate>Tue, 22 Feb 2022 15:39:30 +0800</pubDate><guid>https://zfunnily.github.io/2022/02/jwt/</guid><description>概述 现在有个需求，需要在grpc的拦截器中，通过token进行身份认证。如果认证不通过则返回错误; 认证通过，则放行; TLS是用作加密通讯通道的，与该需求无关。 Token认证 具体流程 客户端通过账号密码登</description></item><item><title>Grpc ｜ 通过SSL/TLS建立安全连接</title><link>https://zfunnily.github.io/2022/02/san/</link><pubDate>Tue, 22 Feb 2022 14:22:41 +0800</pubDate><guid>https://zfunnily.github.io/2022/02/san/</guid><description>使用golang的grpc库作为例子 grpc使用TLS建立安全连接需要有SAN证书， go 1.15 版本开始废弃 CommonName。 什么是SAN证书 SAN(Subject Alternative Name) 是 SSL 标准 x509 中定义的一个扩展。使用了 SAN 字段的 SSL 证书，可以扩</description></item><item><title>Grpc ｜ 通过SSL/TLS建立安全连接</title><link>https://zfunnily.github.io/2022/02/san/</link><pubDate>Tue, 22 Feb 2022 14:22:41 +0800</pubDate><guid>https://zfunnily.github.io/2022/02/san/</guid><description>使用golang的grpc库作为例子 grpc使用TLS建立安全连接需要有SAN证书， go 1.15 版本开始废弃 CommonName。 什么是SAN证书 SAN(Subject Alternative Name) 是 SSL 标准 x509 中定义的一个扩展。使用了 SAN 字段的 SSL 证书，可以扩</description></item><item><title>转载｜江雪：长安十日</title><link>https://zfunnily.github.io/thinking/2022/01/jx/</link><pubDate>Thu, 06 Jan 2022 11:32:56 +0800</pubDate><guid>https://zfunnily.github.io/thinking/2022/01/jx/</guid><description>转载 https://chinadigitaltimes.net/chinese/675386.html(需科学上网) 01/03/2022 文：江雪 小区里的大喇叭又响了起来，一遍遍重复着，喊人们下楼做核酸。队排了很长。测核</description></item><item><title>Blog | 代码显示/隐藏</title><link>https://zfunnily.github.io/2021/12/shortcodes/</link><pubDate>Wed, 29 Dec 2021 13:50:28 +0800</pubDate><guid>https://zfunnily.github.io/2021/12/shortcodes/</guid><description>缘由 最近在写技术博客时，引入的代码太多，影响观感。 在尽力减少代码量，还是有些不可或缺的代码，代码量很惊人，已经占满整个屏幕. 因为个人博客是使用hugo生成的静态博客，我刚开始想的使用原生的js和css</description></item><item><title>Nginx的一些配置</title><link>https://zfunnily.github.io/2021/12/nginx/</link><pubDate>Tue, 28 Dec 2021 16:04:10 +0800</pubDate><guid>https://zfunnily.github.io/2021/12/nginx/</guid><description>静态网站 应用场景 文件服务 静态网站 &amp;hellip; 静态网站的配置 配置如下: nginx.conf worker_processes 1; pid nginx.pid; events { worker_connections 1024; multi_accept on; } http { default_type application/octet-stream; sendfile on; keepalive_timeout 100; server { listen 80; charset utf-8,gbk; server_name localhost; location /{ root /opt/; autoindex on; autoindex_localtime on; } index index.html; # 显示首页 #静态文件访问 location ~* ^.+\.(jpg|jpeg|gif|png|ico|css|js|pdf|txt) { root /opt; } } } root: 表示网站根目录 autoindex: on 显</description></item><item><title>摘抄 ｜ 我的精神家园</title><link>https://zfunnily.github.io/thinking/2021/12/pervert/</link><pubDate>Mon, 27 Dec 2021 21:44:21 +0800</pubDate><guid>https://zfunnily.github.io/thinking/2021/12/pervert/</guid><description>另一种文化 假如有个pervert站出来说：我就是个pervert，那他就不是个pervert。 当且仅当一个人声称：我就不知道pervert是什么时，他才是个pervert。 假如我说，我们这里有种per</description></item><item><title>A*算法 | Lua版本</title><link>https://zfunnily.github.io/2021/12/astar/</link><pubDate>Thu, 23 Dec 2021 16:37:44 +0800</pubDate><guid>https://zfunnily.github.io/2021/12/astar/</guid><description>A*算法思路 寻路步骤 从起点A开始, 把它作为待处理的方格存入一个&amp;quot;开启列表&amp;quot;, 开启列表就是一个等待检查方格的列表. 寻找起点A周围可以到达的方格, 将它们放入&amp;quot;开启列表&amp;quo</description></item><item><title>Blog | 音乐播放器</title><link>https://zfunnily.github.io/2021/12/music/</link><pubDate>Tue, 21 Dec 2021 16:55:23 +0800</pubDate><guid>https://zfunnily.github.io/2021/12/music/</guid><description>概述 今天给我的个人博客加了个暗模式，这样可以在晚上阅读博客的时候不伤害眼睛。突然想到如果在阅读博客的时候可以听听音乐就更好了。 于是在github上找到了一个开源的项目MetingJS，看最后一次com</description></item><item><title>Blog | 网站暗模式</title><link>https://zfunnily.github.io/2021/12/dark/</link><pubDate>Tue, 21 Dec 2021 11:05:00 +0800</pubDate><guid>https://zfunnily.github.io/2021/12/dark/</guid><description>Wordpress 如果你的网站是wordpress，则可以参考以Darkmode.js为基础的插件: blackout-darkmode-widget darkmode Nuxt.js 如果你正在使用Nuxt.js,则可以使用下面的模块 nuxtjs-darkmode-js-module 快速使用 使用Darkmode.js给网站快速部署上暗/浅色</description></item><item><title>Openresty三 | 上传文件</title><link>https://zfunnily.github.io/2021/12/openresty-upload/</link><pubDate>Wed, 08 Dec 2021 16:42:17 +0800</pubDate><guid>https://zfunnily.github.io/2021/12/openresty-upload/</guid><description>上传文件接口 nginx.conf 的server 增加一个location: location /upload { resolver 8.8.8.8 ipv6=off; content_by_lua_file lua/upload.lua; } upload.lua lua -- upload.lua --========================================== -- 文件上传 --========================================== local chunk_size = 4096 local form, err = upload:new(chunk_size) if not form then ngx.log(ngx.ERR, &amp;#34;failed to new upload: &amp;#34;, err) ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR) end form:set_timeout(1000) -- 文件保存的根路径 local saveRootPath = &amp;#34;./download/&amp;#34; -- 保存的文件对象 local fileToSave --文件是否成</description></item><item><title>Webrtc二 | 共享桌面</title><link>https://zfunnily.github.io/2021/11/webrtcdesk/</link><pubDate>Mon, 15 Nov 2021 11:23:24 +0800</pubDate><guid>https://zfunnily.github.io/2021/11/webrtcdesk/</guid><description>环境 Ubuntu18.04 webrtc M84 改造peerconnection例子，用来实现桌面共享 改造类CapturerTrackSource 增加桌面的数据源类RcrtcDesktopCapturerTrackSource 继承webr</description></item><item><title>Webrtc一 | peerconnection</title><link>https://zfunnily.github.io/2021/11/webrtcpeerconnection/</link><pubDate>Sun, 14 Nov 2021 16:20:31 +0800</pubDate><guid>https://zfunnily.github.io/2021/11/webrtcpeerconnection/</guid><description>环境 Ubuntu18.04 webrtc M84 国内镜像：https://webrtc.org.cn/mirror/ webrtc交互过程 通过peerconnection的例子来分析webrtc的交互流程 peer_connection 解析 为了便于管理，如编码，回显等，</description></item><item><title>Go-libp2p四 | 穿透NAT</title><link>https://zfunnily.github.io/2021/11/gop2pfour/</link><pubDate>Sun, 07 Nov 2021 15:49:46 +0800</pubDate><guid>https://zfunnily.github.io/2021/11/gop2pfour/</guid><description>本文目的 上文Go-libp2p三 | relay例子已经分析过relay例子，并解释了两个节点如果通过中继服务进行通信。本文改造relay例子 并让这个服务做如下两件事： 交换两个节点的在交换机上的信息，帮助</description></item><item><title>Blog | 随机名人名言</title><link>https://zfunnily.github.io/2021/11/randomquotes/</link><pubDate>Fri, 05 Nov 2021 15:50:16 +0800</pubDate><guid>https://zfunnily.github.io/2021/11/randomquotes/</guid><description>本文目的 我的个人博客已经搭建好了，使用的hugo+飞雪的主题。我看到有些博客上有些随机的名人名言，但是这个主题没有。遂自己写一个。 根据飞雪的主题自定义 飞雪主题的github: https://github.com/flysnow-org/maupassant-hugo 复制主题里的文件them</description></item><item><title>Go-libp2p三 | relay例子</title><link>https://zfunnily.github.io/2021/10/gop2pthree/</link><pubDate>Sun, 31 Oct 2021 10:13:40 +0800</pubDate><guid>https://zfunnily.github.io/2021/10/gop2pthree/</guid><description>我想做什么 chat和echo两个例子，说明了两个节点之间的通信需要两节点在同一个局域网内，或者有一个节点有公网。 如果我两个节点分别在两个NAT下面, 都在各自的局域网内，则需要有一个中继服务，这个服务做</description></item><item><title>Go-libp2p二 | echo例子</title><link>https://zfunnily.github.io/2021/10/gop2ptwo/</link><pubDate>Fri, 29 Oct 2021 11:15:42 +0800</pubDate><guid>https://zfunnily.github.io/2021/10/gop2ptwo/</guid><description>go-libp2p的echo例子分析 进入目录go-libp2p/examples/echo/, 编译 go build 先看README.md， 可以了解到使用echo的方式: 终端B $ ./echo -l 3001 2021/10/28 11:25:33 I am /ip4/127.0.0.1/tcp/3001/p2p/QmTu8sxDi3fSjz9ZMvkAj3qA9YAoGskroEnyLz2ZvfTBhX 2021/10/28 11:25:33 listening for connections 2021/10/28 11:25:33 Now run &amp;#34;./echo</description></item><item><title>Go-libp2p一 | chat例子</title><link>https://zfunnily.github.io/2021/10/gop2pone/</link><pubDate>Thu, 28 Oct 2021 14:40:02 +0800</pubDate><guid>https://zfunnily.github.io/2021/10/gop2pone/</guid><description>代码下载 git clone https://github.com/libp2p/go-libp2p.git chat实例分析 进入目录go-libp2p/examples/chat/, 编译 go build 先看README.md， 可以了解到使用chat的方式 在节点 B $ ./chat -sp 3001 2021/10/28 11:01:25 Run &amp;#39;./chat -d /ip4/127.0.0.1/tcp/3001/p2p/QmXgEXt4CiqmVmDhPPQnyVkoj3Bsx3Nggq57PPsk5tLNTs&amp;#39; on another console. 2021/10/28 11:01:25 You can replace 127.0.0.1 with public IP</description></item><item><title>Blog | 新的开始</title><link>https://zfunnily.github.io/2021/10/blogmigration/</link><pubDate>Fri, 22 Oct 2021 19:01:20 +0800</pubDate><guid>https://zfunnily.github.io/2021/10/blogmigration/</guid><description>迁移博客 我是从18年开始写一些东西，先写在看云笔记上，后面东西越来越多。写出来的东西比较零散. 20年下半年入职新公司，开始在csdn上写博客，今年我准备尝试使用个人博客，hugo和gitPage结合部</description></item><item><title>Skynet源码赏析四 | 消息调度</title><link>https://zfunnily.github.io/2021/10/four/</link><pubDate>Thu, 21 Oct 2021 10:06:39 +0800</pubDate><guid>https://zfunnily.github.io/2021/10/four/</guid><description>服务间消息流转 发送消息 数据结构message_queue *q是次级消息队列，每个服务都有与之绑定的唯一一个次级消息队列。当我们在lua层，调用skynet.send(...), 或者调用skynet.c</description></item><item><title>Skynet源码赏析三 | 服务启动</title><link>https://zfunnily.github.io/2021/10/skynetthree/</link><pubDate>Wed, 20 Oct 2021 11:26:07 +0800</pubDate><guid>https://zfunnily.github.io/2021/10/skynetthree/</guid><description>skynet启动一个C服务 查看怎么启动C服务的最好的办法是打断点，看源码。 启动logger日志服务 我拿日志服务来举例子，怎么启动日志服务的呢？ 传参数name = &amp;quot;logger&amp;quot;, param = null， struct skynet_context *ctx = skynet_context_new(config-&amp;gt;logservice, config-&amp;gt;logger);; 从module</description></item><item><title>Skynet源码赏析二 | 基础数据结构</title><link>https://zfunnily.github.io/2021/10/skynettwo/</link><pubDate>Tue, 19 Oct 2021 18:47:45 +0800</pubDate><guid>https://zfunnily.github.io/2021/10/skynettwo/</guid><description>module管理模块 我们所写的C服务编译成.so文件后放在cpath变量路径下，程序会加载路径cpath = root..&amp;quot;cservice/?.so&amp;quot;下的.so文件，通过static</description></item><item><title>Skynet源码赏析一 | 启动初始化的过程</title><link>https://zfunnily.github.io/2021/10/skynetone/</link><pubDate>Tue, 19 Oct 2021 17:28:45 +0800</pubDate><guid>https://zfunnily.github.io/2021/10/skynetone/</guid><description>入口文件 skynet_main.c 加载配置 struct skynet_config config; config.thread = optint(&amp;#34;thread&amp;#34;,8); config.module_path = optstring(&amp;#34;cpath&amp;#34;,&amp;#34;./cservice/?.so&amp;#34;); config.harbor = optint(&amp;#34;harbor&amp;#34;, 1); config.bootstrap = optstring(&amp;#34;bootstrap&amp;#34;,&amp;#34;snlua bootstrap&amp;#34;); config.daemon = optstring(&amp;#34;daemon&amp;#34;, NULL); config.logger = optstring(&amp;#34;logger&amp;#34;, NULL); config.logservice = optstring(&amp;#34;logservice&amp;#34;, &amp;#34;logger&amp;#34;); config.profile = optboolean(&amp;#34;profile&amp;#34;, 1); 从上述代码可以看到，配置都已经加载到变量struct skynet_config config;中了。 初始化 初始化skynet_context管</description></item><item><title>Golang | 调用带有后台进程shell脚本可能会被挂起</title><link>https://zfunnily.github.io/2021/10/shell/</link><pubDate>Wed, 13 Oct 2021 17:15:45 +0800</pubDate><guid>https://zfunnily.github.io/2021/10/shell/</guid><description>起因 今天用Golang写一个调用外部shell脚本的程序，使用 exec.Command方法，这段脚本代码中包含了一个后台任务语句。 结果发生了一个问题：cmd.Output 始终不会返回，一直挂起。导致我</description></item><item><title>FPS游戏 | 实现移动功能</title><link>https://zfunnily.github.io/2021/09/move/</link><pubDate>Sun, 12 Sep 2021 20:43:34 +0800</pubDate><guid>https://zfunnily.github.io/2021/09/move/</guid><description>三种实现FPS Controller的区别 Transform Translate 允许移动物理，但无物理碰撞 Rigid body + Capsule Collider 符合物理学 不会鬼穿墙 无法滞空运动 可与Physics Object 交互 Charactor Controller 不会鬼穿墙 提供的API相对多 无法与Physic objects</description></item><item><title>免费Music</title><link>https://zfunnily.github.io/2021/09/music/</link><pubDate>Wed, 08 Sep 2021 14:47:14 +0800</pubDate><guid>https://zfunnily.github.io/2021/09/music/</guid><description>介绍一个可以免费听音乐的方法 环境 docker mac 安装 $ docker run -d -p 264:264 -p 9000:9000 -v $dir_name:/var/www/html/cache --name music oldiy/music-player-docker $dir_name 是 你自己宿主机的目录。可以自定义 访问：127.0.0.1:264 就可以放心使用， 同事推荐的，贼好用。</description></item><item><title>Unity3D | Transform类</title><link>https://zfunnily.github.io/2021/09/transform/</link><pubDate>Tue, 07 Sep 2021 15:55:59 +0800</pubDate><guid>https://zfunnily.github.io/2021/09/transform/</guid><description>Transform类 在unity中，把transform类理解为，transform类是在每个对象生成时自动附加的一个类。在Unity的视图中，点击Hierarchy中的对象，就可以在Inspecto</description></item><item><title>Vim | 切换模式/输入法</title><link>https://zfunnily.github.io/2021/09/vimchange/</link><pubDate>Tue, 07 Sep 2021 10:46:58 +0800</pubDate><guid>https://zfunnily.github.io/2021/09/vimchange/</guid><description>vim 在退出输入模式的时候切换为原来的输入法 在敲代码的时候使用我们使用的英文，当遇到问题，我们需要搜索引擎的时候需要中文输入法，这个时候，自动切换输入法可以帮助我们节省手动切换输入法的时间。 跟编辑器结合，</description></item><item><title>Linux | Screen</title><link>https://zfunnily.github.io/2021/09/screen/</link><pubDate>Tue, 07 Sep 2021 10:02:16 +0800</pubDate><guid>https://zfunnily.github.io/2021/09/screen/</guid><description>screen命令 screen 是一个非常有用的命令。应用场景： 单个 SSH 会话中使用多个 shell 窗口（会话）的能力 服务器开发，一个单独运行进程的窗口。可以避免单独再开一个窗口。 &amp;hellip; screen使用 创建一个窗口 $ screen -S name 执行自己需</description></item><item><title>Centos7.2 | gcc4.8升级为4.9</title><link>https://zfunnily.github.io/2021/09/upgradegcc/</link><pubDate>Wed, 01 Sep 2021 18:13:41 +0800</pubDate><guid>https://zfunnily.github.io/2021/09/upgradegcc/</guid><description>环境 CentOS 7.2.1511 Docker 我是用 docker 拉取镜像 CentOS 7.2.1511, 利用容器来作为我的开发环境。有条件的也可以用虚拟机或者实体机器。原理都一样。 $ docker $ yum update &amp;amp;&amp;amp; yum install gcc gcc-c++ make zlib-devel.x86_6 下载依赖包 升级 gcc， 下载安装包下载依赖。 $ wget http://ftp.gnu.org/gnu/gcc/gcc-4.9.3/gcc-4.9.3.tar.bz2 $ tar xfv gcc-4.9.3.tar.bz2 &amp;amp;&amp;amp; cd gcc-4.9.3 $ ./contrib/download_prerequisites 如果</description></item><item><title>Shell | Except 使用</title><link>https://zfunnily.github.io/2021/08/except/</link><pubDate>Mon, 30 Aug 2021 17:13:33 +0800</pubDate><guid>https://zfunnily.github.io/2021/08/except/</guid><description>Except 参数 spawn 交互程序开始后面跟命令或者指定程序 expect 获取匹配信息匹配成功则执行expect后面的程序动作 send exp_send 用于发送指定的字符串信息 exp_continue 在expect中多次匹配就需要用到 send_user 用来打印输出 相当于shell中的ech</description></item><item><title>Unity3D | UGUI</title><link>https://zfunnily.github.io/2021/08/ugui/</link><pubDate>Fri, 20 Aug 2021 14:15:41 +0800</pubDate><guid>https://zfunnily.github.io/2021/08/ugui/</guid><description>Text Text的属性 在 Unity 的 Hierarchy 面板上右键–&amp;gt;UI–&amp;gt;Text, 在 Inspector 面板上查看属性 属性 功能 Text 需要显示的文本 Font 显示文本的字体 如：微软雅黑，宋体等 Font Style 显示文本的样式，有普通，粗体，斜体，粗体和斜体四种</description></item><item><title>Golang | redis实现分布式锁</title><link>https://zfunnily.github.io/2021/06/distribute/</link><pubDate>Thu, 03 Jun 2021 16:12:21 +0000</pubDate><guid>https://zfunnily.github.io/2021/06/distribute/</guid><description>概述 网上有很多Golang操作redis的例子，我使用github.com/gomodule/redigo/redis包写一个关于redis分布式锁的问题。 redis分布式锁 锁需要的几个组件 获取锁- 删</description></item><item><title>Golang | redis</title><link>https://zfunnily.github.io/2021/06/goredis/</link><pubDate>Thu, 03 Jun 2021 15:57:14 +0800</pubDate><guid>https://zfunnily.github.io/2021/06/goredis/</guid><description>概述 网上有很多golang操作redis的例子，我使用github.com/gomodule/redigo/redis包写一个关于redis分布式锁的问题。 redis分布式锁 锁需要的几个组件 获取锁 删除</description></item><item><title>Lua | next的使用</title><link>https://zfunnily.github.io/2021/05/lua_next/</link><pubDate>Mon, 10 May 2021 16:39:50 +0800</pubDate><guid>https://zfunnily.github.io/2021/05/lua_next/</guid><description>lua_next lua_next(L,index)：先把 表(lua栈 index所指的表), 的当前索引弹出，再把table 当前索引的值弹出，也就是先弹出 table的索引，再弹出table索引的值 举例： local t = { [&amp;#34;a&amp;#34;] = 1, [&amp;#34;b&amp;#34;]</description></item><item><title>Lua | API</title><link>https://zfunnily.github.io/2021/05/settopandpop/</link><pubDate>Mon, 10 May 2021 15:57:03 +0800</pubDate><guid>https://zfunnily.github.io/2021/05/settopandpop/</guid><description>lua_pop和lua_settop lua_settop 我们直接来看lua_settop，文档解释 /* 设置栈的高度，如果之前的栈顶比新设置的更高，那么高出来的元素会被丢弃，反之压入nil来补足大小 假设栈里有2个元素。 如果</description></item><item><title>Hugo</title><link>https://zfunnily.github.io/2021/04/hugo/</link><pubDate>Sat, 17 Apr 2021 00:00:00 +0000</pubDate><guid>https://zfunnily.github.io/2021/04/hugo/</guid><description>hugo 我用过的静态博客有hexo、jekyll和hugo，对比起来，hugo虽然没有hexo那样丰富的插件和主题，但是hugo生成文章的速度更快。我是一名go语言爱好者，而hugo是go语言开发的, jek</description></item><item><title>Golang | gomod拉取私有仓库</title><link>https://zfunnily.github.io/2021/03/gomod/</link><pubDate>Tue, 23 Mar 2021 16:10:02 +0000</pubDate><guid>https://zfunnily.github.io/2021/03/gomod/</guid><description>概述 在使用go mod的过程中，依赖的包往往是第三方库，当我们自定义一个包并且放在github.com私有仓库时候，按照原来的方法则会有如下问题。 get &amp;#34;gitlab.com/xxx/zz&amp;#34;: found meta tag get.metaImport{Prefix:&amp;#34;gitlab.com/xxx/zz&amp;#34;, VCS:&amp;#34;git&amp;#34;, RepoRoot:&amp;#34;https://gitlab.com/xxx/zz.git&amp;#34;} at //gitlab.com/xxx/zz?go-get=1 verifying gitlab.com/xxx/zz@v0.0.1: gitlab.com/xxx/zz@v0.0.1: reading https://sum.golang.org/lookup/gitlab.com/xxx/zz@v0.0.1: 410 Gone 这个错误是因为新版本g</description></item><item><title>八个基础排序</title><link>https://zfunnily.github.io/2021/03/sort/</link><pubDate>Tue, 23 Mar 2021 10:13:31 +0000</pubDate><guid>https://zfunnily.github.io/2021/03/sort/</guid><description>sort排序 std::sort( )函数是库函数提供的排序函数，必须包括头文件#include &amp;lt;algorithm&amp;gt;，它使用的排序方法是类似于快排的方法，时间复杂度为n*log2(n) Sort函数有三个参数：</description></item><item><title>《仙剑奇侠传》编译运行</title><link>https://zfunnily.github.io/2021/03/gamexian/</link><pubDate>Sun, 21 Mar 2021 10:44:58 +0000</pubDate><guid>https://zfunnily.github.io/2021/03/gamexian/</guid><description>概述 今天在github上找到了《仙剑奇侠传》的rpg单机游戏sdlpal，sdlpal 是一个开源项目，基于sdl把仙剑奇侠传重写了一遍。 下面是我的编译过程总结。 环境 win10- sdl1.2- sdlpal- vs2017- DirectX SDK10 下载sdlpal $ git clone https://github.com.cnpmjs.org/sdlpal/sdlpal.git</description></item><item><title>实现atoi和itoa函数</title><link>https://zfunnily.github.io/2021/03/atoianditoa/</link><pubDate>Wed, 17 Mar 2021 16:43:20 +0000</pubDate><guid>https://zfunnily.github.io/2021/03/atoianditoa/</guid><description>题目1： 把字符串转化为整数 有整数字符串，&amp;quot;13579&amp;quot;, 和 &amp;quot;246810&amp;quot;. 请写一个函数把这两个字符串转化为整数 步骤： 先判断正负 遍历字符串，转换字符为整数 //atoi.cc #include &amp;lt;stdio.h&amp;gt; int my_atoi(char *str) { bool bmin = false; int result = 0; //先判断正</description></item><item><title>协程解析二 | 云风的coroutine</title><link>https://zfunnily.github.io/2021/03/coroutinetwo/</link><pubDate>Wed, 10 Mar 2021 11:11:47 +0000</pubDate><guid>https://zfunnily.github.io/2021/03/coroutinetwo/</guid><description>概述 云风的coroutine是通过ucontext来控制程序运行时上下文的，我们来根据该库提供的几个接口，和一个demo来解释协程的运行原理。如果不了解ucontext的，建议先了解ucontxt 环境</description></item><item><title>协程解析一 | ucontext</title><link>https://zfunnily.github.io/2021/03/coroutineone/</link><pubDate>Tue, 09 Mar 2021 09:43:00 +0000</pubDate><guid>https://zfunnily.github.io/2021/03/coroutineone/</guid><description>概述 最近在研究协程的实现原理，看了云风的coroutine和腾讯的开源库libco后，原来要实现一个协程库也没那么难。我先来讲讲云风的coroutine库。他使用的是 uncontext来保存程序运行上</description></item><item><title>关于我</title><link>https://zfunnily.github.io/about/</link><pubDate>Sun, 28 Feb 2021 00:00:00 +0000</pubDate><guid>https://zfunnily.github.io/about/</guid><description>我是谁 我是一名游戏从业者, 目前在一家公司做游戏后端的工作。 地址 浙江杭州滨江区 Email 582132116@qq.com 技能 skynet框架+lua脚本 &amp;ndash; 游戏后端 C/C++ &amp;ndash; IM服务器 Golang &amp;ndash; 后端</description></item><item><title>Golang | 定时器</title><link>https://zfunnily.github.io/2021/02/timer/</link><pubDate>Thu, 25 Feb 2021 16:02:13 +0000</pubDate><guid>https://zfunnily.github.io/2021/02/timer/</guid><description>概述 golang有三种方式实现定时器： ticker timer select Ticker 通过 time.NewTicker(d)的方式实现定时器 d := time.Duration(time.Second * 2) t1 := time.NewTicker(d) defer t1.Stop() go func() { for { &amp;lt;- t1.C fmt.Println(&amp;#34;NewTicker...&amp;#34;) } }() Timer 通过 time.NewTimer(d)的方式实现定时器 t2 := time.NewTimer(d)</description></item><item><title>Lua | 解决百元买鸡的问题</title><link>https://zfunnily.github.io/2021/02/chicken/</link><pubDate>Wed, 24 Feb 2021 17:51:46 +0000</pubDate><guid>https://zfunnily.github.io/2021/02/chicken/</guid><description>问题 编写lua程序求解百鸡百钱问题。公鸡5元一只，母鸡3元一只，小鸡一元3只，问100元钱买100只鸡，可买公鸡、母鸡、小鸡各多少只？ 代码 ----------------------------------------------------------------------------- --公鸡5元一只，母鸡3元一只，小鸡一元3只，问100元钱买</description></item><item><title>Golang | JWT身份认证</title><link>https://zfunnily.github.io/2021/02/JWT/</link><pubDate>Wed, 24 Feb 2021 14:22:04 +0000</pubDate><guid>https://zfunnily.github.io/2021/02/JWT/</guid><description>概述 最近要在http接口上加一个token认证，但是接口很多，有没有一个省时省力的办法来解决。token的使用流程是： 用户使用帐号密码登陆到服务器1. 服务器验证登陆成功，根据帐号密码生成token。把</description></item><item><title>Lua | 调用C/C++的动态库</title><link>https://zfunnily.github.io/2021/02/dynamic/</link><pubDate>Sat, 20 Feb 2021 11:11:51 +0000</pubDate><guid>https://zfunnily.github.io/2021/02/dynamic/</guid><description>概述 最近在学习 云风的skynet库，想自定义一个模块，目标是使用lua调用C/C++所编写的库。 当我们需要在Lua里面调用c/c++函数时，所有的函数都必须满足以下函数签名： typedef int (*lua_CFunction) (lua_State *L); 换句话说，所有的</description></item><item><title>汇编 | C/C++调用汇编</title><link>https://zfunnily.github.io/2021/02/compilation/</link><pubDate>Mon, 01 Feb 2021 14:40:51 +0000</pubDate><guid>https://zfunnily.github.io/2021/02/compilation/</guid><description>概述 我使用AT&amp;amp;T的规范，在linux上完成 C和汇编的互相调用，并使用gcc编译成可执行文件。 目标：汇编函数提供输出。类似C语言的函数 void hello_world(char* value) { printf(value); } 提供给C语言调用： int main() { hello_world(&amp;#34;hello world!\n&amp;#34;); } 搭建AT&amp;amp</description></item><item><title>汇编 | AT&amp;T和Intel规范的区别</title><link>https://zfunnily.github.io/2021/01/attandintel/</link><pubDate>Sun, 31 Jan 2021 11:25:39 +0000</pubDate><guid>https://zfunnily.github.io/2021/01/attandintel/</guid><description>概述 常见的指令集以及汇编语言规范： x86(IA-32)、x86-64指令集(常见于PC端)，对应有2家公司发布的不同汇编语言规范： intel公司发布的汇编语言规范，称intel 汇编：Windows派系</description></item><item><title>Skynet | lua-protobuf</title><link>https://zfunnily.github.io/2021/01/skynetprotobuf/</link><pubDate>Mon, 25 Jan 2021 14:25:07 +0000</pubDate><guid>https://zfunnily.github.io/2021/01/skynetprotobuf/</guid><description>概述 在最新的skynet中我使用的是云风的pbc库来解析protobuf，该项目中的一个文件protobuf.lua 使用了module语法在lua5.1版本中已经删除，最新的skynet是lua5.4</description></item><item><title>Protobuf | 请求参数为空的案例</title><link>https://zfunnily.github.io/2021/01/pbempty/</link><pubDate>Fri, 22 Jan 2021 16:41:16 +0000</pubDate><guid>https://zfunnily.github.io/2021/01/pbempty/</guid><description>参数为空的grpc请求怎么定义 google protobuf已经提供了空参数 //empty.proto message Empty {&amp;lt;!-- --&amp;gt;} 使用方法，在proto文件中导入empty.proto, 定义一个请求参数和返回值为空的函数emptyfunction， 函数名字</description></item><item><title>Golang | C数组转化为Golang的切片类型</title><link>https://zfunnily.github.io/2021/01/goslience/</link><pubDate>Fri, 22 Jan 2021 15:56:40 +0000</pubDate><guid>https://zfunnily.github.io/2021/01/goslience/</guid><description>概述 最近在巩固cgo的基础知识，在网上看到一篇Go和C之间 字符串数组、切片类型转换的文章，让我想到我之前写的一篇在go中遍历C结构体数组的文章，让我有新的方法来解决之前的问题，把C的数组转化为Go的切</description></item><item><title>Skynet | echo服务</title><link>https://zfunnily.github.io/2021/01/skynetecho/</link><pubDate>Fri, 15 Jan 2021 16:07:51 +0000</pubDate><guid>https://zfunnily.github.io/2021/01/skynetecho/</guid><description>概述 引用云风博客的话：“skynet 是一个为网络游戏服务器设计的轻量框架。但它本身并没有任何为网络游戏业务而特别设计的部分，所以尽可以把它用于其它领域。skynet 并不是一个开箱即用的引擎，使用它需要</description></item><item><title>Redis源码分析 | ziplist</title><link>https://zfunnily.github.io/2021/01/ziplist/</link><pubDate>Wed, 13 Jan 2021 17:52:27 +0000</pubDate><guid>https://zfunnily.github.io/2021/01/ziplist/</guid><description>概述 Redis中的List是一个有序（按加入的时序排序）的数据结构，一般有序我们会采用数组或者是双向链表，其中双向链表由于有前后指针实际上会很浪费内存。3.2版本之前采用两种数据结构作为底层实现： 压缩</description></item><item><title>Redis源码解析 | VScode调试</title><link>https://zfunnily.github.io/2021/01/vscodedebugredis/</link><pubDate>Tue, 12 Jan 2021 14:25:29 +0000</pubDate><guid>https://zfunnily.github.io/2021/01/vscodedebugredis/</guid><description>环境 vscode- gcc5.4 ubuntu16.04 或者 ubuntu18.04 make 下载6.2版本. 我使用的是国内github镜像地址：github.com.cnpmjs.org，速度比较快。 $ git clone https://github.com.cnpmjs.org/redis/redis.git redis $ git checkout -b 6.2 remotes/origin/6.2 vscode不参与编译，只充当可视化的调试工具。 使用</description></item><item><title>VScode | 调试Redis源码，指针显示的问题</title><link>https://zfunnily.github.io/2021/01/vscoderedis/</link><pubDate>Tue, 12 Jan 2021 14:17:22 +0000</pubDate><guid>https://zfunnily.github.io/2021/01/vscoderedis/</guid><description>缘由 使用VScode的时候，断点看到指针显示的是一串地址，而不是指针指向的对象的值。上网找了一圈，没看到vscode有对应的插件来解决这个问题。vscode有对应的语法来解决这个问题。 网上几乎都在说在</description></item><item><title>Cgo | 遍历C结构体数组</title><link>https://zfunnily.github.io/2021/01/cgostruct/</link><pubDate>Mon, 11 Jan 2021 17:18:35 +0000</pubDate><guid>https://zfunnily.github.io/2021/01/cgostruct/</guid><description>缘由 现在有个应用场景，我们要在go中获取C结构体数组中的值。在C语言中，对于结构体数组，我们可以利用指针的偏移量来获取我们想要的值的位置。在go中我们怎么使用C指针和偏移量进行运算呢？下面的文字中C指</description></item><item><title>Redis源码解析 | sds</title><link>https://zfunnily.github.io/2021/01/sds/</link><pubDate>Wed, 06 Jan 2021 14:20:23 +0000</pubDate><guid>https://zfunnily.github.io/2021/01/sds/</guid><description>SDS头文件及作用 sds.h: sds声明- sdsalloc.h： 为sds分配内存 源码文件sds.h中有这样一行代码 typedef char *sds; 很清晰、明了，sds其实就是char*。 最新的6.2分支的代码： struct __attribute__ ((__packed__)) sdshdr5 {&amp;lt;!-- --&amp;gt; unsigned char flags; /* 3 lsb of</description></item><item><title>struct中使用char[]</title><link>https://zfunnily.github.io/2021/01/chararray/</link><pubDate>Tue, 05 Jan 2021 15:45:36 +0000</pubDate><guid>https://zfunnily.github.io/2021/01/chararray/</guid><description>缘由 最近在看redis的源码，刚开始看sds，看到这块代码 struct __attribute__ ((__packed__)) sdshdr5 { unsigned char flags; /* 3 lsb of type, and 5 msb of string length */ char buf[]; }; 好奇为什么使用 char buf[],而不用char *buf，找到答案记录一下。 struct中的char*</description></item><item><title>Lastbattle | 游戏场景服务器SS解析</title><link>https://zfunnily.github.io/2021/01/lastbattle/</link><pubDate>Sat, 02 Jan 2021 23:19:58 +0000</pubDate><guid>https://zfunnily.github.io/2021/01/lastbattle/</guid><description>游戏场景服务器概况 指令对应的处理handle的文件：SSBattleMgr.cpp 创建战场 指令： eMsgToSSFromCS_CreateBattle GC服务器发往SS fromCS 收到中心服务器CS创建站场的指令，在函数INT32 CSSBattleMgr::OnMsgFromCS_CreateBattle(const char* pData, int n32DataLengt</description></item><item><title>CCnet | 单线程reactor演变为多线程</title><link>https://zfunnily.github.io/2020/12/ccnet/</link><pubDate>Wed, 30 Dec 2020 09:19:41 +0000</pubDate><guid>https://zfunnily.github.io/2020/12/ccnet/</guid><description>ccnet从单线程演变为多线程 ccnet现状： epoll linux平台 事件循环 单线程 reactor 监听和新连接的事件都在主线程中 单线程的ccnet ccnet的单线程的角色： EventLoop: 整个事件循环。 EPollPoller: 负责事件的收集。 Channel</description></item><item><title>Golang | sync.Mutex详解</title><link>https://zfunnily.github.io/2020/12/syncmutex/</link><pubDate>Tue, 29 Dec 2020 13:17:18 +0000</pubDate><guid>https://zfunnily.github.io/2020/12/syncmutex/</guid><description>概述 自己做的一个golang项目需要优化，优化方向是减少gpu内存的使用。同一个模型被重复加载多次，使用更多的gpu内存，也增加 sync.Mutex的使用。 优化的方向是: 减少代码量的改动- 减少gpu内</description></item><item><title>五种网络IO模型总结</title><link>https://zfunnily.github.io/2020/12/iomodels/</link><pubDate>Mon, 28 Dec 2020 11:57:04 +0000</pubDate><guid>https://zfunnily.github.io/2020/12/iomodels/</guid><description>概述 在网络上看到很多关于阻塞IO、非阻塞IO、同步IO、异步IO的例子，总觉得写的过于复杂并且让人难以理解。于是我把我自己把这几个概念的理解写下来以供参考。 POSIX POSIX(可移植操作系统接口)把同步IO</description></item><item><title>CCnet | 一个reactor单线程网络库</title><link>https://zfunnily.github.io/2020/12/ccnetone/</link><pubDate>Sun, 27 Dec 2020 18:41:25 +0000</pubDate><guid>https://zfunnily.github.io/2020/12/ccnetone/</guid><description>缘由 最近在研究陈硕的网络库muduo，是一个基于reactor架构的网络库。我对网络库的感觉是易用，但是内容庞大，依赖颇多。比如boost网络库里面的一些语法让人生畏。关于reactor和proact</description></item><item><title>C++ | vector中的resize()函数 VS reserve()函数</title><link>https://zfunnily.github.io/2020/12/reserve/</link><pubDate>Fri, 25 Dec 2020 11:04:29 +0000</pubDate><guid>https://zfunnily.github.io/2020/12/reserve/</guid><description>reserve void reserve (size_type n); reserver函数用来给vector预分配存储区大小，即capacity的值 ，但是没有给这段内存进行初始化。reserve 的参数n是推荐预分配内存的大小，实际分配的可能等于或大于这个值，即</description></item><item><title>Golang | 用gocolly登录B站</title><link>https://zfunnily.github.io/2020/12/gocolly/</link><pubDate>Sun, 13 Dec 2020 14:51:53 +0000</pubDate><guid>https://zfunnily.github.io/2020/12/gocolly/</guid><description>概述 gocolly是golang语言开发的爬虫包，通过gocolly来进行模拟网站的登录， 目标已经确立，开始行动。 下载 $ go get -u github.com/gocolly/colly 获取cookie 登录网站：https://www.bilibili.co</description></item><item><title>Protobuf | 沾包问题</title><link>https://zfunnily.github.io/2020/12/tcp/</link><pubDate>Sun, 13 Dec 2020 10:22:38 +0000</pubDate><guid>https://zfunnily.github.io/2020/12/tcp/</guid><description>缘由 最近在研究一款游戏的源码。发现里面的通信协议是protobuf定义的，但还是自己定义了协议头部，类似 head + body。先解析头部里所存储的整个包的数据长度，然后再解析包剩余的数据，这样做的目的是为了防</description></item><item><title>Grpc | 概述</title><link>https://zfunnily.github.io/2020/12/grpc/</link><pubDate>Sun, 13 Dec 2020 09:10:42 +0000</pubDate><guid>https://zfunnily.github.io/2020/12/grpc/</guid><description>OverView gRPC是由Google主导开发的RPC框架，使用HTTP/2协议并用ProtoBuf作为序列化工具。其客户端提供Objective-C、Java接口，服务器侧则有Java、Golang、C++等接</description></item><item><title>Ubuntu16.04.6 | 安装Cinnamon3.0</title><link>https://zfunnily.github.io/2020/12/cinnamon3.0/</link><pubDate>Tue, 01 Dec 2020 15:43:58 +0000</pubDate><guid>https://zfunnily.github.io/2020/12/cinnamon3.0/</guid><description>概述 Cinnamon[1]是Linux Mint[2]的默认桌面环境。不同于 Ubuntu 的 Unity 桌面环境，Cinnamon 是一个更加传统而优雅的桌面环境，其带有底部面板和应用菜单。由于 Cinnamon 桌面以及它类 Windows 的用户界面，许多</description></item><item><title>Ubuntu | version `GLIBC_2.27‘ not found错误</title><link>https://zfunnily.github.io/2020/11/glibcnotfound/</link><pubDate>Sat, 28 Nov 2020 15:03:04 +0000</pubDate><guid>https://zfunnily.github.io/2020/11/glibcnotfound/</guid><description>version `GLIBC_2.27’ not found错误 执行strings /lib/x86_64-linux-gnu/libc.so.6 | grep GLIBC_ 结果显示如下： GLIBC_2.2.5 GLIBC_2.2.6 GLIBC_2.3 GLIBC_2.3.2 GLIBC_2.3.3 GLIBC_2.3.4 GLIBC_2.4 GLIBC_2.5 GLIBC_2.6 GLIBC_2.7 GLIBC_2.8 GLIBC_2.9 GLIBC_2.10 GLIBC_2.11 GLIBC_2.12 GLIBC_2.13 GLIBC_2.14 GLIBC_2.15 GLIBC_2.16 GLIBC_2.17 GLIBC_2.18 GLIBC_2.22 GLIBC_2.23 GLIBC_2.24 GLIBC_PRIVATE 去清华开源站点下载glibc： https://mirrors.tuna.tsinghua.edu.cn/gnu/libc/ 下载好文件后解压 $ tar -zxvf glibc-2.27.tar.gz 进入 glibc-2.27 目录,</description></item><item><title>Docker | 容器退出码详解</title><link>https://zfunnily.github.io/2020/11/Docker%E5%AE%B9%E5%99%A8%E9%80%80%E5%87%BA%E7%A0%81%E8%AF%A6%E8%A7%A3/</link><pubDate>Sat, 28 Nov 2020 13:32:57 +0000</pubDate><guid>https://zfunnily.github.io/2020/11/Docker%E5%AE%B9%E5%99%A8%E9%80%80%E5%87%BA%E7%A0%81%E8%AF%A6%E8%A7%A3/</guid><description>docker查看退出码指令 $ docker ps --filter &amp;#34;status=exited&amp;#34; $ docker inspect container-id --format=&amp;#39;{&amp;lt;!-- --&amp;gt;{.State.ExitCode}}&amp;#39; 常见退出码 Exit Code 0 退出代码0表示特定容器没有附加前台进程。 该退出代码是所有其他后续退出代码的例外。 这不一定意味着发生了不好的事情。如果开发人员想要在容器完</description></item><item><title>Openresty二 | postman小工具</title><link>https://zfunnily.github.io/2020/11/%E4%BD%BF%E7%94%A8OpenResty%E5%81%9A%E4%B8%80%E4%B8%AApostman%E5%B0%8F%E5%B7%A5%E5%85%B7/</link><pubDate>Wed, 25 Nov 2020 16:30:39 +0800</pubDate><guid>https://zfunnily.github.io/2020/11/%E4%BD%BF%E7%94%A8OpenResty%E5%81%9A%E4%B8%80%E4%B8%AApostman%E5%B0%8F%E5%B7%A5%E5%85%B7/</guid><description>用到的知识点 mvc架构 模型渲染库：https://github.com/bungle/lua-resty-template resty http请求库： https://github.com/bungle/lua-resty-template 参照 mvc模型来做postman工具 配置文件说明 worker_processes 1; error_log logs/error.log; events</description></item><item><title>Openresty一 | 初探</title><link>https://zfunnily.github.io/2020/11/OpenResty%E5%88%9D%E6%8E%A2/</link><pubDate>Mon, 23 Nov 2020 16:21:34 +0800</pubDate><guid>https://zfunnily.github.io/2020/11/OpenResty%E5%88%9D%E6%8E%A2/</guid><description>概述 OpenResty®是一个基于Nginx与 Lua 的高性能 Web 平台，其内部集成了大量精良的 Lua 库、第三方模块以及大多数的依赖项。用于方便地搭建能够处理超高并发、扩展性极高的动态 Web 应用、Web 服务和动态网关。</description></item><item><title>LastBattle | 登录流程(LS &amp; BS &amp; GS)</title><link>https://zfunnily.github.io/2020/11/lastbattlelogin/</link><pubDate>Fri, 20 Nov 2020 17:27:08 +0000</pubDate><guid>https://zfunnily.github.io/2020/11/lastbattlelogin/</guid><description>登录流程 根据上一篇文章中的登录流程,我在工程中找到了相应的代码并记录了下来 登录服务代码解析 监听端口：49997 供BS服务连接 监听端口：49996 供客户端连接 CIocpCtrl：IOCP控制类 多线程循环</description></item><item><title>LastBattle | 服务架构</title><link>https://zfunnily.github.io/2020/11/lastbattleserver/</link><pubDate>Fri, 20 Nov 2020 17:24:32 +0000</pubDate><guid>https://zfunnily.github.io/2020/11/lastbattleserver/</guid><description>服务器架构简图如下: 连线说明： 实线：表示客户端登录流程，①②③④⑤表示登录流程，详细解释见下文。 虚线：表示服务器间的连接，虚线箭头指向监听方。 架构说明： |英文名称|简称|中文名称|功能简介|单个大区需</description></item><item><title>LastBattle | 安装部署笔记</title><link>https://zfunnily.github.io/2020/11/lastbattleone/</link><pubDate>Mon, 16 Nov 2020 06:49:49 +0000</pubDate><guid>https://zfunnily.github.io/2020/11/lastbattleone/</guid><description>环境准备 win10 服务器：vs2010 / 数据库 mysql5.7 清华大学mysql镜像网站:https://mirrors.tuna.tsinghua.edu.cn/mysql/downloads/MySQL-5.7/ 客户端</description></item><item><title>Cgo | 使用libevent库实现一个定时器</title><link>https://zfunnily.github.io/2020/11/cgo%E4%BD%BF%E7%94%A8libevent%E5%BA%93%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%AE%9A%E6%97%B6%E5%99%A8/</link><pubDate>Fri, 13 Nov 2020 16:40:42 +0000</pubDate><guid>https://zfunnily.github.io/2020/11/cgo%E4%BD%BF%E7%94%A8libevent%E5%BA%93%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%AE%9A%E6%97%B6%E5%99%A8/</guid><description>使用libevent库作为例子 下载 &amp;amp; 编译 &amp;amp; 安装libevent $ git clone https://github.com.cnpmjs.org/libevent/libevent.git $ cd libevent &amp;amp;&amp;amp; mkdir build &amp;amp;&amp;amp; cd build $ cmake .. $ make libevent实现的定时器 // main.cpp #include &amp;#34;event.h&amp;#34; struct event ev; struct timeval tv; void time_cb(evutil_socket_t fd, short event, void *argc) { printf(&amp;#34;timer wakeup\n&amp;#34;); event_add(&amp;amp;ev, &amp;amp;tv); // reschedule timer } int main() { struct event_base *base = event_base_new(); tv.tv_sec = 2;</description></item><item><title>Golang | 利用指针进行数据转换</title><link>https://zfunnily.github.io/2020/11/Golang-%E5%88%A9%E7%94%A8%E6%8C%87%E9%92%88%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E8%BD%AC%E6%8D%A2/</link><pubDate>Thu, 12 Nov 2020 17:19:07 +0000</pubDate><guid>https://zfunnily.github.io/2020/11/Golang-%E5%88%A9%E7%94%A8%E6%8C%87%E9%92%88%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E8%BD%AC%E6%8D%A2/</guid><description>概述 在Go语言中，Slice本质是什么呢？是一个reflect.SliceHeader结构体和这个结构体中Data字段所指向的内存。String本质是什么呢？是一个reflect.StringHead</description></item><item><title>Golang | builds</title><link>https://zfunnily.github.io/2020/11/go-builds/</link><pubDate>Thu, 12 Nov 2020 17:15:17 +0000</pubDate><guid>https://zfunnily.github.io/2020/11/go-builds/</guid><description>概述 通常我们会给每个产品环境设置不同的配置，比如 redis 要在开发环境就连接 localhost:6379，测试环境可能连接某一个主机的 redis。 如果放在 go 里面是否可行？因为 go 是编译二进制包，也没有动态加载这</description></item><item><title>Cgo | 简单使用</title><link>https://zfunnily.github.io/2020/11/cgo%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</link><pubDate>Thu, 05 Nov 2020 09:45:23 +0000</pubDate><guid>https://zfunnily.github.io/2020/11/cgo%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</guid><description>使用自己的C函数 文件名：testC.go package main /* #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;stdlib.h&amp;gt; void c_print(char *str) { printf(&amp;#34;%s\n&amp;#34;, str); } */ import &amp;#34;C&amp;#34; //import “C” 必须单起一行，并且紧跟在注释行之后 import &amp;#34;unsafe&amp;#34; func main() { s := &amp;#34;Hello Cgo&amp;#34; cs := C.CString(s) //字符串映射 C.c_print(cs) //调用C函数 defer C.free(unsafe.Pointer(cs)) //释放内存 } 说明： 1、g</description></item><item><title>Golang | 使用Lumberjack+zap进行日志切割归档</title><link>https://zfunnily.github.io/2020/11/%E4%BD%BF%E7%94%A8Lumberjack-zap%E8%BF%9B%E8%A1%8C%E6%97%A5%E5%BF%97%E5%88%87%E5%89%B2%E5%BD%92%E6%A1%A3/</link><pubDate>Wed, 04 Nov 2020 12:44:03 +0000</pubDate><guid>https://zfunnily.github.io/2020/11/%E4%BD%BF%E7%94%A8Lumberjack-zap%E8%BF%9B%E8%A1%8C%E6%97%A5%E5%BF%97%E5%88%87%E5%89%B2%E5%BD%92%E6%A1%A3/</guid><description>使用Lumberjack+zap进行日志切割归档 为了添加日志切割归档功能，我们将使用第三方库Lumberjack来实现。 安装 执行下面的命令安装Lumberjack go get -u github.com/natefinch/lumberjack zap logger中加入Lumbe</description></item><item><title>Vim | vimplus快捷键</title><link>https://zfunnily.github.io/2020/10/vimplus%E5%BF%AB%E6%8D%B7%E9%94%AE/</link><pubDate>Wed, 28 Oct 2020 09:14:28 +0000</pubDate><guid>https://zfunnily.github.io/2020/10/vimplus%E5%BF%AB%E6%8D%B7%E9%94%AE/</guid><description>插件相关 |快捷键|说明 |&amp;mdash;&amp;mdash; |,|Leader Key |&amp;lt;leader&amp;gt;n|打开 / 关闭代码资源管理器 |&amp;lt;leader&amp;gt;t|打开 / 关闭函数列表 |&amp;lt;leader&amp;gt;a|.h .cpp 文件切换 |&amp;lt;leader&amp;gt;u|转到函数声明 |&amp;</description></item><item><title>Vim | 打造编C++IDE</title><link>https://zfunnily.github.io/2020/10/%E4%BD%BF%E7%94%A8vim%E6%89%93%E9%80%A0%E7%BC%96C-IDE/</link><pubDate>Wed, 28 Oct 2020 09:11:32 +0000</pubDate><guid>https://zfunnily.github.io/2020/10/%E4%BD%BF%E7%94%A8vim%E6%89%93%E9%80%A0%E7%BC%96C-IDE/</guid><description>使用 vimplus 打造C++ IDE GitHub： https://github.com/chxuan/vimplus 支持平台： macos/linux 安装vimplus // 原来的链接， 国内速度较慢 $ git clone https://github.com/chxuan/vimplus.git ~/.vimplus // github修改为镜像的链接 $ git clone --depth=1 https://github.com.cnpmjs.org/chxuan/vimplus.git ~/.vimplus $ cd ~/.vimplus //不加sudo $ ./install.sh 设置Nerd Font 为防止vimplu</description></item><item><title>Linux | 删除大量文件指令--rsync</title><link>https://zfunnily.github.io/2020/10/linux%E7%B3%BB%E7%BB%9F%E5%88%A0%E9%99%A4%E5%A4%A7%E9%87%8F%E6%96%87%E4%BB%B6%E6%8C%87%E4%BB%A4--rsync/</link><pubDate>Tue, 13 Oct 2020 16:29:34 +0000</pubDate><guid>https://zfunnily.github.io/2020/10/linux%E7%B3%BB%E7%BB%9F%E5%88%A0%E9%99%A4%E5%A4%A7%E9%87%8F%E6%96%87%E4%BB%B6%E6%8C%87%E4%BB%A4--rsync/</guid><description>rsync的安装 rsync安装，有些系统默认安装有该命令 ubuntu系统 sudo apt-get install rsync centos系统 sudo yum install rsync rsync参数详解 rsync提供了一些跟删除有关的参数 rsync --help | grep delete -del an alias for --delete-during --delete delete extraneous files from destination dirs --delete-before receiver deletes before</description></item><item><title>CPU的核与线程-4核8线程</title><link>https://zfunnily.github.io/2020/10/CPU%E7%9A%84%E6%A0%B8%E4%B8%8E%E7%BA%BF%E7%A8%8B-4%E6%A0%B88%E7%BA%BF%E7%A8%8B/</link><pubDate>Mon, 12 Oct 2020 16:29:34 +0000</pubDate><guid>https://zfunnily.github.io/2020/10/CPU%E7%9A%84%E6%A0%B8%E4%B8%8E%E7%BA%BF%E7%A8%8B-4%E6%A0%B88%E7%BA%BF%E7%A8%8B/</guid><description>查看cpu信息 $ cat /proc/cpuinfo 物理CPU 物理CPU就是计算机上实际配置的CPU个数。 在linux上可以打开cat /proc/cpuinfo 来查看，其中的physical id就是每个物理CPU的ID，能找到几个physical id就代表</description></item><item><title>TCP/IP | 大量TIME_WAIT对线上业务的影响</title><link>https://zfunnily.github.io/2020/10/%E5%A4%A7%E9%87%8FTIME_WAIT%E5%AF%B9%E7%BA%BF%E4%B8%8A%E4%B8%9A%E5%8A%A1%E7%9A%84%E5%BD%B1%E5%93%8D/</link><pubDate>Sat, 10 Oct 2020 16:46:34 +0000</pubDate><guid>https://zfunnily.github.io/2020/10/%E5%A4%A7%E9%87%8FTIME_WAIT%E5%AF%B9%E7%BA%BF%E4%B8%8A%E4%B8%9A%E5%8A%A1%E7%9A%84%E5%BD%B1%E5%93%8D/</guid><description>TCP的三次握手和四次挥手 TIME_WAIT概述 TIME_WAIT 状态： TCP 连接中，主动关闭连接的一方出现的状态；（收到 FIN 命令，进入 TIME_WAIT 状态，并返回 ACK 命令） 保持 2 个 MSL 时间，即，4 分钟 ；（MSL 为 2 分钟） TCP 连接建立后，「主</description></item><item><title>Libevent | 定时器</title><link>https://zfunnily.github.io/2020/09/libeventimer/</link><pubDate>Wed, 16 Sep 2020 23:20:28 +0000</pubDate><guid>https://zfunnily.github.io/2020/09/libeventimer/</guid><description>libevent 实现定时器流程 首先初始化libevent库，并保存返回的指针 struct event_base * base = event_init(); 实际上这一步相当于初始化一个Reactor实例；在初始化libevent后，就可以注册事件了。 初始化事件event，设置回调函</description></item><item><title>FFmpeg | 画中画和视频多宫格处理</title><link>https://zfunnily.github.io/2020/09/ffmpegpicture/</link><pubDate>Mon, 14 Sep 2020 18:29:33 +0000</pubDate><guid>https://zfunnily.github.io/2020/09/ffmpegpicture/</guid><description>FFmpeg生成画中画 静态画中画 将视频sub.mp4视频文件缩放成宽 480 、高 320 的视频,然后显示在 视频 input.mp4,x坐标为0,y 坐标为0 的位置 ffmpeg -re -i input.mp4 -vf &amp;#34;movie=sub.mp4, scale=480x320[test]; [in][test]overlay [out]&amp;#34; -vcodec libx264 output.flv 显示在画面的右下角，则需要用到</description></item><item><title>FFmpeg | 给视频加文字和图片水印</title><link>https://zfunnily.github.io/2020/09/ffmpegvideo/</link><pubDate>Sat, 12 Sep 2020 12:47:57 +0000</pubDate><guid>https://zfunnily.github.io/2020/09/ffmpegvideo/</guid><description>FFmpeg给视频加上logo ffmpeg从视频中截取图像帧 ffmpeg -i inputfile.avi -r 1 -f image2 image-%05d.jpeg ffmpeg -i inputfile.avi -r 1 -s 4cif -f image2 image-%05d.jpeg ffmpeg -i inputfile.avi -r 1 -t 4 -f image2 image-%05d.jpeg ffmpeg -i inputfile.avi -r 1 -ss 01:30:14 -f image2 image-%05d.jpeg ffmpeg -i inputfile.avi -r 1 -ss 01:30:14 -vframes 120 4cif -f image2 image-%05d.jpeg -r 指定抽取的帧率，即从视频中每秒钟抽取</description></item><item><title>FFmpeg | 录制摄像头和桌面数据windows</title><link>https://zfunnily.github.io/2020/09/ffmpegvideow/</link><pubDate>Wed, 09 Sep 2020 09:36:49 +0000</pubDate><guid>https://zfunnily.github.io/2020/09/ffmpegvideow/</guid><description>概述 FFmpeg Windows 设备操作 Windows 采集设备的主要方式是 dshow vfwcap gdigrab 其中 dshow 可以用来抓 取摄像头、采集卡、麦克风等，- vfwcap 主要用来采集摄像头类设备，- gdigrab 则是抓取 Windows 窗口程序 FFmpeg 使用 dshow 采集音视频设备 使用 dshow 枚举设备 ffmpeg -f dshow -list_devices true -i dymmy 输出 [dshow @ 000002622302e340]</description></item><item><title>FFmpeg | 录制摄像头和桌面数据mac</title><link>https://zfunnily.github.io/2020/08/macffmpeg/</link><pubDate>Sat, 29 Aug 2020 17:20:40 +0000</pubDate><guid>https://zfunnily.github.io/2020/08/macffmpeg/</guid><description>设备枚举 查看设备列表 $ ffmpeg -hide_banner -devices Devices: D. = Demuxing supported .E = Muxing supported -- D avfoundation AVFoundation input device D lavfi Libavfilter virtual input device E sdl,sdl2 SDL2 output device 可以看到输入设备有：avfoundation，lavfi 输出设备有：sdl `` 设备采集举例： $ ffmpeg -f avfoundation -list_devices true -i &amp;#34; &amp;#34; 看到了 如下设</description></item><item><title>K8S | Prometheus+Grafana监控</title><link>https://zfunnily.github.io/2020/08/prometheusgrafana/</link><pubDate>Mon, 17 Aug 2020 13:58:35 +0000</pubDate><guid>https://zfunnily.github.io/2020/08/prometheusgrafana/</guid><description>概述 作为应用与Kubernetes的监控体系，Prometheus具备诸多的优势，如： Kubernetes默认支持,非常适合容器和微服务- 无依赖，安装方便，上手容易- 社区活跃，它不仅仅是个工具，而是生</description></item><item><title>Owt-server | owt-client-javascript</title><link>https://zfunnily.github.io/2020/08/owt-client-javascript/</link><pubDate>Sun, 16 Aug 2020 23:04:13 +0000</pubDate><guid>https://zfunnily.github.io/2020/08/owt-client-javascript/</guid><description>概述 天气燥热，不易出门。遂研究一下owt-server，从owt-client-javascript的流程开始吧。 获取一个会议室 owt-client-javascript的时候有一个初始化房间的过程 ///owt-client-javascript/src/samples/conference/samplertcservice.js</description></item><item><title>K8S | Ingress的基本使用</title><link>https://zfunnily.github.io/2020/08/ingress/</link><pubDate>Sat, 15 Aug 2020 00:05:15 +0000</pubDate><guid>https://zfunnily.github.io/2020/08/ingress/</guid><description>缘由 看了statefulset基础教程的基础教程，并且把环境搭建起来后。pod内部是可以连通了。但是我不知道怎么去从外部访问。在网上搜索一番，通过Ingress可以作为集群的入口。遂记录之。 结合Sta</description></item><item><title>K8S | Statefluset的持久存储PVC</title><link>https://zfunnily.github.io/2020/08/pvc/</link><pubDate>Fri, 14 Aug 2020 17:18:58 +0000</pubDate><guid>https://zfunnily.github.io/2020/08/pvc/</guid><description>缘由 在看statefluset基础教程的时候遇到pod状态为pending kubectl describe pod web-0 日志内容是 pod has unbound immediate PersistentVolumeClaims 于是就对PV和PVC进行研究。 有给出完整的 web.yaml查看最下面的完整示例。但是我建议先把PV</description></item><item><title>Linux | nsf服务的搭建和使用</title><link>https://zfunnily.github.io/2020/08/nsf/</link><pubDate>Fri, 14 Aug 2020 17:17:54 +0000</pubDate><guid>https://zfunnily.github.io/2020/08/nsf/</guid><description>搭建nsf服务 sudo apt install nfs-kernel-server 默认情况下，在Ubuntu 18.04上，NFS版本2是禁用的。版本3和版本4已启用。您可以通过运行以下cat命令来验证： sudo cat /proc/fs/nfsd/versions 写入 exports cat /etc/exports sudo echo /nfs/prometheus/data/ 192.168.84.75/24(rw,no_root_squash,no_all_squash,sync) &amp;gt;&amp;gt; /etc/exports sudo echo /nfs/prometheus/data/ 192.168.84.75/24(rw,no_root_squash,no_all_squash,sync) &amp;gt;&amp;gt; /etc/exports 可以设定的参数主要</description></item><item><title>K8S | StatefulSet基本原理</title><link>https://zfunnily.github.io/2020/08/statefulset/</link><pubDate>Fri, 14 Aug 2020 16:03:41 +0000</pubDate><guid>https://zfunnily.github.io/2020/08/statefulset/</guid><description>背景 用户通过 Deployment、ReplicationController 可以方便地在 kubernetes 中部署一套高可用、可扩展的分布式无状态服务。这类应用不在本地存储数据，通过简单的负载均衡策略可实现请求分发。随</description></item><item><title>K8S | coreDNS的部署安装</title><link>https://zfunnily.github.io/2020/08/coredns/</link><pubDate>Thu, 13 Aug 2020 18:44:28 +0000</pubDate><guid>https://zfunnily.github.io/2020/08/coredns/</guid><description>概述 CoreDNS可以在具有标准的Kube-DNS的Kubernetes集群中运行。作为Kubernetes 的插件使用，CoreDNS将从 Kubernetes集群中读取区（zone）数据。它实现了为K</description></item><item><title>K8S | 创建第一个应用</title><link>https://zfunnily.github.io/2020/08/firstk8s/</link><pubDate>Thu, 13 Aug 2020 15:28:31 +0000</pubDate><guid>https://zfunnily.github.io/2020/08/firstk8s/</guid><description>使用k8s部署第一个应用 创建一个nginx.yaml文件 apiVersion: v1 kind: Pod metadata: name: nginx # 指定 label，便于检索 labels: app: nginx spec: containers: - name: nginx # 指定镜像 image: nginx:alpine # 指定暴露端口 ports: - containerPort: 80 --- # 创建网络服务 apiVersion: v1 kind: Service metadata: name: kube-node-service labels: name: kube-node-service spec: type: NodePort #这里代表</description></item><item><title>Licod | 安装和配置</title><link>https://zfunnily.github.io/2020/08/licode/</link><pubDate>Sun, 09 Aug 2020 09:34:36 +0000</pubDate><guid>https://zfunnily.github.io/2020/08/licode/</guid><description>拉取docker镜像并运行 licode官方提供了配置好的docker镜像，使用以下命令拉下来跑就行。 docker run --name licode -p 3000:3000 -p $MIN_PORT-$MAX_PORT:30000-30050/udp -p 3001:3001 -p 8080:8080 -e &amp;#34;MIN_PORT=30000&amp;#34; -e &amp;#34;MAX_PORT=30050&amp;#34; -e &amp;#34;PUBLIC_IP=your_ip_address&amp;#34; lynckia/licode 注意命令里的PUBLIC_IP要改为服务器的公网IP。 配置好之</description></item><item><title>Docker | 远程访问加密</title><link>https://zfunnily.github.io/2020/08/dockersecret/</link><pubDate>Fri, 07 Aug 2020 07:56:52 +0000</pubDate><guid>https://zfunnily.github.io/2020/08/dockersecret/</guid><description>docker的远程访问 方法一 ：编辑docker.service文件 编辑docker.service文件 sudo vim /lib/systemd/system/docker.service 修改ExecStart行为下面内容 ExecStart=/usr/bin/dockerd -H tcp://0.0.0.0:2375 -H unix://var/run/docker.sock 重新加载docker配置 sudo systemctl daemon-reload // 1，加载dock</description></item><item><title>Docker | web管理界面portainer</title><link>https://zfunnily.github.io/2020/08/dockerweb/</link><pubDate>Fri, 07 Aug 2020 07:54:43 +0000</pubDate><guid>https://zfunnily.github.io/2020/08/dockerweb/</guid><description>拉取镜像 $ docker pull portainer/portainer 运行启动portainer docker run -d -p 9000:9000 -v /var/run/docker.sock:/var/run/docker.sock -v /home/docker/portainer:/data --name portainer --restart=always portainer/portainer admin bigant.cn 汉化 Portainer-CN.zip 百度云盘: https://pan.baidu.com/s/13ra6jXHR_7vajLLlf5GVEw 提取码: nzue 新建文件夹命名为public，把Portainer-CN.zip解压至里面。 2、public文件夹传</description></item><item><title>K8S | 集群资源监控 heapster</title><link>https://zfunnily.github.io/2020/08/heapster/</link><pubDate>Thu, 06 Aug 2020 09:06:05 +0000</pubDate><guid>https://zfunnily.github.io/2020/08/heapster/</guid><description>安装heapster的原因 查看dashboard状态 $ sudo kubectl get pods --all-namespaces | grep dashboard kubernetes-dashboard dashboard-metrics-scraper-6b4884c9d5-mvnb9 1/1 Running 0 40m kubernetes-dashboard kubernetes-dashboard-d7f7f565d-zhpsc 1/1 Running 0 40m 查看dashboard的日志 $ sudo kubectl logs -f -n kubernetes-dashboard kubernetes-dashboard-d7f7f565d-zhpsc 日志遇到这样的情况 No metric client provided. Skipping metrics. 2020/08/03 09:02:22 [2020-08-03T09:02:22Z] Outcoming response to 192.168.84.241:40086 with 200 status code 2020/08/03 09:02:23 Metric client health</description></item><item><title>K8S | Dashboard界面管理</title><link>https://zfunnily.github.io/2020/08/dashboard/</link><pubDate>Thu, 06 Aug 2020 09:04:14 +0000</pubDate><guid>https://zfunnily.github.io/2020/08/dashboard/</guid><description>安装部署Dashboard 通过一下命令来部署, recommended.yaml $ sudo kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v2.0.0/aio/deploy/recommended.yaml https://raw.githubusercontent.com/kubernetes/dashboard/v2.0.0/aio/depl</description></item><item><title>K8S | 安装</title><link>https://zfunnily.github.io/2020/08/k8sinstall/</link><pubDate>Wed, 05 Aug 2020 10:00:40 +0000</pubDate><guid>https://zfunnily.github.io/2020/08/k8sinstall/</guid><description>安装k8s前的准备工作 环境 ubuntu18.04 docker 关闭 swap 暂时关闭 $ swapoff -a 永久关闭 注释掉这一行 sudo vim /etc/fstab # /swapfile none swap sw 0 0 重启机器 sudo reboot docker 的配置 安装完成之后需要进行一些配置，包括 切换docker下载源为国内镜像站 以及 修改cgroups</description></item><item><title>Owt-server | 编译运行</title><link>https://zfunnily.github.io/2020/08/owtservercomplie/</link><pubDate>Wed, 05 Aug 2020 09:47:22 +0000</pubDate><guid>https://zfunnily.github.io/2020/08/owtservercomplie/</guid><description>概述 owt是一套完整的webrtc视频会议系统。包含的功能模块有： 视频会议1. p2p 服务器是owt-server通过nodejs编写的webrtc信令。依赖是licode。licode依赖webrtc。 客</description></item><item><title>归档</title><link>https://zfunnily.github.io/archives/</link><pubDate>Fri, 17 Apr 2020 20:43:57 +0800</pubDate><guid>https://zfunnily.github.io/archives/</guid><description/></item><item><title>搜索</title><link>https://zfunnily.github.io/search/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zfunnily.github.io/search/</guid><description/></item><item><title>神之亵渎1</title><link>https://zfunnily.github.io/1/01/blasphemous/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zfunnily.github.io/1/01/blasphemous/</guid><description>地图设计 非线性结构： 游戏的地图是非线性的，允许玩家在一个庞大的世界中自由探索。玩家可以决定选择不同的路径和区域，解锁新的能力以访问之前无法到达的地方。 多样化的区域： 地图中包含了多个主题区域，每个区域都</description></item><item><title>血污boos</title><link>https://zfunnily.github.io/1/01/blood/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zfunnily.github.io/1/01/blood/</guid><description>《血污：夜之仪式》 BOSS一/猎魔斩月 挑衅 + 招架 飞镖 横砍 劈砍 冲刺 + 横砍 跳起来 + 劈砍 跳起来 + 上挑 跳起来 + 上挑 + 劈砍 钩锁 + 劈砍 刀刃，火焰附魔 + 上面的轮回 影分身 格莫瑞 最终boss 没有后续boss的分析 地图设</description></item></channel></rss>