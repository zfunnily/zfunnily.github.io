<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Zzz记忆</title>
    <link>https://zfunnily.github.io/</link>
    <description>Recent content on Zzz记忆</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Wed, 29 Dec 2021 13:50:28 +0800</lastBuildDate><atom:link href="https://zfunnily.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Blog | 代码显示/隐藏</title>
      <link>https://zfunnily.github.io/2021/12/shortcodes/</link>
      <pubDate>Wed, 29 Dec 2021 13:50:28 +0800</pubDate>
      
      <guid>https://zfunnily.github.io/2021/12/shortcodes/</guid>
      <description>缘由 最近在写技术博客时，引入的代码太多，影响观感。 在尽力减少代码量，还是有些不可或缺的代码，代码量很惊人，已经占满整个屏幕. 因为个人博客是使用hugo生成的静态博客，我刚开始想的使用原生的js和css</description>
    </item>
    
    <item>
      <title>Nginx的一些配置</title>
      <link>https://zfunnily.github.io/2021/12/nginx/</link>
      <pubDate>Tue, 28 Dec 2021 16:04:10 +0800</pubDate>
      
      <guid>https://zfunnily.github.io/2021/12/nginx/</guid>
      <description>静态网站 应用场景 文件服务 静态网站 &amp;hellip; 静态网站的配置 配置如下: nginx.conf worker_processes 1; pid nginx.pid; events { worker_connections 1024; multi_accept on; } http { default_type application/octet-stream; sendfile on; keepalive_timeout 100; server { listen 80; charset utf-8,gbk; server_name localhost; location /{ root /opt/; autoindex on; autoindex_localtime on; } index index.html; # 显示首页 #静态文件访问 location ~* ^.+\.(jpg|jpeg|gif|png|ico|css|js|pdf|txt) { root /opt; } } } root: 表示网站根目录 autoindex: on 显</description>
    </item>
    
    <item>
      <title>摘抄 ｜ 我的精神家园</title>
      <link>https://zfunnily.github.io/thinking/2021/12/pervert/</link>
      <pubDate>Mon, 27 Dec 2021 21:44:21 +0800</pubDate>
      
      <guid>https://zfunnily.github.io/thinking/2021/12/pervert/</guid>
      <description>另一种文化 假如有个pervert站出来说：我就是个pervert，那他就不是个pervert。 当且仅当一个人声称：我就不知道pervert是什么时，他才是个pervert。 假如我说，我们这里有种per</description>
    </item>
    
    <item>
      <title>A*算法 | Lua版本</title>
      <link>https://zfunnily.github.io/2021/12/astar/</link>
      <pubDate>Thu, 23 Dec 2021 16:37:44 +0800</pubDate>
      
      <guid>https://zfunnily.github.io/2021/12/astar/</guid>
      <description>A*算法思路 寻路步骤 从起点A开始, 把它作为待处理的方格存入一个&amp;quot;开启列表&amp;quot;, 开启列表就是一个等待检查方格的列表. 寻找起点A周围可以到达的方格, 将它们放入&amp;quot;开启列表&amp;quo</description>
    </item>
    
    <item>
      <title>Blog | 音乐播放器</title>
      <link>https://zfunnily.github.io/2021/12/music/</link>
      <pubDate>Tue, 21 Dec 2021 16:55:23 +0800</pubDate>
      
      <guid>https://zfunnily.github.io/2021/12/music/</guid>
      <description>概述 今天给我的个人博客加了个暗模式，这样可以在晚上阅读博客的时候不伤害眼睛。突然想到如果在阅读博客的时候可以听听音乐就更好了。 于是在github上找到了一个开源的项目MetingJS，看最后一次com</description>
    </item>
    
    <item>
      <title>Blog | 网站暗模式</title>
      <link>https://zfunnily.github.io/2021/12/dark/</link>
      <pubDate>Tue, 21 Dec 2021 11:05:00 +0800</pubDate>
      
      <guid>https://zfunnily.github.io/2021/12/dark/</guid>
      <description>Wordpress 如果你的网站是wordpress，则可以参考以Darkmode.js为基础的插件: blackout-darkmode-widget darkmode Nuxt.js 如果你正在使用Nuxt.js,则可以使用下面的模块 nuxtjs-darkmode-js-module 快速使用 使用Darkmode.js给网站快速部署上暗/浅色</description>
    </item>
    
    <item>
      <title>介词 ｜ of 的使用方法</title>
      <link>https://zfunnily.github.io/english/preposition/</link>
      <pubDate>Wed, 15 Dec 2021 11:14:10 +0800</pubDate>
      
      <guid>https://zfunnily.github.io/english/preposition/</guid>
      <description>介词of的使用方法 介词of共有13种使用方法 表示地区 英文里的方位East、West、South、North后面加上of+地名可以表示一个地区。 1 2 Newcastle is in the north of England. 纽卡斯位于英国北部 表示方位 方位加上 of + 某</description>
    </item>
    
    <item>
      <title>连词 ｜ and 和 or 的用法</title>
      <link>https://zfunnily.github.io/english/conjunction/</link>
      <pubDate>Wed, 15 Dec 2021 10:20:57 +0800</pubDate>
      
      <guid>https://zfunnily.github.io/english/conjunction/</guid>
      <description>连词 and 和 or 的用法 and 和 or 在否定句中的比较 通常情况下and用于肯定句，or用于否定句: 1 2 He has brother and sister. 他有兄弟姐妹 He has no brother or sister. 他没有兄弟姐妹 在特殊情况下，即使否定句也得用or: 1 Drivers must not drink and drive. 司机不准酒后驾车</description>
    </item>
    
    <item>
      <title>Openresty三 | 上传文件</title>
      <link>https://zfunnily.github.io/2021/12/openresty-upload/</link>
      <pubDate>Wed, 08 Dec 2021 16:42:17 +0800</pubDate>
      
      <guid>https://zfunnily.github.io/2021/12/openresty-upload/</guid>
      <description>上传文件接口 nginx.conf 的server 增加一个location: location /upload { resolver 8.8.8.8 ipv6=off; content_by_lua_file lua/upload.lua; } upload.lua lua 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62</description>
    </item>
    
    <item>
      <title>Webrtc二 | 共享桌面</title>
      <link>https://zfunnily.github.io/2021/11/webrtcdesk/</link>
      <pubDate>Mon, 15 Nov 2021 11:23:24 +0800</pubDate>
      
      <guid>https://zfunnily.github.io/2021/11/webrtcdesk/</guid>
      <description>环境 Ubuntu18.04 webrtc M84 改造peerconnection例子，用来实现桌面共享 改造类CapturerTrackSource 增加桌面的数据源类RcrtcDesktopCapturerTrackSource 继承webr</description>
    </item>
    
    <item>
      <title>Webrtc一 | peerconnection</title>
      <link>https://zfunnily.github.io/2021/11/webrtcpeerconnection/</link>
      <pubDate>Sun, 14 Nov 2021 16:20:31 +0800</pubDate>
      
      <guid>https://zfunnily.github.io/2021/11/webrtcpeerconnection/</guid>
      <description>环境 Ubuntu18.04 webrtc M84 国内镜像：https://webrtc.org.cn/mirror/ webrtc交互过程 通过peerconnection的例子来分析webrtc的交互流程 peer_connection 解析 为了便于管理，如编码，回显等，</description>
    </item>
    
    <item>
      <title>Go-libp2p四 | 穿透NAT</title>
      <link>https://zfunnily.github.io/2021/11/gop2pfour/</link>
      <pubDate>Sun, 07 Nov 2021 15:49:46 +0800</pubDate>
      
      <guid>https://zfunnily.github.io/2021/11/gop2pfour/</guid>
      <description>本文目的 上文Go-libp2p三 | relay例子已经分析过relay例子，并解释了两个节点如果通过中继服务进行通信。本文改造relay例子 并让这个服务做如下两件事： 交换两个节点的在交换机上的信息，帮助</description>
    </item>
    
    <item>
      <title>Blog | 随机名人名言</title>
      <link>https://zfunnily.github.io/2021/11/randomquotes/</link>
      <pubDate>Fri, 05 Nov 2021 15:50:16 +0800</pubDate>
      
      <guid>https://zfunnily.github.io/2021/11/randomquotes/</guid>
      <description>本文目的 我的个人博客已经搭建好了，使用的hugo+飞雪的主题。我看到有些博客上有些随机的名人名言，但是这个主题没有。遂自己写一个。 根据飞雪的主题自定义 飞雪主题的github: https://github.com/flysnow-org/maupassant-hugo 复制主题里的文件them</description>
    </item>
    
    <item>
      <title>Go-libp2p三 | relay例子</title>
      <link>https://zfunnily.github.io/2021/10/gop2pthree/</link>
      <pubDate>Sun, 31 Oct 2021 10:13:40 +0800</pubDate>
      
      <guid>https://zfunnily.github.io/2021/10/gop2pthree/</guid>
      <description>我想做什么 chat和echo两个例子，说明了两个节点之间的通信需要两节点在同一个局域网内，或者有一个节点有公网。 如果我两个节点分别在两个NAT下面, 都在各自的局域网内，则需要有一个中继服务，这个服务做</description>
    </item>
    
    <item>
      <title>Go-libp2p二 | echo例子</title>
      <link>https://zfunnily.github.io/2021/10/gop2ptwo/</link>
      <pubDate>Fri, 29 Oct 2021 11:15:42 +0800</pubDate>
      
      <guid>https://zfunnily.github.io/2021/10/gop2ptwo/</guid>
      <description>go-libp2p的echo例子分析 进入目录go-libp2p/examples/echo/, 编译 go build 先看README.md， 可以了解到使用echo的方式: 终端B 1 2 3 4 5 6 7 $ ./echo -l 3001 2021/10/28 11:25:33 I am /ip4/127.0.0.1/tcp/3001/p2p/QmTu8sxDi3fSjz9ZMvkAj3qA9YAoGskroEnyLz2ZvfTBhX 2021/10/28 11:25:33 listening</description>
    </item>
    
    <item>
      <title>Go-libp2p一 | chat例子</title>
      <link>https://zfunnily.github.io/2021/10/gop2pone/</link>
      <pubDate>Thu, 28 Oct 2021 14:40:02 +0800</pubDate>
      
      <guid>https://zfunnily.github.io/2021/10/gop2pone/</guid>
      <description>代码下载 git clone https://github.com/libp2p/go-libp2p.git chat实例分析 进入目录go-libp2p/examples/chat/, 编译 go build 先看README.md， 可以了解到使用chat的方式 在节点 B 1 2 3 4 5 6 7 $ ./chat -sp 3001 2021/10/28 11:01:25 Run &amp;#39;./chat -d /ip4/127.0.0.1/tcp/3001/p2p/QmXgEXt4CiqmVmDhPPQnyVkoj3Bsx3Nggq57PPsk5tLNTs&amp;#39; on another console. 2021/10/28 11:01:25</description>
    </item>
    
    <item>
      <title>Blog | 新的开始</title>
      <link>https://zfunnily.github.io/2021/10/blogmigration/</link>
      <pubDate>Fri, 22 Oct 2021 19:01:20 +0800</pubDate>
      
      <guid>https://zfunnily.github.io/2021/10/blogmigration/</guid>
      <description>迁移博客 我是从18年开始写一些东西，先写在看云笔记上，后面东西越来越多。写出来的东西比较零散. 20年下半年入职新公司，开始在csdn上写博客，今年我准备尝试使用个人博客，hugo和gitPage结合部</description>
    </item>
    
    <item>
      <title>Skynet源码赏析四 | 消息调度</title>
      <link>https://zfunnily.github.io/2021/10/four/</link>
      <pubDate>Thu, 21 Oct 2021 10:06:39 +0800</pubDate>
      
      <guid>https://zfunnily.github.io/2021/10/four/</guid>
      <description>服务间消息流转 发送消息 数据结构message_queue *q是次级消息队列，每个服务都有与之绑定的唯一一个次级消息队列。当我们在lua层，调用skynet.send(...), 或者调用skynet.c</description>
    </item>
    
    <item>
      <title>Skynet源码赏析三 | 服务启动</title>
      <link>https://zfunnily.github.io/2021/10/skynetthree/</link>
      <pubDate>Wed, 20 Oct 2021 11:26:07 +0800</pubDate>
      
      <guid>https://zfunnily.github.io/2021/10/skynetthree/</guid>
      <description>skynet启动一个C服务 查看怎么启动C服务的最好的办法是打断点，看源码。 启动logger日志服务 我拿日志服务来举例子，怎么启动日志服务的呢？ 传参数name = &amp;quot;logger&amp;quot;, param = null， struct skynet_context *ctx = skynet_context_new(config-&amp;gt;logservice, config-&amp;gt;logger);; 从module</description>
    </item>
    
    <item>
      <title>Skynet源码赏析二 | 基础数据结构</title>
      <link>https://zfunnily.github.io/2021/10/skynettwo/</link>
      <pubDate>Tue, 19 Oct 2021 18:47:45 +0800</pubDate>
      
      <guid>https://zfunnily.github.io/2021/10/skynettwo/</guid>
      <description>module管理模块 我们所写的C服务编译成.so文件后放在cpath变量路径下，程序会加载路径cpath = root..&amp;quot;cservice/?.so&amp;quot;下的.so文件，通过static</description>
    </item>
    
    <item>
      <title>Skynet源码赏析一 | 启动初始化的过程</title>
      <link>https://zfunnily.github.io/2021/10/skynetone/</link>
      <pubDate>Tue, 19 Oct 2021 17:28:45 +0800</pubDate>
      
      <guid>https://zfunnily.github.io/2021/10/skynetone/</guid>
      <description>入口文件 skynet_main.c 加载配置 1 2 3 4 5 6 7 8 9 struct skynet_config config; config.thread = optint(&amp;#34;thread&amp;#34;,8); config.module_path = optstring(&amp;#34;cpath&amp;#34;,&amp;#34;./cservice/?.so&amp;#34;); config.harbor = optint(&amp;#34;harbor&amp;#34;, 1); config.bootstrap = optstring(&amp;#34;bootstrap&amp;#34;,&amp;#34;snlua bootstrap&amp;#34;); config.daemon = optstring(&amp;#34;daemon&amp;#34;, NULL); config.logger = optstring(&amp;#34;logger&amp;#34;, NULL); config.logservice = optstring(&amp;#34;logservice&amp;#34;, &amp;#34;logger&amp;#34;); config.profile = optboolean(&amp;#34;profile&amp;#34;, 1); 从上述代码可以看到，配置都已经加载到变量struct skynet_config config;中了。 初始化 初始化skynet</description>
    </item>
    
    <item>
      <title>Golang | 调用带有后台进程shell脚本可能会被挂起</title>
      <link>https://zfunnily.github.io/2021/10/shell/</link>
      <pubDate>Wed, 13 Oct 2021 17:15:45 +0800</pubDate>
      
      <guid>https://zfunnily.github.io/2021/10/shell/</guid>
      <description>起因 今天用Golang写一个调用外部shell脚本的程序，使用 exec.Command方法，这段脚本代码中包含了一个后台任务语句。 结果发生了一个问题：cmd.Output 始终不会返回，一直挂起。导致我</description>
    </item>
    
    <item>
      <title>FPS游戏 | 实现移动功能</title>
      <link>https://zfunnily.github.io/2021/09/move/</link>
      <pubDate>Sun, 12 Sep 2021 20:43:34 +0800</pubDate>
      
      <guid>https://zfunnily.github.io/2021/09/move/</guid>
      <description>三种实现FPS Controller的区别 Transform Translate 允许移动物理，但无物理碰撞 Rigid body + Capsule Collider 符合物理学 不会鬼穿墙 无法滞空运动 可与Physics Object 交互 Charactor Controller 不会鬼穿墙 提供的API相对多 无法与Physic objects</description>
    </item>
    
    <item>
      <title>免费Music</title>
      <link>https://zfunnily.github.io/2021/09/music/</link>
      <pubDate>Wed, 08 Sep 2021 14:47:14 +0800</pubDate>
      
      <guid>https://zfunnily.github.io/2021/09/music/</guid>
      <description>介绍一个可以免费听音乐的方法 环境 docker mac 安装 $ docker run -d -p 264:264 -p 9000:9000 -v $dir_name:/var/www/html/cache --name music oldiy/music-player-docker $dir_name 是 你自己宿主机的目录。可以自定义 访问：127.0.0.1:264 就可以放心使用， 同事推荐的，贼好用。</description>
    </item>
    
    <item>
      <title>Unity3D | Transform类</title>
      <link>https://zfunnily.github.io/2021/09/transform/</link>
      <pubDate>Tue, 07 Sep 2021 15:55:59 +0800</pubDate>
      
      <guid>https://zfunnily.github.io/2021/09/transform/</guid>
      <description>Transform类 在unity中，把transform类理解为，transform类是在每个对象生成时自动附加的一个类。在Unity的视图中，点击Hierarchy中的对象，就可以在Inspecto</description>
    </item>
    
    <item>
      <title>Vim | 切换模式/输入法</title>
      <link>https://zfunnily.github.io/2021/09/vimchange/</link>
      <pubDate>Tue, 07 Sep 2021 10:46:58 +0800</pubDate>
      
      <guid>https://zfunnily.github.io/2021/09/vimchange/</guid>
      <description>vim 在退出输入模式的时候切换为原来的输入法 在敲代码的时候使用我们使用的英文，当遇到问题，我们需要搜索引擎的时候需要中文输入法，这个时候，自动切换输入法可以帮助我们节省手动切换输入法的时间。 跟编辑器结合，</description>
    </item>
    
    <item>
      <title>Linux | Screen</title>
      <link>https://zfunnily.github.io/2021/09/screen/</link>
      <pubDate>Tue, 07 Sep 2021 10:02:16 +0800</pubDate>
      
      <guid>https://zfunnily.github.io/2021/09/screen/</guid>
      <description>screen命令 screen 是一个非常有用的命令。应用场景： 单个 SSH 会话中使用多个 shell 窗口（会话）的能力 服务器开发，一个单独运行进程的窗口。可以避免单独再开一个窗口。 &amp;hellip; screen使用 创建一个窗口 1 $ screen -S name 执行自己</description>
    </item>
    
    <item>
      <title>Centos7.2 | gcc4.8升级为4.9</title>
      <link>https://zfunnily.github.io/2021/09/upgradegcc/</link>
      <pubDate>Wed, 01 Sep 2021 18:13:41 +0800</pubDate>
      
      <guid>https://zfunnily.github.io/2021/09/upgradegcc/</guid>
      <description>环境 CentOS 7.2.1511 Docker 我是用 docker 拉取镜像 CentOS 7.2.1511, 利用容器来作为我的开发环境。有条件的也可以用虚拟机或者实体机器。原理都一样。 1 2 $ docker $ yum update &amp;amp;&amp;amp; yum install gcc gcc-c++ make zlib-devel.x86_6 下载依赖包 升级 gcc， 下载安装包下载依赖。 1 2 3 $ wget http://ftp.gnu.org/gnu/gcc/gcc-4.9.3/gcc-4.9.3.tar.bz2 $ tar xfv gcc-4.9.3.tar.bz2 &amp;amp;&amp;amp; cd</description>
    </item>
    
    <item>
      <title>Shell | Except 使用</title>
      <link>https://zfunnily.github.io/2021/08/except/</link>
      <pubDate>Mon, 30 Aug 2021 17:13:33 +0800</pubDate>
      
      <guid>https://zfunnily.github.io/2021/08/except/</guid>
      <description>Except 参数 1 2 3 4 5 6 7 8 9 10 11 12 spawn 交互程序开始后面跟命令或者指定程序 expect 获取匹配信息匹配成功则执行expect后面的程序动作 send exp_send 用于发送指定的字符串信息 exp_continue 在expect中多次匹配就需要用到 send_user 用来打印输出 相</description>
    </item>
    
    <item>
      <title>Unity3D | UGUI</title>
      <link>https://zfunnily.github.io/2021/08/ugui/</link>
      <pubDate>Fri, 20 Aug 2021 14:15:41 +0800</pubDate>
      
      <guid>https://zfunnily.github.io/2021/08/ugui/</guid>
      <description>Text Text的属性 在 Unity 的 Hierarchy 面板上右键–&amp;gt;UI–&amp;gt;Text, 在 Inspector 面板上查看属性 属性 功能 Text 需要显示的文本 Font 显示文本的字体 如：微软雅黑，宋体等 Font Style 显示文本的样式，有普通，粗体，斜体，粗体和斜体四种</description>
    </item>
    
    <item>
      <title>Golang | redis实现分布式锁</title>
      <link>https://zfunnily.github.io/2021/06/distribute/</link>
      <pubDate>Thu, 03 Jun 2021 16:12:21 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2021/06/distribute/</guid>
      <description>概述 网上有很多Golang操作redis的例子，我使用github.com/gomodule/redigo/redis包写一个关于redis分布式锁的问题。 redis分布式锁 锁需要的几个组件 获取锁- 删</description>
    </item>
    
    <item>
      <title>Golang | redis</title>
      <link>https://zfunnily.github.io/2021/06/goredis/</link>
      <pubDate>Thu, 03 Jun 2021 15:57:14 +0800</pubDate>
      
      <guid>https://zfunnily.github.io/2021/06/goredis/</guid>
      <description>概述 网上有很多golang操作redis的例子，我使用github.com/gomodule/redigo/redis包写一个关于redis分布式锁的问题。 redis分布式锁 锁需要的几个组件 获取锁 删除</description>
    </item>
    
    <item>
      <title>Lua | next的使用</title>
      <link>https://zfunnily.github.io/2021/05/lua_next/</link>
      <pubDate>Mon, 10 May 2021 16:39:50 +0800</pubDate>
      
      <guid>https://zfunnily.github.io/2021/05/lua_next/</guid>
      <description>lua_next lua_next(L,index)：先把 表(lua栈 index所指的表), 的当前索引弹出，再把table 当前索引的值弹出，也就是先弹出 table的索引，再弹出table索引的值 举例： local t = { [&amp;quot;a&amp;quot;] = 1, [&amp;quot;b&amp;quot;]</description>
    </item>
    
    <item>
      <title>Lua | API</title>
      <link>https://zfunnily.github.io/2021/05/settopandpop/</link>
      <pubDate>Mon, 10 May 2021 15:57:03 +0800</pubDate>
      
      <guid>https://zfunnily.github.io/2021/05/settopandpop/</guid>
      <description>lua_pop和lua_settop lua_settop 我们直接来看lua_settop，文档解释 /* 设置栈的高度，如果之前的栈顶比新设置的更高，那么高出来的元素会被丢弃，反之压入nil来补足大小 假设栈里有2个元素。 如果</description>
    </item>
    
    <item>
      <title>Hugo</title>
      <link>https://zfunnily.github.io/2021/04/hugo/</link>
      <pubDate>Sat, 17 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2021/04/hugo/</guid>
      <description>hugo 我用过的静态博客有hexo、jekyll和hugo，对比起来，hugo虽然没有hexo那样丰富的插件和主题，但是hugo生成文章的速度更快。我是一名go语言爱好者，而hugo是go语言开发的, jek</description>
    </item>
    
    <item>
      <title>Golang | gomod拉取私有仓库</title>
      <link>https://zfunnily.github.io/2021/03/gomod/</link>
      <pubDate>Tue, 23 Mar 2021 16:10:02 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2021/03/gomod/</guid>
      <description>概述 在使用go mod的过程中，依赖的包往往是第三方库，当我们自定义一个包并且放在github.com私有仓库时候，按照原来的方法则会有如下问题。 get &amp;quot;gitlab.com/xxx/zz&amp;quot;: found meta tag get.metaImport{Prefix:&amp;quot;gitlab.com/xxx/zz&amp;quot;, VCS:&amp;quot;git&amp;quot;, RepoRoot:&amp;quot;https://gitlab.com/xxx/zz.git&amp;quot;} at //gitlab.com/xxx/zz?go-get=1 verifying gitlab.com/xxx/zz@v0.0.1: gitlab.com/xxx/zz@v0.0.1: reading https://sum.golang.org/lookup/gitlab.com/xxx/zz@v0.0.1: 410 Gone 这个错误是因为新版本g</description>
    </item>
    
    <item>
      <title>C/C&#43;&#43; | 八个基础排序</title>
      <link>https://zfunnily.github.io/2021/03/sort/</link>
      <pubDate>Tue, 23 Mar 2021 10:13:31 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2021/03/sort/</guid>
      <description>sort排序 冒泡排序 选择排序 插入排序 快速排序 希尔排序 堆排序 归并排序 sort排序 std::sort( )函数是库函数提供的排序函数，必须包括头文件#include &amp;lt;algorithm&amp;gt;，它使用的排序方法是类似于</description>
    </item>
    
    <item>
      <title>《仙剑奇侠传》编译运行</title>
      <link>https://zfunnily.github.io/2021/03/gamexian/</link>
      <pubDate>Sun, 21 Mar 2021 10:44:58 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2021/03/gamexian/</guid>
      <description>概述 今天在github上找到了《仙剑奇侠传》的rpg单机游戏sdlpal，sdlpal 是一个开源项目，基于sdl把仙剑奇侠传重写了一遍。 下面是我的编译过程总结。 环境 win10- sdl1.2- sdlpal- vs2017- DirectX SDK10 下载sdlpal $ git clone https://github.com.cnpmjs.org/sdlpal/sdlpal.git</description>
    </item>
    
    <item>
      <title>C/C&#43;&#43; | 实现atoi和itoa函数</title>
      <link>https://zfunnily.github.io/2021/03/atoianditoa/</link>
      <pubDate>Wed, 17 Mar 2021 16:43:20 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2021/03/atoianditoa/</guid>
      <description>题目1： 把字符串转化为整数 有整数字符串，&amp;quot;13579&amp;quot;, 和 &amp;quot;246810&amp;quot;. 请写一个函数把这两个字符串转化为整数 步骤： 先判断正负 遍历字符串，转换字符为整数 //atoi.cc #include &amp;lt;stdio.h&amp;gt; int my_atoi(char *str) { bool bmin = false; int result = 0; //先判断正</description>
    </item>
    
    <item>
      <title>协程解析二 | 云风的coroutine</title>
      <link>https://zfunnily.github.io/2021/03/coroutinetwo/</link>
      <pubDate>Wed, 10 Mar 2021 11:11:47 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2021/03/coroutinetwo/</guid>
      <description>概述 云风的coroutine是通过ucontext来控制程序运行时上下文的，我们来根据该库提供的几个接口，和一个demo来解释协程的运行原理。如果不了解ucontext的，建议先了解ucontxt 环境</description>
    </item>
    
    <item>
      <title>协程解析一 | ucontext</title>
      <link>https://zfunnily.github.io/2021/03/coroutineone/</link>
      <pubDate>Tue, 09 Mar 2021 09:43:00 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2021/03/coroutineone/</guid>
      <description>概述 最近在研究协程的实现原理，看了云风的coroutine和腾讯的开源库libco后，原来要实现一个协程库也没那么难。我先来讲讲云风的coroutine库。他使用的是 uncontext来保存程序运行上</description>
    </item>
    
    <item>
      <title>关于我</title>
      <link>https://zfunnily.github.io/about/</link>
      <pubDate>Sun, 28 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/about/</guid>
      <description>我是谁 我是一名游戏从业者, 目前在一家公司做游戏后端的工作。 地址 浙江杭州滨江区 Email 582132116@qq.com 技能 skynet框架+lua脚本 &amp;ndash; 游戏后端 C/C++ &amp;ndash; IM服务器 Golang &amp;ndash; 后端</description>
    </item>
    
    <item>
      <title>Golang | 定时器</title>
      <link>https://zfunnily.github.io/2021/02/timer/</link>
      <pubDate>Thu, 25 Feb 2021 16:02:13 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2021/02/timer/</guid>
      <description>概述 golang有三种方式实现定时器： ticker timer select Ticker 通过 time.NewTicker(d)的方式实现定时器 d := time.Duration(time.Second * 2) t1 := time.NewTicker(d) defer t1.Stop() go func() { for { &amp;lt;- t1.C fmt.Println(&amp;quot;NewTicker...&amp;quot;) } }() Timer 通过 time.NewTimer(d)的方式实现定时器 t2 := time.NewTimer(d)</description>
    </item>
    
    <item>
      <title>Lua | 解决百元买鸡的问题</title>
      <link>https://zfunnily.github.io/2021/02/chicken/</link>
      <pubDate>Wed, 24 Feb 2021 17:51:46 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2021/02/chicken/</guid>
      <description>问题 编写lua程序求解百鸡百钱问题。公鸡5元一只，母鸡3元一只，小鸡一元3只，问100元钱买100只鸡，可买公鸡、母鸡、小鸡各多少只？ 代码 ----------------------------------------------------------------------------- --公鸡5元一只，母鸡3元一只，小鸡一元3只，问100元钱买</description>
    </item>
    
    <item>
      <title>Golang | JWT身份认证</title>
      <link>https://zfunnily.github.io/2021/02/JWT/</link>
      <pubDate>Wed, 24 Feb 2021 14:22:04 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2021/02/JWT/</guid>
      <description>概述 最近要在http接口上加一个token认证，但是接口很多，有没有一个省时省力的办法来解决。token的使用流程是： 用户使用帐号密码登陆到服务器1. 服务器验证登陆成功，根据帐号密码生成token。把</description>
    </item>
    
    <item>
      <title>Lua | 调用C/C&#43;&#43;的动态库</title>
      <link>https://zfunnily.github.io/2021/02/dynamic/</link>
      <pubDate>Sat, 20 Feb 2021 11:11:51 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2021/02/dynamic/</guid>
      <description>概述 最近在学习 云风的skynet库，想自定义一个模块，目标是使用lua调用C/C++所编写的库。 当我们需要在Lua里面调用c/c++函数时，所有的函数都必须满足以下函数签名： typedef int (*lua_CFunction) (lua_State *L); 换句话说，所有的</description>
    </item>
    
    <item>
      <title>汇编 | C/C&#43;&#43;调用汇编</title>
      <link>https://zfunnily.github.io/2021/02/compilation/</link>
      <pubDate>Mon, 01 Feb 2021 14:40:51 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2021/02/compilation/</guid>
      <description>概述 我使用AT&amp;amp;T的规范，在linux上完成 C和汇编的互相调用，并使用gcc编译成可执行文件。 目标：汇编函数提供输出。类似C语言的函数 void hello_world(char* value) { printf(value); } 提供给C语言调用： int main() { hello_world(&amp;quot;hello world!\n&amp;quot;); } 搭建AT&amp;amp</description>
    </item>
    
    <item>
      <title>汇编 | AT&amp;T和Intel规范的区别</title>
      <link>https://zfunnily.github.io/2021/01/attandintel/</link>
      <pubDate>Sun, 31 Jan 2021 11:25:39 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2021/01/attandintel/</guid>
      <description>概述 常见的指令集以及汇编语言规范： x86(IA-32)、x86-64指令集(常见于PC端)，对应有2家公司发布的不同汇编语言规范： - intel公司发布的汇编语言规范，称`intel 汇编`：Window</description>
    </item>
    
    <item>
      <title>Skynet | lua-protobuf</title>
      <link>https://zfunnily.github.io/2021/01/skynetprotobuf/</link>
      <pubDate>Mon, 25 Jan 2021 14:25:07 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2021/01/skynetprotobuf/</guid>
      <description>概述 在最新的skynet中我使用的是云风的pbc库来解析protobuf，该项目中的一个文件protobuf.lua 使用了module语法在lua5.1版本中已经删除，最新的skynet是lua5.4</description>
    </item>
    
    <item>
      <title>Protobuf | 请求参数为空的案例</title>
      <link>https://zfunnily.github.io/2021/01/pbempty/</link>
      <pubDate>Fri, 22 Jan 2021 16:41:16 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2021/01/pbempty/</guid>
      <description>参数为空的grpc请求怎么定义 google protobuf已经提供了空参数 //empty.proto message Empty {&amp;lt;!-- --&amp;gt;} 使用方法，在proto文件中导入empty.proto, 定义一个请求参数和返回值为空的函数emptyfunction， 函数名字</description>
    </item>
    
    <item>
      <title>Golang | C数组转化为Golang的切片类型</title>
      <link>https://zfunnily.github.io/2021/01/goslience/</link>
      <pubDate>Fri, 22 Jan 2021 15:56:40 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2021/01/goslience/</guid>
      <description>概述 最近在巩固cgo的基础知识，在网上看到一篇Go和C之间 字符串数组、切片类型转换的文章，让我想到我之前写的一篇在go中遍历C结构体数组的文章，让我有新的方法来解决之前的问题，把C的数组转化为Go的切</description>
    </item>
    
    <item>
      <title>Skynet | echo服务</title>
      <link>https://zfunnily.github.io/2021/01/skynetecho/</link>
      <pubDate>Fri, 15 Jan 2021 16:07:51 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2021/01/skynetecho/</guid>
      <description>概述 引用云风博客的话：“skynet 是一个为网络游戏服务器设计的轻量框架。但它本身并没有任何为网络游戏业务而特别设计的部分，所以尽可以把它用于其它领域。skynet 并不是一个开箱即用的引擎，使用它需要</description>
    </item>
    
    <item>
      <title>Redis源码分析 | ziplist</title>
      <link>https://zfunnily.github.io/2021/01/ziplist/</link>
      <pubDate>Wed, 13 Jan 2021 17:52:27 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2021/01/ziplist/</guid>
      <description>概述 Redis中的List是一个有序（按加入的时序排序）的数据结构，一般有序我们会采用数组或者是双向链表，其中双向链表由于有前后指针实际上会很浪费内存。3.2版本之前采用两种数据结构作为底层实现： 压缩</description>
    </item>
    
    <item>
      <title>Redis源码解析 | VScode调试</title>
      <link>https://zfunnily.github.io/2021/01/vscodedebugredis/</link>
      <pubDate>Tue, 12 Jan 2021 14:25:29 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2021/01/vscodedebugredis/</guid>
      <description>环境 vscode- gcc5.4 ubuntu16.04 或者 ubuntu18.04 make 下载6.2版本. 我使用的是国内github镜像地址：github.com.cnpmjs.org，速度比较快。 $ git clone https://github.com.cnpmjs.org/redis/redis.git redis $ git checkout -b 6.2 remotes/origin/6.2 vscode不参与编译，只充当可视化的调试工具。 使用</description>
    </item>
    
    <item>
      <title>VScode | 调试Redis源码，指针显示的问题</title>
      <link>https://zfunnily.github.io/2021/01/vscoderedis/</link>
      <pubDate>Tue, 12 Jan 2021 14:17:22 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2021/01/vscoderedis/</guid>
      <description>缘由 使用VScode的时候，断点看到指针显示的是一串地址，而不是指针指向的对象的值。上网找了一圈，没看到vscode有对应的插件来解决这个问题。vscode有对应的语法来解决这个问题。 网上几乎都在说在</description>
    </item>
    
    <item>
      <title>Cgo | 遍历C结构体数组</title>
      <link>https://zfunnily.github.io/2021/01/cgostruct/</link>
      <pubDate>Mon, 11 Jan 2021 17:18:35 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2021/01/cgostruct/</guid>
      <description>缘由 现在有个应用场景，我们要在go中获取C结构体数组中的值。在C语言中，对于结构体数组，我们可以利用指针的偏移量来获取我们想要的值的位置。在go中我们怎么使用C指针和偏移量进行运算呢？下面的文字中C指</description>
    </item>
    
    <item>
      <title>Redis源码解析 | sds</title>
      <link>https://zfunnily.github.io/2021/01/sds/</link>
      <pubDate>Wed, 06 Jan 2021 14:20:23 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2021/01/sds/</guid>
      <description>SDS头文件及作用 sds.h: sds声明- sdsalloc.h： 为sds分配内存 源码文件sds.h中有这样一行代码 typedef char *sds; 很清晰、明了，sds其实就是char*。 最新的6.2分支的代码： struct __attribute__ ((__packed__)) sdshdr5 {&amp;lt;!-- --&amp;gt; unsigned char flags; /* 3 lsb of</description>
    </item>
    
    <item>
      <title>C/C&#43;&#43; | struct中使用char[]</title>
      <link>https://zfunnily.github.io/2021/01/chararray/</link>
      <pubDate>Tue, 05 Jan 2021 15:45:36 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2021/01/chararray/</guid>
      <description>缘由 最近在看redis的源码，刚开始看sds，看到这块代码 struct __attribute__ ((__packed__)) sdshdr5 { unsigned char flags; /* 3 lsb of type, and 5 msb of string length */ char buf[]; }; 好奇为什么使用 char buf[],而不用char *buf，找到答案记录一下。 struct中的char*</description>
    </item>
    
    <item>
      <title>Lastbattle | 游戏场景服务器SS解析</title>
      <link>https://zfunnily.github.io/2021/01/lastbattle/</link>
      <pubDate>Sat, 02 Jan 2021 23:19:58 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2021/01/lastbattle/</guid>
      <description>游戏场景服务器概况 指令对应的处理handle的文件：SSBattleMgr.cpp 创建战场 指令： eMsgToSSFromCS_CreateBattle GC服务器发往SS fromCS 收到中心服务器CS创建站场的指令，在函数INT32 CSSBattleMgr::OnMsgFromCS_CreateBattle(const char* pData, int n32DataLengt</description>
    </item>
    
    <item>
      <title>CCnet | 单线程reactor演变为多线程</title>
      <link>https://zfunnily.github.io/2020/12/%E5%8D%95%E7%BA%BF%E7%A8%8Breactor%E7%BD%91%E7%BB%9C%E5%BA%93ccnet%E6%BC%94%E5%8F%98%E4%B8%BA%E5%A4%9A%E7%BA%BF%E7%A8%8B/</link>
      <pubDate>Wed, 30 Dec 2020 09:19:41 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2020/12/%E5%8D%95%E7%BA%BF%E7%A8%8Breactor%E7%BD%91%E7%BB%9C%E5%BA%93ccnet%E6%BC%94%E5%8F%98%E4%B8%BA%E5%A4%9A%E7%BA%BF%E7%A8%8B/</guid>
      <description>[ccnet从单线程演变为多线程](#ccnet_2)- [单线程的ccnet](#ccnet_11)- [单线程的Reactor](#Reactor_24)- [主从Reactor多线程模型](#Reac</description>
    </item>
    
    <item>
      <title>Golang | sync.Mutex详解</title>
      <link>https://zfunnily.github.io/2020/12/Go-sync.Mutex%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Tue, 29 Dec 2020 13:17:18 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2020/12/Go-sync.Mutex%E8%AF%A6%E8%A7%A3/</guid>
      <description>概述 自己做的一个golang项目需要优化，优化方向是减少gpu内存的使用。同一个模型被重复加载多次，使用更多的gpu内存，也增加 sync.Mutex的使用。 优化的方向是: 减少代码量的改动- 减少gpu内</description>
    </item>
    
    <item>
      <title>五种网络IO模型总结</title>
      <link>https://zfunnily.github.io/2020/12/%E4%BA%94%E7%A7%8D%E7%BD%91%E7%BB%9CIO%E6%A8%A1%E5%9E%8B%E6%80%BB%E7%BB%93/</link>
      <pubDate>Mon, 28 Dec 2020 11:57:04 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2020/12/%E4%BA%94%E7%A7%8D%E7%BD%91%E7%BB%9CIO%E6%A8%A1%E5%9E%8B%E6%80%BB%E7%BB%93/</guid>
      <description>概述 在网络上看到很多关于阻塞IO、非阻塞IO、同步IO、异步IO的例子，总觉得写的过于复杂并且让人难以理解。于是我把我自己把这几个概念的理解写下来以供参考。 POSIX POSIX(可移植操作系统接口)把同步IO</description>
    </item>
    
    <item>
      <title>CCnet | 一个reactor单线程网络库</title>
      <link>https://zfunnily.github.io/2020/12/%E4%B8%80%E4%B8%AAreactor%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%BD%91%E7%BB%9C%E5%BA%93ccnet/</link>
      <pubDate>Sun, 27 Dec 2020 18:41:25 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2020/12/%E4%B8%80%E4%B8%AAreactor%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%BD%91%E7%BB%9C%E5%BA%93ccnet/</guid>
      <description>缘由 最近在研究陈硕的网络库muduo，是一个基于reactor架构的网络库。我对网络库的感觉是易用，但是内容庞大，依赖颇多。比如boost网络库里面的一些语法让人生畏。关于reactor和proact</description>
    </item>
    
    <item>
      <title>C/C&#43;&#43; | vector中的resize()函数 VS reserve()函数</title>
      <link>https://zfunnily.github.io/2020/12/C-vector%E4%B8%AD%E7%9A%84resize%E5%87%BD%E6%95%B0-VS-reserve%E5%87%BD%E6%95%B0/</link>
      <pubDate>Fri, 25 Dec 2020 11:04:29 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2020/12/C-vector%E4%B8%AD%E7%9A%84resize%E5%87%BD%E6%95%B0-VS-reserve%E5%87%BD%E6%95%B0/</guid>
      <description>reserve void reserve (size_type n); reserver函数用来给vector预分配存储区大小，即capacity的值 ，但是没有给这段内存进行初始化。reserve 的参数n是推荐预分配内存的大小，实际分配的可能等于或大于这个值，即</description>
    </item>
    
    <item>
      <title>Golang | 用gocolly登录B站</title>
      <link>https://zfunnily.github.io/2020/12/%E7%94%A8gocolly%E7%99%BB%E5%BD%95B%E7%AB%99/</link>
      <pubDate>Sun, 13 Dec 2020 14:51:53 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2020/12/%E7%94%A8gocolly%E7%99%BB%E5%BD%95B%E7%AB%99/</guid>
      <description>概述 gocolly是golang语言开发的爬虫包，通过gocolly来进行模拟网站的登录， 目标已经确立，开始行动。 下载 go get -u github.com/gocolly/colly 获取cookie 登录网站：https://www.bilibili.com</description>
    </item>
    
    <item>
      <title>Protobuf | 解决沾包问题</title>
      <link>https://zfunnily.github.io/2020/12/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%A4%B4%E5%92%8Cprotobuf%E8%A7%A3%E5%86%B3%E6%B2%BE%E5%8C%85%E9%97%AE%E9%A2%98/</link>
      <pubDate>Sun, 13 Dec 2020 10:22:38 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2020/12/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%A4%B4%E5%92%8Cprotobuf%E8%A7%A3%E5%86%B3%E6%B2%BE%E5%8C%85%E9%97%AE%E9%A2%98/</guid>
      <description>缘由 最近在研究一款游戏的源码。发现里面的通信协议是protobuf定义的，但还是自己定义了协议头部，类似 head + body。先解析头部里所存储的整个包的数据长度，然后再解析包剩余的数据，这样做的目的是为了防</description>
    </item>
    
    <item>
      <title>Golang | grpc</title>
      <link>https://zfunnily.github.io/2020/12/Golang%E7%9A%84grpc/</link>
      <pubDate>Sun, 13 Dec 2020 09:10:42 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2020/12/Golang%E7%9A%84grpc/</guid>
      <description>OverView gRPC是由Google主导开发的RPC框架，使用HTTP/2协议并用ProtoBuf作为序列化工具。其客户端提供Objective-C、Java接口，服务器侧则有Java、Golang、C++等接</description>
    </item>
    
    <item>
      <title>Ubuntu16.04.6 | 安装Cinnamon3.0</title>
      <link>https://zfunnily.github.io/2020/12/Ubuntu16.04.6%E5%AE%89%E8%A3%85Cinnamon3.0/</link>
      <pubDate>Tue, 01 Dec 2020 15:43:58 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2020/12/Ubuntu16.04.6%E5%AE%89%E8%A3%85Cinnamon3.0/</guid>
      <description>概述 Cinnamon[1]是Linux Mint[2]的默认桌面环境。不同于 Ubuntu 的 Unity 桌面环境，Cinnamon 是一个更加传统而优雅的桌面环境，其带有底部面板和应用菜单。由于 Cinnamon 桌面以及它类 Windows 的用户界面，许多</description>
    </item>
    
    <item>
      <title>Ubuntu下version `GLIBC_2.27‘ not found错误</title>
      <link>https://zfunnily.github.io/2020/11/Ubuntu%E4%B8%8Bversion-GLIBC_2.27-not-found%E9%94%99%E8%AF%AF/</link>
      <pubDate>Sat, 28 Nov 2020 15:03:04 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2020/11/Ubuntu%E4%B8%8Bversion-GLIBC_2.27-not-found%E9%94%99%E8%AF%AF/</guid>
      <description>version `GLIBC_2.27’ not found错误 执行strings /lib/x86_64-linux-gnu/libc.so.6 | grep GLIBC_ 结果显示如下： GLIBC_2.2.5 GLIBC_2.2.6 GLIBC_2.3 GLIBC_2.3.2 GLIBC_2.3.3 GLIBC_2.3.4 GLIBC_2.4 GLIBC_2.5 GLIBC_2.6 GLIBC_2.7 GLIBC_2.8 GLIBC_2.9 GLIBC_2.10 GLIBC_2.11 GLIBC_2.12 GLIBC_2.13 GLIBC_2.14 GLIBC_2.15 GLIBC_2.16 GLIBC_2.17 GLIBC_2.18 GLIBC_2.22 GLIBC_2.23 GLIBC_2.24 GLIBC_PRIVATE 去清华开源站点下载glibc： https://mirrors.tuna.tsinghua.edu.cn/gnu/libc/ 下载好文件后解压 tar -zxvf glibc-2.27.tar.gz 进入 glibc-2.27 目录,创</description>
    </item>
    
    <item>
      <title>Docker | 容器退出码详解</title>
      <link>https://zfunnily.github.io/2020/11/Docker%E5%AE%B9%E5%99%A8%E9%80%80%E5%87%BA%E7%A0%81%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Sat, 28 Nov 2020 13:32:57 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2020/11/Docker%E5%AE%B9%E5%99%A8%E9%80%80%E5%87%BA%E7%A0%81%E8%AF%A6%E8%A7%A3/</guid>
      <description>docker查看退出码指令 $ docker ps --filter &amp;quot;status=exited&amp;quot; $ docker inspect container-id --format=&#39;{&amp;lt;!-- --&amp;gt;{.State.ExitCode}}&#39; 常见退出码 Exit Code 0 退出代码0表示特定容器没有附加前台进程。- 该退出代码是所有其他后续退出代码的例外。- 这不一定意味着发生了不好的事情。如果开发人员想要在容</description>
    </item>
    
    <item>
      <title>Openresty二 | postman小工具</title>
      <link>https://zfunnily.github.io/2020/11/%E4%BD%BF%E7%94%A8OpenResty%E5%81%9A%E4%B8%80%E4%B8%AApostman%E5%B0%8F%E5%B7%A5%E5%85%B7/</link>
      <pubDate>Wed, 25 Nov 2020 16:30:39 +0800</pubDate>
      
      <guid>https://zfunnily.github.io/2020/11/%E4%BD%BF%E7%94%A8OpenResty%E5%81%9A%E4%B8%80%E4%B8%AApostman%E5%B0%8F%E5%B7%A5%E5%85%B7/</guid>
      <description>用到的知识点 mvc架构 模型渲染库：https://github.com/bungle/lua-resty-template resty http请求库： https://github.com/bungle/lua-resty-template 参照 mvc模型来做postman工具 配置文件说明 worker_processes 1; error_log logs/error.log; events</description>
    </item>
    
    <item>
      <title>Openresty一 | 初探</title>
      <link>https://zfunnily.github.io/2020/11/OpenResty%E5%88%9D%E6%8E%A2/</link>
      <pubDate>Mon, 23 Nov 2020 16:21:34 +0800</pubDate>
      
      <guid>https://zfunnily.github.io/2020/11/OpenResty%E5%88%9D%E6%8E%A2/</guid>
      <description>概述 OpenResty®是一个基于Nginx与 Lua 的高性能 Web 平台，其内部集成了大量精良的 Lua 库、第三方模块以及大多数的依赖项。用于方便地搭建能够处理超高并发、扩展性极高的动态 Web 应用、Web 服务和动态网关。</description>
    </item>
    
    <item>
      <title>LastBattle | 登录流程(LS &amp; BS &amp; GS)</title>
      <link>https://zfunnily.github.io/2020/11/%E6%9C%80%E5%90%8E%E4%B8%80%E7%AB%99%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90LastBattle-%E7%99%BB%E5%BD%95%E6%B5%81%E7%A8%8BLS-BS-GS/</link>
      <pubDate>Fri, 20 Nov 2020 17:27:08 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2020/11/%E6%9C%80%E5%90%8E%E4%B8%80%E7%AB%99%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90LastBattle-%E7%99%BB%E5%BD%95%E6%B5%81%E7%A8%8BLS-BS-GS/</guid>
      <description>登录流程 根据上一篇文章中的登录流程,我在工程中找到了相应的代码并记录了下来 登录服务代码解析 监听端口：49997 供BS服务连接 监听端口：49996 供客户端连接 CIocpCtrl：IOCP控制类 多线程循环</description>
    </item>
    
    <item>
      <title>LastBattle | 服务架构</title>
      <link>https://zfunnily.github.io/2020/11/%E6%9C%80%E5%90%8E%E4%B8%80%E7%AB%99%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90LastBattle-%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84/</link>
      <pubDate>Fri, 20 Nov 2020 17:24:32 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2020/11/%E6%9C%80%E5%90%8E%E4%B8%80%E7%AB%99%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90LastBattle-%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84/</guid>
      <description>服务器架构简图如下: 连线说明： 实线：表示客户端登录流程，①②③④⑤表示登录流程，详细解释见下文。- 虚线：表示服务器间的连接，虚线箭头指向监听方。 架构说明： |英文名称|简称|中文名称|功能简介|单个大区</description>
    </item>
    
    <item>
      <title>LastBattle | 安装部署笔记</title>
      <link>https://zfunnily.github.io/2020/11/%E6%9C%80%E5%90%8E%E4%B8%80%E6%88%98%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Mon, 16 Nov 2020 06:49:49 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2020/11/%E6%9C%80%E5%90%8E%E4%B8%80%E6%88%98%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2%E7%AC%94%E8%AE%B0/</guid>
      <description>环境准备 win10 服务器：vs2010 / 数据库 mysql5.7 清华大学mysql镜像网站:https://mirrors.tuna.tsinghua.edu.cn/mysql/downloads/MySQL-5.7/ 客户端</description>
    </item>
    
    <item>
      <title>Cgo | 使用libevent库实现一个定时器</title>
      <link>https://zfunnily.github.io/2020/11/cgo%E4%BD%BF%E7%94%A8libevent%E5%BA%93%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%AE%9A%E6%97%B6%E5%99%A8/</link>
      <pubDate>Fri, 13 Nov 2020 16:40:42 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2020/11/cgo%E4%BD%BF%E7%94%A8libevent%E5%BA%93%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%AE%9A%E6%97%B6%E5%99%A8/</guid>
      <description>使用libevent库作为例子 下载 &amp;amp; 编译 &amp;amp; 安装libevent $ git clone https://github.com.cnpmjs.org/libevent/libevent.git $ cd libevent &amp;amp;&amp;amp; mkdir build &amp;amp;&amp;amp; cd build $ cmake .. $ make libevent实现的定时器 // main.cpp #include &amp;quot;event.h&amp;quot; struct event ev; struct timeval tv; void time_cb(evutil_socket_t fd, short event, void *argc) { printf(&amp;quot;timer wakeup\n&amp;quot;); event_add(&amp;amp;ev, &amp;amp;tv); // reschedule timer } int main() { struct event_base *base = event_base_new(); tv.tv_sec = 2;</description>
    </item>
    
    <item>
      <title>Golang | 利用指针进行数据转换</title>
      <link>https://zfunnily.github.io/2020/11/Golang-%E5%88%A9%E7%94%A8%E6%8C%87%E9%92%88%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E8%BD%AC%E6%8D%A2/</link>
      <pubDate>Thu, 12 Nov 2020 17:19:07 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2020/11/Golang-%E5%88%A9%E7%94%A8%E6%8C%87%E9%92%88%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E8%BD%AC%E6%8D%A2/</guid>
      <description>概述 在Go语言中，Slice本质是什么呢？是一个reflect.SliceHeader结构体和这个结构体中Data字段所指向的内存。String本质是什么呢？是一个reflect.StringHead</description>
    </item>
    
    <item>
      <title>Golang | builds</title>
      <link>https://zfunnily.github.io/2020/11/go-builds/</link>
      <pubDate>Thu, 12 Nov 2020 17:15:17 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2020/11/go-builds/</guid>
      <description>概述 通常我们会给每个产品环境设置不同的配置，比如 redis 要在开发环境就连接 localhost:6379，测试环境可能连接某一个主机的 redis。 如果放在 go 里面是否可行？因为 go 是编译二进制包，也没有动态加载这</description>
    </item>
    
    <item>
      <title>Cgo | 简单使用</title>
      <link>https://zfunnily.github.io/2020/11/cgo%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Thu, 05 Nov 2020 09:45:23 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2020/11/cgo%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</guid>
      <description>使用自己的C函数 文件名：testC.go package main /* #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;stdlib.h&amp;gt; void c_print(char *str) { printf(&amp;quot;%s\n&amp;quot;, str); } */ import &amp;quot;C&amp;quot; //import “C” 必须单起一行，并且紧跟在注释行之后 import &amp;quot;unsafe&amp;quot; func main() { s := &amp;quot;Hello Cgo&amp;quot; cs := C.CString(s) //字符串映射 C.c_print(cs) //调用C函数 defer C.free(unsafe.Pointer(cs)) //释放内存 } 说明： 1、g</description>
    </item>
    
    <item>
      <title>Golang | 使用Lumberjack&#43;zap进行日志切割归档</title>
      <link>https://zfunnily.github.io/2020/11/%E4%BD%BF%E7%94%A8Lumberjack-zap%E8%BF%9B%E8%A1%8C%E6%97%A5%E5%BF%97%E5%88%87%E5%89%B2%E5%BD%92%E6%A1%A3/</link>
      <pubDate>Wed, 04 Nov 2020 12:44:03 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2020/11/%E4%BD%BF%E7%94%A8Lumberjack-zap%E8%BF%9B%E8%A1%8C%E6%97%A5%E5%BF%97%E5%88%87%E5%89%B2%E5%BD%92%E6%A1%A3/</guid>
      <description>使用Lumberjack+zap进行日志切割归档 为了添加日志切割归档功能，我们将使用第三方库Lumberjack来实现。 安装 执行下面的命令安装Lumberjack go get -u github.com/natefinch/lumberjack zap logger中加入Lumbe</description>
    </item>
    
    <item>
      <title>Vim | vimplus快捷键</title>
      <link>https://zfunnily.github.io/2020/10/vimplus%E5%BF%AB%E6%8D%B7%E9%94%AE/</link>
      <pubDate>Wed, 28 Oct 2020 09:14:28 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2020/10/vimplus%E5%BF%AB%E6%8D%B7%E9%94%AE/</guid>
      <description>插件相关 |快捷键|说明 |&amp;mdash;&amp;mdash; |,|Leader Key |&amp;lt;leader&amp;gt;n|打开 / 关闭代码资源管理器 |&amp;lt;leader&amp;gt;t|打开 / 关闭函数列表 |&amp;lt;leader&amp;gt;a|.h .cpp 文件切换 |&amp;lt;leader&amp;gt;u|转到函数声明 |&amp;</description>
    </item>
    
    <item>
      <title>Vim | 打造编C&#43;&#43;IDE</title>
      <link>https://zfunnily.github.io/2020/10/%E4%BD%BF%E7%94%A8vim%E6%89%93%E9%80%A0%E7%BC%96C-IDE/</link>
      <pubDate>Wed, 28 Oct 2020 09:11:32 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2020/10/%E4%BD%BF%E7%94%A8vim%E6%89%93%E9%80%A0%E7%BC%96C-IDE/</guid>
      <description>使用 vimplus 打造C++ IDE GitHub： https://github.com/chxuan/vimplus 支持平台： macos/linux 安装vimplus // 原来的链接， 国内速度较慢 $ git clone https://github.com/chxuan/vimplus.git ~/.vimplus // github修改为镜像的链接 $ git clone --depth=1 https://github.com.cnpmjs.org/chxuan/vimplus.git ~/.vimplus $ cd ~/.vimplus //不加sudo $ ./install.sh 设置Nerd Font 为防止vimplu</description>
    </item>
    
    <item>
      <title>Linux | 删除大量文件指令--rsync</title>
      <link>https://zfunnily.github.io/2020/10/linux%E7%B3%BB%E7%BB%9F%E5%88%A0%E9%99%A4%E5%A4%A7%E9%87%8F%E6%96%87%E4%BB%B6%E6%8C%87%E4%BB%A4-rsync/</link>
      <pubDate>Tue, 13 Oct 2020 16:29:34 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2020/10/linux%E7%B3%BB%E7%BB%9F%E5%88%A0%E9%99%A4%E5%A4%A7%E9%87%8F%E6%96%87%E4%BB%B6%E6%8C%87%E4%BB%A4-rsync/</guid>
      <description>rsync的安装 rsync安装，有些系统默认安装有该命令 ubuntu系统 sudo apt-get install rsync centos系统 sudo yum install rsync rsync参数详解 rsync提供了一些跟删除有关的参数 rsync --help | grep delete -del an alias for --delete-during --delete delete extraneous files from destination dirs --delete-before receiver deletes before</description>
    </item>
    
    <item>
      <title>CPU的核与线程-4核8线程</title>
      <link>https://zfunnily.github.io/2020/10/CPU%E7%9A%84%E6%A0%B8%E4%B8%8E%E7%BA%BF%E7%A8%8B-4%E6%A0%B88%E7%BA%BF%E7%A8%8B/</link>
      <pubDate>Mon, 12 Oct 2020 16:29:34 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2020/10/CPU%E7%9A%84%E6%A0%B8%E4%B8%8E%E7%BA%BF%E7%A8%8B-4%E6%A0%B88%E7%BA%BF%E7%A8%8B/</guid>
      <description>查看cpu信息 $ cat /proc/cpuinfo 物理CPU 物理CPU就是计算机上实际配置的CPU个数。 在linux上可以打开cat /proc/cpuinfo 来查看，其中的physical id就是每个物理CPU的ID，能找到几个physical id就代表</description>
    </item>
    
    <item>
      <title>TCP/IP | 大量TIME_WAIT对线上业务的影响</title>
      <link>https://zfunnily.github.io/2020/10/%E5%A4%A7%E9%87%8FTIME_WAIT%E5%AF%B9%E7%BA%BF%E4%B8%8A%E4%B8%9A%E5%8A%A1%E7%9A%84%E5%BD%B1%E5%93%8D/</link>
      <pubDate>Sat, 10 Oct 2020 16:46:34 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2020/10/%E5%A4%A7%E9%87%8FTIME_WAIT%E5%AF%B9%E7%BA%BF%E4%B8%8A%E4%B8%9A%E5%8A%A1%E7%9A%84%E5%BD%B1%E5%93%8D/</guid>
      <description>TCP的三次握手和四次挥手 TIME_WAIT概述 TIME_WAIT 状态： TCP 连接中，主动关闭连接的一方出现的状态；（收到 FIN 命令，进入 TIME_WAIT 状态，并返回 ACK 命令） - 保持 2 个 MSL 时间，即，4 分钟 ；（MSL 为 2 分钟） TCP 连接建立后，「</description>
    </item>
    
    <item>
      <title>Libevent | 定时器</title>
      <link>https://zfunnily.github.io/2020/09/libeventimer/</link>
      <pubDate>Wed, 16 Sep 2020 23:20:28 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2020/09/libeventimer/</guid>
      <description>libevent 实现定时器流程 首先初始化libevent库，并保存返回的指针 struct event_base * base = event_init(); 实际上这一步相当于初始化一个Reactor实例；在初始化libevent后，就可以注册事件了。 初始化事件event，设置回调函</description>
    </item>
    
    <item>
      <title>FFmpeg | 画中画和视频多宫格处理</title>
      <link>https://zfunnily.github.io/2020/09/ffmpegpicture/</link>
      <pubDate>Mon, 14 Sep 2020 18:29:33 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2020/09/ffmpegpicture/</guid>
      <description>FFmpeg生成画中画 静态画中画 将视频sub.mp4视频文件缩放成宽 480 、高 320 的视频,然后显示在 视频 input.mp4,x坐标为0,y 坐标为0 的位置 ffmpeg -re -i input.mp4 -vf &amp;quot;movie=sub.mp4, scale=480x320[test]; [in][test]overlay [out]&amp;quot; -vcodec libx264 output.flv 显示在画面的右下角，则需要用到</description>
    </item>
    
    <item>
      <title>FFmpeg | 给视频加文字和图片水印</title>
      <link>https://zfunnily.github.io/2020/09/ffmpegvideo/</link>
      <pubDate>Sat, 12 Sep 2020 12:47:57 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2020/09/ffmpegvideo/</guid>
      <description>FFmpeg给视频加上logo ffmpeg从视频中截取图像帧 ffmpeg -i inputfile.avi -r 1 -f image2 image-%05d.jpeg ffmpeg -i inputfile.avi -r 1 -s 4cif -f image2 image-%05d.jpeg ffmpeg -i inputfile.avi -r 1 -t 4 -f image2 image-%05d.jpeg ffmpeg -i inputfile.avi -r 1 -ss 01:30:14 -f image2 image-%05d.jpeg ffmpeg -i inputfile.avi -r 1 -ss 01:30:14 -vframes 120 4cif -f image2 image-%05d.jpeg -r 指定抽取的帧率，即从视频中每秒钟抽取</description>
    </item>
    
    <item>
      <title>FFmpeg | 录制摄像头和桌面数据windows</title>
      <link>https://zfunnily.github.io/2020/09/ffmpegvideow/</link>
      <pubDate>Wed, 09 Sep 2020 09:36:49 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2020/09/ffmpegvideow/</guid>
      <description>概述 FFmpeg Windows 设备操作 Windows 采集设备的主要方式是 dshow vfwcap gdigrab 其中 dshow 可以用来抓 取摄像头、采集卡、麦克风等，- vfwcap 主要用来采集摄像头类设备，- gdigrab 则是抓取 Windows 窗口程序 FFmpeg 使用 dshow 采集音视频设备 使用 dshow 枚举设备 ffmpeg -f dshow -list_devices true -i dymmy 输出 [dshow @ 000002622302e340]</description>
    </item>
    
    <item>
      <title>FFmpeg | 录制摄像头和桌面数据mac</title>
      <link>https://zfunnily.github.io/2020/08/macffmpeg/</link>
      <pubDate>Sat, 29 Aug 2020 17:20:40 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2020/08/macffmpeg/</guid>
      <description>设备枚举 查看设备列表 $ ffmpeg -hide_banner -devices Devices: D. = Demuxing supported .E = Muxing supported -- D avfoundation AVFoundation input device D lavfi Libavfilter virtual input device E sdl,sdl2 SDL2 output device 可以看到输入设备有：avfoundation，lavfi 输出设备有：sdl `` 设备采集举例： $ ffmpeg -f avfoundation -list_devices true -i &amp;quot; &amp;quot; 看到了 如下设</description>
    </item>
    
    <item>
      <title>K8S | Prometheus&#43;Grafana监控</title>
      <link>https://zfunnily.github.io/2020/08/prometheusgrafana/</link>
      <pubDate>Mon, 17 Aug 2020 13:58:35 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2020/08/prometheusgrafana/</guid>
      <description>概述 作为应用与Kubernetes的监控体系，Prometheus具备诸多的优势，如： Kubernetes默认支持,非常适合容器和微服务- 无依赖，安装方便，上手容易- 社区活跃，它不仅仅是个工具，而是生</description>
    </item>
    
    <item>
      <title>Owt-server | owt-client-javascript</title>
      <link>https://zfunnily.github.io/2020/08/owt-client-javascript/</link>
      <pubDate>Sun, 16 Aug 2020 23:04:13 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2020/08/owt-client-javascript/</guid>
      <description>概述 天气燥热，不易出门。遂研究一下owt-server，从owt-client-javascript的流程开始吧。 获取一个会议室 owt-client-javascript的时候有一个初始化房间的过程 ///owt-client-javascript/src/samples/conference/samplertcservice.js</description>
    </item>
    
    <item>
      <title>K8S | Ingress的基本使用</title>
      <link>https://zfunnily.github.io/2020/08/ingress/</link>
      <pubDate>Sat, 15 Aug 2020 00:05:15 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2020/08/ingress/</guid>
      <description>缘由 看了statefulset基础教程的基础教程，并且把环境搭建起来后。pod内部是可以连通了。但是我不知道怎么去从外部访问。在网上搜索一番，通过Ingress可以作为集群的入口。遂记录之。 结合Sta</description>
    </item>
    
    <item>
      <title>K8S | Statefluset的持久存储PVC</title>
      <link>https://zfunnily.github.io/2020/08/pvc/</link>
      <pubDate>Fri, 14 Aug 2020 17:18:58 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2020/08/pvc/</guid>
      <description>缘由 在看statefluset基础教程的时候遇到pod状态为pending kubectl describe pod web-0 日志内容是 pod has unbound immediate PersistentVolumeClaims 于是就对PV和PVC进行研究。 有给出完整的 web.yaml查看最下面的完整示例。但是我建议先把PV</description>
    </item>
    
    <item>
      <title>Linux | nsf服务的搭建和使用</title>
      <link>https://zfunnily.github.io/2020/08/nsf/</link>
      <pubDate>Fri, 14 Aug 2020 17:17:54 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2020/08/nsf/</guid>
      <description>搭建nsf服务 sudo apt install nfs-kernel-server 默认情况下，在Ubuntu 18.04上，NFS版本2是禁用的。版本3和版本4已启用。您可以通过运行以下cat命令来验证： sudo cat /proc/fs/nfsd/versions 写入 exports cat /etc/exports sudo echo /nfs/prometheus/data/ 192.168.84.75/24(rw,no_root_squash,no_all_squash,sync) &amp;gt;&amp;gt; /etc/exports sudo echo /nfs/prometheus/data/ 192.168.84.75/24(rw,no_root_squash,no_all_squash,sync) &amp;gt;&amp;gt; /etc/exports 可以设定的参数主要</description>
    </item>
    
    <item>
      <title>K8S | StatefulSet基本原理</title>
      <link>https://zfunnily.github.io/2020/08/statefulset/</link>
      <pubDate>Fri, 14 Aug 2020 16:03:41 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2020/08/statefulset/</guid>
      <description>背景 用户通过 Deployment、ReplicationController 可以方便地在 kubernetes 中部署一套高可用、可扩展的分布式无状态服务。这类应用不在本地存储数据，通过简单的负载均衡策略可实现请求分发。随</description>
    </item>
    
    <item>
      <title>K8S | coreDNS的部署安装</title>
      <link>https://zfunnily.github.io/2020/08/coredns/</link>
      <pubDate>Thu, 13 Aug 2020 18:44:28 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2020/08/coredns/</guid>
      <description>概述 CoreDNS可以在具有标准的Kube-DNS的Kubernetes集群中运行。作为Kubernetes 的插件使用，CoreDNS将从 Kubernetes集群中读取区（zone）数据。它实现了为K</description>
    </item>
    
    <item>
      <title>K8S | 创建第一个应用</title>
      <link>https://zfunnily.github.io/2020/08/firstk8s/</link>
      <pubDate>Thu, 13 Aug 2020 15:28:31 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2020/08/firstk8s/</guid>
      <description>使用k8s部署第一个应用 创建一个nginx.yaml文件 apiVersion: v1 kind: Pod metadata: name: nginx # 指定 label，便于检索 labels: app: nginx spec: containers: - name: nginx # 指定镜像 image: nginx:alpine # 指定暴露端口 ports: - containerPort: 80 --- # 创建网络服务 apiVersion: v1 kind: Service metadata: name: kube-node-service labels: name: kube-node-service spec: type: NodePort #这里代表</description>
    </item>
    
    <item>
      <title>Licod | 安装和配置</title>
      <link>https://zfunnily.github.io/2020/08/licode/</link>
      <pubDate>Sun, 09 Aug 2020 09:34:36 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2020/08/licode/</guid>
      <description>拉取docker镜像并运行 licode官方提供了配置好的docker镜像，使用以下命令拉下来跑就行。 docker run --name licode -p 3000:3000 -p $MIN_PORT-$MAX_PORT:30000-30050/udp -p 3001:3001 -p 8080:8080 -e &amp;quot;MIN_PORT=30000&amp;quot; -e &amp;quot;MAX_PORT=30050&amp;quot; -e &amp;quot;PUBLIC_IP=your_ip_address&amp;quot; lynckia/licode 注意命令里的PUBLIC_IP要改为服务器的公网IP。 配置好之</description>
    </item>
    
    <item>
      <title>Docker | 远程访问加密</title>
      <link>https://zfunnily.github.io/2020/08/dockersecret/</link>
      <pubDate>Fri, 07 Aug 2020 07:56:52 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2020/08/dockersecret/</guid>
      <description>docker的远程访问 方法一 ：编辑docker.service文件 编辑docker.service文件 sudo vim /lib/systemd/system/docker.service 修改ExecStart行为下面内容 ExecStart=/usr/bin/dockerd -H tcp://0.0.0.0:2375 -H unix://var/run/docker.sock 重新加载docker配置 sudo systemctl daemon-reload // 1，加载dock</description>
    </item>
    
    <item>
      <title>Docker | web管理界面portainer</title>
      <link>https://zfunnily.github.io/2020/08/dockerweb/</link>
      <pubDate>Fri, 07 Aug 2020 07:54:43 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2020/08/dockerweb/</guid>
      <description>拉取镜像 $ docker pull portainer/portainer 运行启动portainer docker run -d -p 9000:9000 -v /var/run/docker.sock:/var/run/docker.sock -v /home/docker/portainer:/data --name portainer --restart=always portainer/portainer admin bigant.cn 汉化 Portainer-CN.zip 百度云盘: https://pan.baidu.com/s/13ra6jXHR_7vajLLlf5GVEw 提取码: nzue 新建文件夹命名为public，把Portainer-CN.zip解压至里面。 2、public文件夹传</description>
    </item>
    
    <item>
      <title>K8S | 集群资源监控 heapster</title>
      <link>https://zfunnily.github.io/2020/08/heapster/</link>
      <pubDate>Thu, 06 Aug 2020 09:06:05 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2020/08/heapster/</guid>
      <description>安装heapster的原因 查看dashboard状态 $ sudo kubectl get pods --all-namespaces | grep dashboard kubernetes-dashboard dashboard-metrics-scraper-6b4884c9d5-mvnb9 1/1 Running 0 40m kubernetes-dashboard kubernetes-dashboard-d7f7f565d-zhpsc 1/1 Running 0 40m 查看dashboard的日志 $ sudo kubectl logs -f -n kubernetes-dashboard kubernetes-dashboard-d7f7f565d-zhpsc 日志遇到这样的情况 No metric client provided. Skipping metrics. 2020/08/03 09:02:22 [2020-08-03T09:02:22Z] Outcoming response to 192.168.84.241:40086 with 200 status code 2020/08/03 09:02:23 Metric client health</description>
    </item>
    
    <item>
      <title>K8S | Dashboard界面管理</title>
      <link>https://zfunnily.github.io/2020/08/dashboard/</link>
      <pubDate>Thu, 06 Aug 2020 09:04:14 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2020/08/dashboard/</guid>
      <description>安装部署Dashboard 通过一下命令来部署, recommended.yaml $ sudo kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v2.0.0/aio/deploy/recommended.yaml https://raw.githubusercontent.com/kubernetes/dashboard/v2.0.0/aio/depl</description>
    </item>
    
    <item>
      <title>K8S | 安装</title>
      <link>https://zfunnily.github.io/2020/08/k8sinstall/</link>
      <pubDate>Wed, 05 Aug 2020 10:00:40 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2020/08/k8sinstall/</guid>
      <description>安装k8s前的准备工作 环境 ubuntu18.04 docker 关闭 swap 暂时关闭 $ swapoff -a 永久关闭 注释掉这一行 sudo vim /etc/fstab # /swapfile none swap sw 0 0 重启机器 sudo reboot docker 的配置 安装完成之后需要进行一些配置，包括 切换docker下载源为国内镜像站 以及 修改cgroups</description>
    </item>
    
    <item>
      <title>Owt-server | 编译运行</title>
      <link>https://zfunnily.github.io/2020/08/owtservercomplie/</link>
      <pubDate>Wed, 05 Aug 2020 09:47:22 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2020/08/owtservercomplie/</guid>
      <description>概述 owt是一套完整的webrtc视频会议系统。包含的功能模块有： 视频会议1. p2p 服务器是owt-server通过nodejs编写的webrtc信令。依赖是licode。licode依赖webrtc。 客</description>
    </item>
    
    <item>
      <title>归档</title>
      <link>https://zfunnily.github.io/archives/</link>
      <pubDate>Fri, 17 Apr 2020 20:43:57 +0800</pubDate>
      
      <guid>https://zfunnily.github.io/archives/</guid>
      <description></description>
    </item>
    
    <item>
      <title>搜索</title>
      <link>https://zfunnily.github.io/search/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/search/</guid>
      <description></description>
    </item>
    
  </channel>
</rss>
