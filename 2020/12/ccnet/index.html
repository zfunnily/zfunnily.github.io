<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><title>CCnet | 单线程reactor演变为多线程 | Zzz记忆</title><meta property="og:title" content="CCnet | 单线程reactor演变为多线程 - Zzz记忆"><meta property="og:type" content="article"><meta name=color-scheme content="light dark"><meta property="article:published_time" content="2020-12-30T09:19:41+08:00"><meta property="article:modified_time" content="2022-06-21T11:17:04+08:00"><meta name=Keywords content="skynet开发,skynet源码解析,skynet框架分析,golang,C++,游戏服务器,lua开发 ,IM服务器"><meta name=description content="CCnet | 单线程reactor演变为多线程"><meta name=author content="留白"><meta property="og:url" content="https://blog.rakfree.tk/2020/12/ccnet/"><link rel="shortcut icon" href=/favicon.ico type=image/x-icon><link rel=stylesheet href=/css/normalize.css><link rel=stylesheet href=/css/style.css><script type=text/javascript src=/js/jquery.js></script>
<link href=/js/jquery.fancybox.css rel=stylesheet><link rel=stylesheet type=text/css href=/css/bilibili.css><script id=LA_COLLECT src=/js/js-sdk-pro.min.js></script>
<script>LA.init({id:"JXzIfjoKHVwu0mwG",ck:"JXzIfjoKHVwu0mwG"})</script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><a id=logo href=https://blog.rakfree.tk>Zzz记忆</a><div id=quotes class=description></div></div><div><nav id=nav-menu class=clearfix><a class=current href=https://blog.rakfree.tk>首页</a>
<a href=https://blog.rakfree.tk/thinking/ title=随想>随想</a>
<a href=https://blog.rakfree.tk/archives/ title=归档>归档</a>
<a href=https://blog.rakfree.tk/about/ title=关于>关于</a>
<a href=https://blog.rakfree.tk/search/ title=搜索>搜索</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><style type=text/css>.post-toc{position:fixed;width:200px;margin-left:-210px;padding:5px 10px;font-family:Athelas,STHeiti,Microsoft Yahei,serif;font-size:12px;border:1px solid rgba(0,0,0,7%);border-radius:5px;background-color:rgba(255,255,255,.98);background-clip:padding-box;-webkit-box-shadow:1px 1px 2px rgba(0,0,0,.125);box-shadow:1px 1px 2px rgba(0,0,0,.125);word-wrap:break-word;white-space:nowrap;-webkit-box-sizing:border-box;box-sizing:border-box;z-index:999;cursor:pointer;max-height:70%;overflow-y:auto;overflow-x:hidden}.post-toc .post-toc-title{width:100%;margin:0 auto;font-size:20px;font-weight:400;text-transform:uppercase;text-align:center}.post-toc .post-toc-content{font-size:15px}.post-toc .post-toc-content>nav>ul{margin:10px 0}.post-toc .post-toc-content ul{padding-left:20px;list-style:square;margin:.5em;line-height:1.8em}.post-toc .post-toc-content ul ul{padding-left:15px;display:none}@media print,screen and (max-width:1057px){.post-toc{display:none}}</style><div class=post-toc style=position:absolute;top:188px;mix-blend-mode:difference><h2 class=post-toc-title>文章目录</h2><div class=post-toc-content><nav id=TableOfContents><ul><li><a href=#ccnet从单线程演变为多线程>ccnet从单线程演变为多线程</a></li><li><a href=#单线程的ccnet>单线程的ccnet</a></li><li><a href=#单线程的reactor>单线程的Reactor</a></li><li><a href=#主从reactor多线程模型>主从Reactor多线程模型</a></li><li><a href=#多线程的ccnet>多线程的ccnet</a></li></ul></nav></div></div><script type=text/javascript>$(document).ready(function(){if(e=$(".post-toc"),e.length){t=$("#main").offset().left,t<220&&e.css({width:t-10,"margin-left":0-t});var e,t,n=e.offset().top-20,s={start:{position:"absolute",top:n},process:{position:"fixed",top:20}};$(window).scroll(function(){var t=$(window).scrollTop();t<n?e.css(s.start):e.css(s.process)})}})</script><article class=post><header><h1 class=post-title>CCnet | 单线程reactor演变为多线程</h1></header><date class="post-meta meta-date">2020年12月30日</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=/categories/%E7%BC%96%E7%A8%8B>编程</a></span>
<span class=meta-category><a href=/categories/%E7%BC%96%E7%A8%8B.C>编程.C</a></span>
<span class=meta-category><a href=/categories/%E7%BC%96%E7%A8%8B.%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B>编程.网络编程</a></span></div><div class=post-content><h2 id=ccnet从单线程演变为多线程>ccnet从单线程演变为多线程</h2><p>ccnet现状：</p><ul><li>epoll</li><li>linux平台</li><li>事件循环</li><li>单线程</li><li>reactor</li><li>监听和新连接的事件都在主线程中</li></ul><h2 id=单线程的ccnet>单线程的ccnet</h2><p><a data-fancybox=gallery href=https://img-blog.csdnimg.cn/img_convert/98fb4a422ca29f30211176d1b81489fd.png><img class=mx-auto alt=98fb4a422ca29f30211176d1b81489fd.png src=https://img-blog.csdnimg.cn/img_convert/98fb4a422ca29f30211176d1b81489fd.png></a><br><code>ccnet</code>的单线程的角色：</p><ul><li><code>EventLoop</code>: 整个事件循环。</li><li><code>EPollPoller</code>: 负责事件的收集。</li><li><code>Channel</code>：负责事件的分发。</li><li><code>Acceptor</code>：处理客户端新连接，绑定监听回调时间。</li><li><code>TcpConnection</code>: 包含<code>EventLoop</code>组件，<code>Channel</code>组件，接收缓冲区和发送缓冲区，负责数据的收发。</li><li><code>TcpServer</code>：包含<code>EventLoop</code>组件，<code>Acceptor</code>组件，客户端连接<code>map</code>，还有回调接口</li><li><code>Buffer</code>： 缓冲区</li></ul><p>*<code>ccnet</code>的单线程模型只是对epoll进行了封装，然后根据reactor模型在代码上进行了组件的区分，但是整体操作还是单线程，不能充分利用硬件资源。<code>TcpServer</code>的回调函数中，数据接收和业务处理在同一条线程中。</p><h2 id=单线程的reactor>单线程的Reactor</h2><p><a data-fancybox=gallery href=https://img-blog.csdnimg.cn/img_convert/e2f3cbeb7e1fdd730f024e3cbf719806.png><img class=mx-auto alt=e2f3cbeb7e1fdd730f024e3cbf719806.png src=https://img-blog.csdnimg.cn/img_convert/e2f3cbeb7e1fdd730f024e3cbf719806.png></a><br>Reactor模型中定义的三种角色：</p><ul><li>Reactor：负责监听和分配事件，将I/O事件分派给对应的Handler。新的事件包含连接建立就绪、读就绪、写就绪等。</li><li>Acceptor：处理客户端新连接，并分派请求到处理器中。</li><li>Handler：将自身与事件绑定，执行非阻塞读/写任务。</li></ul><p>单线程<code>reactor</code>的消息处理流程：</p><ul><li><code>Reactor</code>通过 <code>select/poll/epoll</code> 监控连接事件，通过<code>dispatch</code>进行分发</li><li>如果是连接建立的事件，则由<code>acceptor</code>处理，并创建<code>handler</code>处理后续事件。</li><li>如果不是建立连接事件，则<code>Reactor</code>会分发调用<code>Handler</code>来响应。</li><li><code>handler</code>会完成<code>read</code>->业务处理-><code>send</code>的完整业务流程。</li></ul><p><code>Reactor</code>单线程模型只是在代码上进行了组件的区分，但是整体操作还是单线程，不能充分利用硬件资源。<code>handler</code>业务处理部分没有异步。</p><p>对于一些小容量应用场景，可以使用单<code>Reactor</code>单线程模型。但是对于高负载、大并发的应用场景却不合适，主要原因如下：</p><ul><li>即便<code>Reactor</code>线程的CPU负荷达到100%，也无法满足海量消息的编码、解码、读取和发送。</li><li>当<code>Reactor</code>线程负载过重之后，处理速度将变慢，这会导致大量客户端连接超时，超时之后往往会进行重发，这更加重<code>Reactor</code>线程的负载，最终会导致大量消息积压和处理超时，成为系统的性能瓶颈。</li><li>一旦<code>Reactor</code>线程意外中断或者进入死循环，会导致整个系统通信模块不可用，不能接收和处理外部消息，造成节点故障。</li></ul><h2 id=主从reactor多线程模型>主从Reactor多线程模型</h2><p><a data-fancybox=gallery href=https://img-blog.csdnimg.cn/img_convert/3101015a895e4b2ac6745eaa0af0cee9.png><img class=mx-auto alt=3101015a895e4b2ac6745eaa0af0cee9.png src=https://img-blog.csdnimg.cn/img_convert/3101015a895e4b2ac6745eaa0af0cee9.png></a><br>消息处理流程：</p><ul><li>从主线程池中随机选择一个<code>Reactor</code>线程作为<code>acceptor</code>线程，用于绑定监听端口，接收客户端连接</li><li><code>acceptor</code>线程接收客户端连接请求之后创建新的<code>SocketChannel</code>，将其注册到主线程池的其它<code>Reactor</code>线程上。</li><li>步骤2完成之后，业务层的链路正式建立，将<code>SocketChannel</code>从主线程池的Reactor线程的多路复用器上摘除，重新注册到<code>SubReactor</code>线程池的线程上，并创建一个<code>Handler</code>用于处理各种<strong>读写事件</strong></li><li>当有新的事件发生时，<code>SubReactor</code>会调用连接对应的<code>Handler</code>进行响应</li><li><code>Handler</code>通过<code>Read</code>读取数据后，会分发给后面的<code>Worker</code>线程池进行业务处理</li><li><code>Worker</code>线程池会分配独立的线程完成真正的业务处理，如何将响应结果发给Handler进行处理</li><li><code>Handler</code>收到响应结果后通过<code>Send</code>将响应结果返回给<code>Client</code></li></ul><h2 id=多线程的ccnet>多线程的ccnet</h2><p><a data-fancybox=gallery href=https://img-blog.csdnimg.cn/img_convert/12df821b4bd49ee8aa39226e997e3303.png><img class=mx-auto alt=12df821b4bd49ee8aa39226e997e3303.png src=https://img-blog.csdnimg.cn/img_convert/12df821b4bd49ee8aa39226e997e3303.png></a><br><a data-fancybox=gallery href=https://img-blog.csdnimg.cn/img_convert/c3c41423ed93f958253e514ba031e737.png><img class=mx-auto alt=c3c41423ed93f958253e514ba031e737.png src=https://img-blog.csdnimg.cn/img_convert/c3c41423ed93f958253e514ba031e737.png></a><br>根据主从<code>Reactor</code>多线程模型，可以想到<code>ccnet</code>单线程模型中还缺少事件循环线程池<code>EventLoopThreadPool</code>组件和<strong>worker线程池</strong>，<code>EventLoopThreadPool</code>顾名思义，每个线程里都有一个事件循环。<code>ccnet</code>没有worker线程池。<br></p><p>可以把<code>ccnet</code>的单线程模型中 <code>TcpServer</code>组件修改一下，因为他包含事件循环<code>EventLoop</code>组件<code>和Acceptor</code>组件，也绑定了 <code>Acceptor</code>的新连接事件回调，<code>TcpServer</code>一个 <code>ccnet</code>多线程模型所需组件的集合，他还需要的组件如下：</p><ul><li><code>EventLoopThread</code>: on loop peer thread，负责开启一个线程一个事件循环。</li><li><code>EventLoopThreadPool</code>: 是事件循环线程池。</li><li><code>TcpServer</code>: 增加<code>EventLoopThreadPool</code>组件。
修改<code>TcpServer.cc</code>的代码：</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>void</span> TcpServer<span style=color:#f92672>::</span>newConnection(<span style=color:#66d9ef>int</span> sockfd, <span style=color:#66d9ef>const</span> TcpAddr<span style=color:#f92672>&amp;</span> peerAddr)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>    EventLoop <span style=color:#f92672>*</span>io_loop <span style=color:#f92672>=</span> thread_pool_<span style=color:#f92672>-&gt;</span>getNextLoop(); <span style=color:#75715e>//增加的行
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    TcpConnectionPtr <span style=color:#a6e22e>conn</span>(new TcpConnection(io_loop,  <span style=color:#75715e>//修改的行
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                                          connName,
</span></span><span style=display:flex><span>                                          sockfd,
</span></span><span style=display:flex><span>                                          localaddr,
</span></span><span style=display:flex><span>                                          peerAddr));
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>    io_loop<span style=color:#f92672>-&gt;</span>runInLoop(std<span style=color:#f92672>::</span>bind(<span style=color:#f92672>&amp;</span>TcpConnection<span style=color:#f92672>::</span>connectEstablished, conn));<span style=color:#75715e>//修改的行
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>修改<code>TcpServer.h</code>代码：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>TcpServer</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>    <span style=color:#75715e>//thread pool
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    std<span style=color:#f92672>::</span>shared_ptr<span style=color:#f92672>&lt;</span>EventLoopThreadPool<span style=color:#f92672>&gt;</span> thread_pool_;
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>修改example中的<code>EchoServer.cc</code>代码：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>server_.setNumThreads(<span style=color:#ae81ff>4</span>); <span style=color:#75715e>//设置线程数量
</span></span></span></code></pre></div><p>详细代码请参考：github: <a href=https://github.com/zfunnily/ccnet>https://github.com/zfunnily/ccnet</a></p><h4 align=center>--完--</h4></div><div class=post-archive><ul class=post-copyright><li><strong>原文作者：</strong>
<a rel=author href=https://blog.rakfree.tk>留白</a></li><li style=word-break:break-all><strong>原文链接：</strong>
<a href=https://blog.rakfree.tk/2020/12/ccnet/>https://blog.rakfree.tk/2020/12/ccnet/</a></li><li style=word-break:break-all><strong>更新时间：</strong>2022-06-21 11:17:04</li><li><strong>本文声明：</strong>转载请标记原文作者及链接</li></ul></div><br><div class=post-archive><h2>See Also</h2><ul class=listing><li><a href=/2020/12/syncmutex/>Golang | sync.Mutex详解</a></li><li><a href=/2020/12/iomodels/>五种网络IO模型总结</a></li><li><a href=/2020/12/ccnetone/>CCnet | 一个reactor单线程网络库</a></li><li><a href=/2020/12/reserve/>C++ | vector中的resize()函数 VS reserve()函数</a></li><li><a href=/2020/12/gocolly/>Golang | 用gocolly登录B站</a></li></ul></div><div class="post-meta meta-tags">没有标签</div></article><div id=cusdis_thread data-host=https://cusdis-vercel-five.vercel.app data-app-id=01429b04-b016-4c60-99b1-2e11e67ec4c1 data-page-id=a91efbb04f00a45a07fb22cf34852956 data-page-url=https://blog.rakfree.tk/2020/12/ccnet/ data-page-title="CCnet | 单线程reactor演变为多线程"></div><script async defer src=https://cusdis-vercel-five.vercel.app/js/cusdis.es.js></script></div><footer id=footer><div>&copy; 2022 <a href=https://blog.rakfree.tk>Zzz记忆 By 留白</a></div><br><div><div class=github-badge><a href=https://gohugo.io/ target=_black rel=nofollow><span class=badge-subject>Powered by</span><span class="badge-value bg-blue">Hugo</span></a></div><div class=github-badge><a href=https://www.flysnow.org/ target=_black><span class=badge-subject>Design by</span><span class="badge-value bg-brightgreen">飞雪无情</span></a></div><div class=github-badge><a href=https://github.com/flysnow-org/maupassant-hugo target=_black><span class=badge-subject>Theme</span><span class="badge-value bg-yellowgreen">Maupassant</span></a></div></div><div><script id=LA-DATA-WIDGET crossorigin=anonymous src="https://v6-widget.51.la/v6/JXzIfjoKHVwu0mwG/quote.js?theme=0&f=12"></script></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[["$","$"]],processEscapes:!0}}</script><script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script><script src=/js/jquery.fancybox.min.js></script>
<a id=rocket href=#top></a>
<script type=text/javascript src='/js/totop.js?v=0.0.0' async></script></div><div id=secondary><section class=widget><form id=search action=https://blog.rakfree.tk/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=Search>
<input type=hidden name=sitesearch value=https://blog.rakfree.tk>
<button type=submit class="submit icon-search"></button></form></section><section class=widget><h3 class=widget-title>最近文章</h3><ul class=widget-list><li><a href=https://blog.rakfree.tk/2022/05/baidu/ title="百度网盘不限速 | Aria2篇">百度网盘不限速 | Aria2篇</a></li><li><a href=https://blog.rakfree.tk/2022/05/refraction/ title="URP 不透明/半透明物体的折射">URP 不透明/半透明物体的折射</a></li><li><a href=https://blog.rakfree.tk/2022/05/shaderalpha/ title="《Unity Shader入门精要》第八章笔记 | 透明度">《Unity Shader入门精要》第八章笔记 | 透明度</a></li><li><a href=https://blog.rakfree.tk/2022/05/shaderlighting/ title="《Unity Shader入门精要》第六章笔记 | 基础光照">《Unity Shader入门精要》第六章笔记 | 基础光照</a></li><li><a href=https://blog.rakfree.tk/2022/05/shaderbase/ title="《Unity Shader入门精要》第五章笔记 | 开始shader练习">《Unity Shader入门精要》第五章笔记 | 开始shader练习</a></li></ul><h3 class=widget-title>随想</h3><ul class=widget-list><li><a href=https://blog.rakfree.tk/thinking/2022/03/shuowang/ title="无聊 & 痛苦">无聊 & 痛苦</a></li><li><a href=https://blog.rakfree.tk/thinking/2022/03/think01/ title=爬楼有感>爬楼有感</a></li><li><a href=https://blog.rakfree.tk/thinking/2022/03/weekly01/ title=老纪>老纪</a></li><li><a href=https://blog.rakfree.tk/thinking/2022/03/summarize/ title=2021焦虑总结>2021焦虑总结</a></li><li><a href=https://blog.rakfree.tk/thinking/2022/01/jx/ title=转载｜江雪：长安十日>转载｜江雪：长安十日</a></li></ul></section><section class=widget><h3 class=widget-title><a href=/categories/>分类</a></h3><ul class=widget-list><li><a href=https://blog.rakfree.tk/categories/IT/>IT (11)</a></li><li><a href=https://blog.rakfree.tk/categories/IT.Linux/>IT.Linux (10)</a></li><li><a href=https://blog.rakfree.tk/categories/%E5%8D%9A%E5%AE%A2%E8%AE%B0%E4%BA%8B/>博客记事 (7)</a></li><li><a href=https://blog.rakfree.tk/categories/%E7%A7%91%E6%99%AE/>科普 (1)</a></li><li><a href=https://blog.rakfree.tk/categories/%E7%BC%96%E7%A8%8B/>编程 (96)</a></li><li><a href=https://blog.rakfree.tk/categories/%E7%BC%96%E7%A8%8B.C/>编程.C (9)</a></li><li><a href=https://blog.rakfree.tk/categories/%E7%BC%96%E7%A8%8B.Golang/>编程.Golang (22)</a></li><li><a href=https://blog.rakfree.tk/categories/%E7%BC%96%E7%A8%8B.Lua/>编程.Lua (5)</a></li><li><a href=https://blog.rakfree.tk/categories/%E7%BC%96%E7%A8%8B.P2P/>编程.P2P (4)</a></li><li><a href=https://blog.rakfree.tk/categories/%E7%BC%96%E7%A8%8B.Unity3D/>编程.Unity3D (2)</a></li><li><a href=https://blog.rakfree.tk/categories/%E7%BC%96%E7%A8%8B.UnityShader/>编程.UnityShader (12)</a></li><li><a href=https://blog.rakfree.tk/categories/%E7%BC%96%E7%A8%8B.%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/>编程.图形学入门 (1)</a></li><li><a href=https://blog.rakfree.tk/categories/%E7%BC%96%E7%A8%8B.%E6%B1%87%E7%BC%96/>编程.汇编 (2)</a></li><li><a href=https://blog.rakfree.tk/categories/%E7%BC%96%E7%A8%8B.%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/>编程.游戏开发 (12)</a></li><li><a href=https://blog.rakfree.tk/categories/%E7%BC%96%E7%A8%8B.%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/>编程.网络编程 (4)</a></li><li><a href=https://blog.rakfree.tk/categories/%E7%BC%96%E7%A8%8B.%E9%9F%B3%E8%A7%86%E9%A2%91/>编程.音视频 (9)</a></li><li><a href=https://blog.rakfree.tk/categories/%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/>自动部署 (12)</a></li><li><a href=https://blog.rakfree.tk/categories/%E8%BD%AC%E8%BD%BD/>转载 (1)</a></li><li><a href=https://blog.rakfree.tk/categories/%E9%9A%8F%E7%AC%94/>随笔 (5)</a></li><li><a href=https://blog.rakfree.tk/categories/%E9%9A%8F%E7%AC%94.%E6%91%98%E6%8A%84/>随笔.摘抄 (2)</a></li></ul></section><section class=widget><h3 class=widget-title><a href=/tags/>标签</a></h3><div class=tagcloud><a href=https://blog.rakfree.tk/tags/URP/>URP</a>
<a href=https://blog.rakfree.tk/tags/cpu/>cpu</a>
<a href=https://blog.rakfree.tk/tags/docker/>docker</a>
<a href=https://blog.rakfree.tk/tags/except/>except</a>
<a href=https://blog.rakfree.tk/tags/ffmpeg/>ffmpeg</a>
<a href=https://blog.rakfree.tk/tags/gcc/>gcc</a>
<a href=https://blog.rakfree.tk/tags/glibc/>glibc</a>
<a href=https://blog.rakfree.tk/tags/hugo/>hugo</a>
<a href=https://blog.rakfree.tk/tags/k8s/>k8s</a>
<a href=https://blog.rakfree.tk/tags/music/>music</a>
<a href=https://blog.rakfree.tk/tags/nginx/>nginx</a>
<a href=https://blog.rakfree.tk/tags/nsf/>nsf</a>
<a href=https://blog.rakfree.tk/tags/p2p/>p2p</a>
<a href=https://blog.rakfree.tk/tags/randomquotes/>randomquotes</a>
<a href=https://blog.rakfree.tk/tags/redis/>redis</a>
<a href=https://blog.rakfree.tk/tags/rsync/>rsync</a>
<a href=https://blog.rakfree.tk/tags/screen/>screen</a>
<a href=https://blog.rakfree.tk/tags/shader/>shader</a>
<a href=https://blog.rakfree.tk/tags/shader%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/>shader学习笔记</a>
<a href=https://blog.rakfree.tk/tags/shortcodes/>shortcodes</a>
<a href=https://blog.rakfree.tk/tags/skynet/>skynet</a>
<a href=https://blog.rakfree.tk/tags/vim/>vim</a>
<a href=https://blog.rakfree.tk/tags/weekly/>weekly</a>
<a href=https://blog.rakfree.tk/tags/year/>year</a>
<a href=https://blog.rakfree.tk/tags/%E5%AE%9A%E6%97%B6%E5%99%A8/>定时器</a>
<a href=https://blog.rakfree.tk/tags/%E6%8A%BD%E5%8D%A1/>抽卡</a>
<a href=https://blog.rakfree.tk/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/>读书笔记</a>
<a href=https://blog.rakfree.tk/tags/%E9%95%BF%E5%AE%89%E5%8D%81%E6%97%A5/>长安十日</a></div></section><section class=widget><h3 class=widget-title>友情链接</h3><ul class=widget-list><li><a target=_blank href=https://github.com/zfunnily title=留白的github>留白github</a></li></ul></section><section class=widget><h3 class=widget-title>其它</h3><ul class=widget-list><li><a href=https://blog.rakfree.tk/index.xml>文章 RSS</a></li></ul></section></div></div></div></div></body></html>