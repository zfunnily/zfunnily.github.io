<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>go on 流浪花</title>
    <link>https://zfunnily.github.io/tags/go/</link>
    <description>Recent content in go on 流浪花</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Thu, 03 Jun 2021 16:12:21 +0000</lastBuildDate><atom:link href="https://zfunnily.github.io/tags/go/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Golang利用redis实现分布式锁</title>
      <link>https://zfunnily.github.io/post/csdn/golang%E5%88%A9%E7%94%A8redis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</link>
      <pubDate>Thu, 03 Jun 2021 16:12:21 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/post/csdn/golang%E5%88%A9%E7%94%A8redis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</guid>
      <description>概述 网上有很多Golang操作redis的例子，我使用github.com/gomodule/redigo/redis包写一个关于redis分布式锁的问题。 redis分布式锁 锁需要的几个组件 获取锁- 删除锁 分布式锁还需要 给锁加上唯一id (只能获取和删除自己的锁)- 给锁加上过期时间 (</description>
    </item>
    
    <item>
      <title>Go mod拉取私有仓库</title>
      <link>https://zfunnily.github.io/post/csdn/Go-mod%E6%8B%89%E5%8F%96%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93/</link>
      <pubDate>Tue, 23 Mar 2021 16:10:02 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/post/csdn/Go-mod%E6%8B%89%E5%8F%96%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93/</guid>
      <description>概述 在使用go mod的过程中，依赖的包往往是第三方库，当我们自定义一个包并且放在github.com私有仓库时候，按照原来的方法则会有如下问题。 get &amp;quot;gitlab.com/xxx/zz&amp;quot;: found meta tag get.metaImport{Prefix:&amp;quot;gitlab.com/xxx/zz&amp;quot;, VCS:&amp;quot;git&amp;quot;, RepoRoot:&amp;quot;https://gitlab.com/xxx/zz.git&amp;quot;} at //gitlab.com/xxx/zz?go-get=1 verifying gitlab.com/xxx/zz@v0.0.1: gitlab.com/xxx/zz@v0.0.1: reading https://sum.golang.org/lookup/gitlab.com/xxx/zz@v0.0.1: 410 Gone 这个错误是因为新版本go mod会对依赖包进行checksum校验，但是私有仓库对sum.golang.</description>
    </item>
    
    <item>
      <title>Golang的定时器实现方式</title>
      <link>https://zfunnily.github.io/post/csdn/golang%E7%9A%84%E5%AE%9A%E6%97%B6%E5%99%A8%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/</link>
      <pubDate>Thu, 25 Feb 2021 16:02:13 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/post/csdn/golang%E7%9A%84%E5%AE%9A%E6%97%B6%E5%99%A8%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/</guid>
      <description>概述 golang有三种方式实现定时器： ticker1. timer1. select Ticker 通过 time.NewTicker(d)的方式实现定时器 d := time.Duration(time.Second * 2) t1 := time.NewTicker(d) defer t1.Stop() go func() { for { &amp;lt;- t1.C fmt.Println(&amp;quot;NewTicker...&amp;quot;) } }() Timer 通过 time.NewTimer(d)的方式实现定时器 t2 := time.NewTimer(d) defer t2.Stop() go func() { for { &amp;lt;- t2.C fmt.Println(&amp;quot;NewTimer...&amp;quot;) } }() select 通过select的方式实现定时器： for { select { case &amp;lt;- time.After(d): fmt.Println(&amp;quot;select...&amp;quot;) } }</description>
    </item>
    
    <item>
      <title>Golang使用JWT身份认证</title>
      <link>https://zfunnily.github.io/post/csdn/Golang%E4%BD%BF%E7%94%A8JWT%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/</link>
      <pubDate>Wed, 24 Feb 2021 14:22:04 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/post/csdn/Golang%E4%BD%BF%E7%94%A8JWT%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/</guid>
      <description>概述 最近要在http接口上加一个token认证，但是接口很多，有没有一个省时省力的办法来解决。token的使用流程是： 用户使用帐号密码登陆到服务器1. 服务器验证登陆成功，根据帐号密码生成token。把token返回给客户端1. 客户端请求接口时需要带上token。服务器需要验证to</description>
    </item>
    
    <item>
      <title>Google Protobuf 请求参数为空的案例</title>
      <link>https://zfunnily.github.io/post/csdn/Google-Protobuf-%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E4%B8%BA%E7%A9%BA%E7%9A%84%E6%A1%88%E4%BE%8B/</link>
      <pubDate>Fri, 22 Jan 2021 16:41:16 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/post/csdn/Google-Protobuf-%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E4%B8%BA%E7%A9%BA%E7%9A%84%E6%A1%88%E4%BE%8B/</guid>
      <description>参数为空的grpc请求怎么定义 google protobuf已经提供了空参数 //empty.proto message Empty {&amp;lt;!-- --&amp;gt;} 使用方法，在proto文件中导入empty.proto, 定义一个请求参数和返回值为空的函数emptyfunction， 函数名字可以自定义。 //server.proto import &amp;quot;google/protobuf/empty.proto&amp;quot;; service pbservice{ rpc emptyfunction(google.protobuf.Empty) return{google.protobuf.Empty} } 以golang语言为例子，在go中对应的函数为： func</description>
    </item>
    
    <item>
      <title>Go sync.Mutex详解</title>
      <link>https://zfunnily.github.io/post/csdn/Go-sync.Mutex%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Tue, 29 Dec 2020 13:17:18 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/post/csdn/Go-sync.Mutex%E8%AF%A6%E8%A7%A3/</guid>
      <description>概述 自己做的一个golang项目需要优化，优化方向是减少gpu内存的使用。同一个模型被重复加载多次，使用更多的gpu内存，也增加 sync.Mutex的使用。优化的方向是: 减少代码量的改动- 减少gpu内存的使用，同一个模型只用加载一次 涉及的问题： sync.Mutex是传值还是传引用</description>
    </item>
    
    <item>
      <title>用gocolly登录B站</title>
      <link>https://zfunnily.github.io/post/csdn/%E7%94%A8gocolly%E7%99%BB%E5%BD%95B%E7%AB%99/</link>
      <pubDate>Sun, 13 Dec 2020 14:51:53 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/post/csdn/%E7%94%A8gocolly%E7%99%BB%E5%BD%95B%E7%AB%99/</guid>
      <description>概述 gocolly是golang语言开发的爬虫包，通过gocolly来进行模拟网站的登录，目标已经确立，开始行动。 下载 go get -u github.com/gocolly/colly 获取cookie 登录网站：https://www.bilibili.com/获取cookie： google浏览器访问bilibili- 按F12- 查看Net</description>
    </item>
    
    <item>
      <title>自定义头和protobuf解决沾包问题</title>
      <link>https://zfunnily.github.io/post/csdn/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%A4%B4%E5%92%8Cprotobuf%E8%A7%A3%E5%86%B3%E6%B2%BE%E5%8C%85%E9%97%AE%E9%A2%98/</link>
      <pubDate>Sun, 13 Dec 2020 10:22:38 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/post/csdn/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%A4%B4%E5%92%8Cprotobuf%E8%A7%A3%E5%86%B3%E6%B2%BE%E5%8C%85%E9%97%AE%E9%A2%98/</guid>
      <description>缘由 最近在研究一款游戏的源码。发现里面的通信协议是protobuf定义的，但还是自己定义了协议头部，类似 head + body。先解析头部里所存储的整个包的数据长度，然后再解析包剩余的数据，这样做的目的是为了防止沾包。我在想都用了protobuf了为啥不直接用grpc呢。一时想不出，于是我</description>
    </item>
    
    <item>
      <title>Golang的grpc</title>
      <link>https://zfunnily.github.io/post/csdn/Golang%E7%9A%84grpc/</link>
      <pubDate>Sun, 13 Dec 2020 09:10:42 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/post/csdn/Golang%E7%9A%84grpc/</guid>
      <description>OverView gRPC是由Google主导开发的RPC框架，使用HTTP/2协议并用ProtoBuf作为序列化工具。其客户端提供Objective-C、Java接口，服务器侧则有Java、Golang、C++等接口，从而为移动端（iOS/Androi）到服务器端通讯提供了一种解决方案。 当然在</description>
    </item>
    
    <item>
      <title>cgo使用libevent库实现一个定时器</title>
      <link>https://zfunnily.github.io/post/csdn/cgo%E4%BD%BF%E7%94%A8libevent%E5%BA%93%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%AE%9A%E6%97%B6%E5%99%A8/</link>
      <pubDate>Fri, 13 Nov 2020 16:40:42 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/post/csdn/cgo%E4%BD%BF%E7%94%A8libevent%E5%BA%93%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%AE%9A%E6%97%B6%E5%99%A8/</guid>
      <description>使用libevent库作为例子 下载 &amp;amp; 编译 &amp;amp; 安装libevent $ git clone https://github.com.cnpmjs.org/libevent/libevent.git $ cd libevent &amp;amp;&amp;amp; mkdir build &amp;amp;&amp;amp; cd build $ cmake .. $ make libevent实现的定时器 // main.cpp #include &amp;quot;event.h&amp;quot; struct event ev; struct timeval tv; void time_cb(evutil_socket_t fd, short event, void *argc) { printf(&amp;quot;timer wakeup\n&amp;quot;); event_add(&amp;amp;ev, &amp;amp;tv); // reschedule timer } int main() { struct event_base *base = event_base_new(); tv.tv_sec = 2; tv.tv_usec = 0; evtimer_set(&amp;amp;ev, time_cb, NULL); event_base_set(base, &amp;amp;ev); event_add(&amp;amp;ev, &amp;amp;tv); event_base_dispatch(base); event_base_free(base); } go调用libevent实现定时器 把编译好的头文件和库</description>
    </item>
    
    <item>
      <title>Golang 利用指针进行数据转换</title>
      <link>https://zfunnily.github.io/post/csdn/Golang-%E5%88%A9%E7%94%A8%E6%8C%87%E9%92%88%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E8%BD%AC%E6%8D%A2/</link>
      <pubDate>Thu, 12 Nov 2020 17:19:07 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/post/csdn/Golang-%E5%88%A9%E7%94%A8%E6%8C%87%E9%92%88%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E8%BD%AC%E6%8D%A2/</guid>
      <description>概述 在Go语言中，Slice本质是什么呢？是一个reflect.SliceHeader结构体和这个结构体中Data字段所指向的内存。String本质是什么呢？是一个reflect.StringHeader结构体和这个结构体所指向的内存。 在Go语言中，指针的本质是什么呢？是unsa</description>
    </item>
    
  </channel>
</rss>
