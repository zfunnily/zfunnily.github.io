<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>skynet on 流浪花</title>
    <link>https://zfunnily.github.io/tags/skynet/</link>
    <description>Recent content in skynet on 流浪花</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Thu, 21 Oct 2021 10:06:39 +0800</lastBuildDate><atom:link href="https://zfunnily.github.io/tags/skynet/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Skynet源码赏析四 | 消息调度</title>
      <link>https://zfunnily.github.io/post/2021/10/skynet%E5%9B%9B/</link>
      <pubDate>Thu, 21 Oct 2021 10:06:39 +0800</pubDate>
      
      <guid>https://zfunnily.github.io/post/2021/10/skynet%E5%9B%9B/</guid>
      <description>服务间消息流转 发送消息 数据结构message_queue *q是次级消息队列，每个服务都有与之绑定的唯一一个次级消息队列。当我们在lua层，调用skynet.send(...), 或者调用skynet.call(...)函数发送消息，其实调用的都是c.send(...),实际上调用的</description>
    </item>
    
    <item>
      <title>Skynet源码赏析三 | 服务启动</title>
      <link>https://zfunnily.github.io/post/2021/10/skynet%E4%B8%89/</link>
      <pubDate>Wed, 20 Oct 2021 11:26:07 +0800</pubDate>
      
      <guid>https://zfunnily.github.io/post/2021/10/skynet%E4%B8%89/</guid>
      <description>skynet启动一个C服务 查看怎么启动C服务的最好的办法是打断点，看源码。 启动logger日志服务 我拿日志服务来举例子，怎么启动日志服务的呢？ 传参数name = &amp;quot;logger&amp;quot;, param = null， struct skynet_context *ctx = skynet_context_new(config-&amp;gt;logservice, config-&amp;gt;logger);; 从modules服务模块中取出名字为 logger的服务, struct skynet_module * result = _query(name);; 如果找不到则从cpath目</description>
    </item>
    
    <item>
      <title>Skynet源码赏析二 | 基础数据结构</title>
      <link>https://zfunnily.github.io/post/2021/10/skynet%E4%BA%8C/</link>
      <pubDate>Tue, 19 Oct 2021 18:47:45 +0800</pubDate>
      
      <guid>https://zfunnily.github.io/post/2021/10/skynet%E4%BA%8C/</guid>
      <description>module管理模块 我们所写的C服务编译成.so文件后放在cpath变量路径下，程序会加载路径cpath = root..&amp;quot;cservice/?.so&amp;quot;下的.so文件，通过static void * _try_open(struct modules *m, const char * name)函数第一次打开，然后被加载到全局变量static struct modules *</description>
    </item>
    
    <item>
      <title>Skynet源码赏析一 | 启动初始化的过程</title>
      <link>https://zfunnily.github.io/post/2021/10/skynet%E4%B8%80/</link>
      <pubDate>Tue, 19 Oct 2021 17:28:45 +0800</pubDate>
      
      <guid>https://zfunnily.github.io/post/2021/10/skynet%E4%B8%80/</guid>
      <description>入口文件 skynet_main.c 加载配置 1 2 3 4 5 6 7 8 9 struct skynet_config config; config.thread = optint(&amp;#34;thread&amp;#34;,8); config.module_path = optstring(&amp;#34;cpath&amp;#34;,&amp;#34;./cservice/?.so&amp;#34;); config.harbor = optint(&amp;#34;harbor&amp;#34;, 1); config.bootstrap = optstring(&amp;#34;bootstrap&amp;#34;,&amp;#34;snlua bootstrap&amp;#34;); config.daemon = optstring(&amp;#34;daemon&amp;#34;, NULL); config.logger = optstring(&amp;#34;logger&amp;#34;, NULL); config.logservice = optstring(&amp;#34;logservice&amp;#34;, &amp;#34;logger&amp;#34;); config.profile = optboolean(&amp;#34;profile&amp;#34;, 1); 从上述代码可以看到，配置都已经加载到变量struct skynet_config config;中了。 初始化 初始化skynet_context管理模块, skynet_handle_init(config-&amp;gt;harbor);; 初始化static struct global_queue *Q消息队列, skynet_mq_init();; 初始化stat</description>
    </item>
    
    <item>
      <title>Lua调用C/C&#43;&#43;的动态库</title>
      <link>https://zfunnily.github.io/post/2021/02/Lua%E8%B0%83%E7%94%A8C-C&#43;&#43;%E7%9A%84%E5%8A%A8%E6%80%81%E5%BA%93/</link>
      <pubDate>Sat, 20 Feb 2021 11:11:51 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/post/2021/02/Lua%E8%B0%83%E7%94%A8C-C&#43;&#43;%E7%9A%84%E5%8A%A8%E6%80%81%E5%BA%93/</guid>
      <description>概述 最近在学习 云风的skynet库，想自定义一个模块，目标是使用lua调用C/C++所编写的库。 当我们需要在Lua里面调用c/c++函数时，所有的函数都必须满足以下函数签名： typedef int (*lua_CFunction) (lua_State *L); 换句话说，所有的函数必须接收一个lua_State作为参数，同时返回一个整数值。因为这个函数使用</description>
    </item>
    
    <item>
      <title>在skynet中使用lua-protobuf库</title>
      <link>https://zfunnily.github.io/post/2021/01/%E5%9C%A8skynet%E4%B8%AD%E4%BD%BF%E7%94%A8lua-protobuf%E5%BA%93/</link>
      <pubDate>Mon, 25 Jan 2021 14:25:07 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/post/2021/01/%E5%9C%A8skynet%E4%B8%AD%E4%BD%BF%E7%94%A8lua-protobuf%E5%BA%93/</guid>
      <description>概述 在最新的skynet中我使用的是云风的pbc库来解析protobuf，该项目中的一个文件protobuf.lua 使用了module语法在lua5.1版本中已经删除，最新的skynet是lua5.4版本，于是我找到了解析protobuf的lua库–lua-protobuf。在最</description>
    </item>
    
  </channel>
</rss>
