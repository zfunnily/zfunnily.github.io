<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>golang on 流浪花</title>
    <link>https://zfunnily.github.io/tags/golang/</link>
    <description>Recent content in golang on 流浪花</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Wed, 13 Oct 2021 17:15:45 +0800</lastBuildDate><atom:link href="https://zfunnily.github.io/tags/golang/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>golang调用带有后台进程shell脚本可能会被挂起</title>
      <link>https://zfunnily.github.io/post/golang/shell/</link>
      <pubDate>Wed, 13 Oct 2021 17:15:45 +0800</pubDate>
      
      <guid>https://zfunnily.github.io/post/golang/shell/</guid>
      <description>起因 今天用golang写一个调用外部shell脚本的程序，使用 exec.Command方法，这段脚本代码中包含了一个后台任务语句。 结果发生了一个问题：cmd.Output 始终不会返回，一直挂起。导致我的Go程序也挂起了。 问题还原 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 //main.go package main import ( &amp;#34;fmt&amp;#34; &amp;#34;os/exec&amp;#34; ) func</description>
    </item>
    
    <item>
      <title>golang利用redis实现分布式锁</title>
      <link>https://zfunnily.github.io/post/csdn/golang%E5%88%A9%E7%94%A8redis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</link>
      <pubDate>Thu, 03 Jun 2021 16:12:21 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/post/csdn/golang%E5%88%A9%E7%94%A8redis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</guid>
      <description>概述 网上有很多golang操作redis的例子，我使用github.com/gomodule/redigo/redis包写一个关于redis分布式锁的问题。 redis分布式锁 锁需要的几个组件 获取锁- 删除锁 分布式锁还需要 给锁加上唯一id (只能获取和删除自己的锁)- 给锁加上过期时间 (</description>
    </item>
    
    <item>
      <title>golang操作redis</title>
      <link>https://zfunnily.github.io/post/golang/go_redis/</link>
      <pubDate>Thu, 03 Jun 2021 15:57:14 +0800</pubDate>
      
      <guid>https://zfunnily.github.io/post/golang/go_redis/</guid>
      <description>概述 网上有很多golang操作redis的例子，我使用github.com/gomodule/redigo/redis包写一个关于redis分布式锁的问题。 redis分布式锁 锁需要的几个组件 获取锁 删除锁 分布式锁还需要 给锁加上唯一id (只能获取和删除自己的锁) 给锁加上过期时间 (防止</description>
    </item>
    
    <item>
      <title>golang的定时器实现方式</title>
      <link>https://zfunnily.github.io/post/csdn/golang%E7%9A%84%E5%AE%9A%E6%97%B6%E5%99%A8%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/</link>
      <pubDate>Thu, 25 Feb 2021 16:02:13 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/post/csdn/golang%E7%9A%84%E5%AE%9A%E6%97%B6%E5%99%A8%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/</guid>
      <description>概述 golang有三种方式实现定时器： ticker1. timer1. select Ticker 通过 time.NewTicker(d)的方式实现定时器 d := time.Duration(time.Second * 2) t1 := time.NewTicker(d) defer t1.Stop() go func() { for { &amp;lt;- t1.C fmt.Println(&amp;quot;NewTicker...&amp;quot;) } }() Timer 通过 time.NewTimer(d)的方式实现定时器 t2 := time.NewTimer(d) defer t2.Stop() go func() { for { &amp;lt;- t2.C fmt.Println(&amp;quot;NewTimer...&amp;quot;) } }() select 通过select的方式实现定时器： for { select { case &amp;lt;- time.After(d): fmt.Println(&amp;quot;select...&amp;quot;) } }</description>
    </item>
    
    <item>
      <title>Golang使用JWT身份认证</title>
      <link>https://zfunnily.github.io/post/csdn/Golang%E4%BD%BF%E7%94%A8JWT%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/</link>
      <pubDate>Wed, 24 Feb 2021 14:22:04 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/post/csdn/Golang%E4%BD%BF%E7%94%A8JWT%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/</guid>
      <description>概述 最近要在http接口上加一个token认证，但是接口很多，有没有一个省时省力的办法来解决。token的使用流程是： 用户使用帐号密码登陆到服务器1. 服务器验证登陆成功，根据帐号密码生成token。把token返回给客户端1. 客户端请求接口时需要带上token。服务器需要验证to</description>
    </item>
    
    <item>
      <title>Go sync.Mutex详解</title>
      <link>https://zfunnily.github.io/post/csdn/Go-sync.Mutex%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Tue, 29 Dec 2020 13:17:18 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/post/csdn/Go-sync.Mutex%E8%AF%A6%E8%A7%A3/</guid>
      <description>概述 自己做的一个golang项目需要优化，优化方向是减少gpu内存的使用。同一个模型被重复加载多次，使用更多的gpu内存，也增加 sync.Mutex的使用。优化的方向是: 减少代码量的改动- 减少gpu内存的使用，同一个模型只用加载一次 涉及的问题： sync.Mutex是传值还是传引用</description>
    </item>
    
    <item>
      <title>用gocolly登录B站</title>
      <link>https://zfunnily.github.io/post/csdn/%E7%94%A8gocolly%E7%99%BB%E5%BD%95B%E7%AB%99/</link>
      <pubDate>Sun, 13 Dec 2020 14:51:53 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/post/csdn/%E7%94%A8gocolly%E7%99%BB%E5%BD%95B%E7%AB%99/</guid>
      <description>概述 gocolly是golang语言开发的爬虫包，通过gocolly来进行模拟网站的登录，目标已经确立，开始行动。 下载 go get -u github.com/gocolly/colly 获取cookie 登录网站：https://www.bilibili.com/获取cookie： google浏览器访问bilibili- 按F12- 查看Net</description>
    </item>
    
    <item>
      <title>自定义头和protobuf解决沾包问题</title>
      <link>https://zfunnily.github.io/post/csdn/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%A4%B4%E5%92%8Cprotobuf%E8%A7%A3%E5%86%B3%E6%B2%BE%E5%8C%85%E9%97%AE%E9%A2%98/</link>
      <pubDate>Sun, 13 Dec 2020 10:22:38 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/post/csdn/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%A4%B4%E5%92%8Cprotobuf%E8%A7%A3%E5%86%B3%E6%B2%BE%E5%8C%85%E9%97%AE%E9%A2%98/</guid>
      <description>缘由 最近在研究一款游戏的源码。发现里面的通信协议是protobuf定义的，但还是自己定义了协议头部，类似 head + body。先解析头部里所存储的整个包的数据长度，然后再解析包剩余的数据，这样做的目的是为了防止沾包。我在想都用了protobuf了为啥不直接用grpc呢。一时想不出，于是我</description>
    </item>
    
    <item>
      <title>Docker容器退出码详解</title>
      <link>https://zfunnily.github.io/post/csdn/Docker%E5%AE%B9%E5%99%A8%E9%80%80%E5%87%BA%E7%A0%81%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Sat, 28 Nov 2020 13:32:57 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/post/csdn/Docker%E5%AE%B9%E5%99%A8%E9%80%80%E5%87%BA%E7%A0%81%E8%AF%A6%E8%A7%A3/</guid>
      <description>docker查看退出码指令 $ docker ps --filter &amp;quot;status=exited&amp;quot; $ docker inspect container-id --format=&#39;{&amp;lt;!-- --&amp;gt;{.State.ExitCode}}&#39; 常见退出码 Exit Code 0 退出代码0表示特定容器没有附加前台进程。- 该退出代码是所有其他后续退出代码的例外。- 这不一定意味着发生了不好的事情。如果开发人员想要在容器完成其工作后自动停止其容器，则使用此退出代码。 Exit Code 1 程序错误，或者Docker</description>
    </item>
    
    <item>
      <title>go builds</title>
      <link>https://zfunnily.github.io/post/csdn/go-builds/</link>
      <pubDate>Thu, 12 Nov 2020 17:15:17 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/post/csdn/go-builds/</guid>
      <description>概述 通常我们会给每个产品环境设置不同的配置，比如 redis 要在开发环境就连接 localhost:6379，测试环境可能连接某一个主机的 redis。 如果放在 go 里面是否可行？因为 go 是编译二进制包，也没有动态加载这么一说，那怎么实现？ 有个方法可以解决，就是配置文件。我们也可以利用golang的</description>
    </item>
    
    <item>
      <title>cgo的简单使用</title>
      <link>https://zfunnily.github.io/post/csdn/cgo%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Thu, 05 Nov 2020 09:45:23 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/post/csdn/cgo%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</guid>
      <description>使用自己的C函数 文件名：testC.go package main /* #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;stdlib.h&amp;gt; void c_print(char *str) { printf(&amp;quot;%s\n&amp;quot;, str); } */ import &amp;quot;C&amp;quot; //import “C” 必须单起一行，并且紧跟在注释行之后 import &amp;quot;unsafe&amp;quot; func main() { s := &amp;quot;Hello Cgo&amp;quot; cs := C.CString(s) //字符串映射 C.c_print(cs) //调用C函数 defer C.free(unsafe.Pointer(cs)) //释放内存 } 说明：1、go代码中的C代码，需要用注释包裹，块注释和行注释均可，其次import “C”是必</description>
    </item>
    
    <item>
      <title>使用Lumberjack&#43;zap进行日志切割归档</title>
      <link>https://zfunnily.github.io/post/csdn/%E4%BD%BF%E7%94%A8Lumberjack&#43;zap%E8%BF%9B%E8%A1%8C%E6%97%A5%E5%BF%97%E5%88%87%E5%89%B2%E5%BD%92%E6%A1%A3/</link>
      <pubDate>Wed, 04 Nov 2020 12:44:03 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/post/csdn/%E4%BD%BF%E7%94%A8Lumberjack&#43;zap%E8%BF%9B%E8%A1%8C%E6%97%A5%E5%BF%97%E5%88%87%E5%89%B2%E5%BD%92%E6%A1%A3/</guid>
      <description>使用Lumberjack+zap进行日志切割归档 为了添加日志切割归档功能，我们将使用第三方库Lumberjack来实现。 安装 执行下面的命令安装Lumberjack go get -u github.com/natefinch/lumberjack zap logger中加入Lumberjack 要在zap中加入Lumberjack支持，我们需要修改WriteSyn</description>
    </item>
    
  </channel>
</rss>
