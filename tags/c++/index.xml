<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>c&#43;&#43; on 流浪花</title>
    <link>https://zfunnily.github.io/tags/c&#43;&#43;/</link>
    <description>Recent content in c&#43;&#43; on 流浪花</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Tue, 23 Mar 2021 13:57:07 +0000</lastBuildDate><atom:link href="https://zfunnily.github.io/tags/c++/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>插入排序</title>
      <link>https://zfunnily.github.io/post/2021/03/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Tue, 23 Mar 2021 13:57:07 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/post/2021/03/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</guid>
      <description>概述 插入排序(InsertionSort)，一般也被称为直接插入排序。 对于少量元素的排序，它是一个有效的算法。插入排序是一种最简单的排序方法，它的基本思想是将一个记录插入到已经排好序的有序表中，从而一个新的、记录数增 1 的有序表。在其实现过程使用双层循环，外层循环对除了第一个元素之</description>
    </item>
    
    <item>
      <title>C&#43;&#43;  sort排序</title>
      <link>https://zfunnily.github.io/post/2021/03/C&#43;&#43;-sort%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Tue, 23 Mar 2021 13:40:22 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/post/2021/03/C&#43;&#43;-sort%E6%8E%92%E5%BA%8F/</guid>
      <description>概述 std::sort( )函数是库函数提供的排序函数，必须包括头文件#include &amp;lt;algorithm&amp;gt;，它使用的排序方法是类似于快排的方法，时间复杂度为n*log2(n) Sort函数有三个参数：（第三个参数可不写） 第一个是要排序的数组的起始地址。- 第二个是结束的地址（最后一位要排序</description>
    </item>
    
    <item>
      <title>快速排序</title>
      <link>https://zfunnily.github.io/post/2021/03/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Tue, 23 Mar 2021 10:15:40 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/post/2021/03/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</guid>
      <description>sort排序冒泡排序选择排序插入排序快速排序希尔排序堆排序归并排序 概述 分治法的基本思想是：将原问题分解为若干个规模更小但结构与原问题相似的子问题。递归地解这些子问题，然后将这些子问题的解组合为原问题的解。 使用递归，则需要找到递归点和递归出口： 递归点：如果数组的元素大于1，就需要再</description>
    </item>
    
    <item>
      <title>选择排序</title>
      <link>https://zfunnily.github.io/post/2021/03/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Tue, 23 Mar 2021 10:14:35 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/post/2021/03/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</guid>
      <description>sort排序冒泡排序选择排序插入排序快速排序希尔排序堆排序归并排序 概述 选择排序法（以从小到大排序为例）算法思想：A.在未排序序列中找到最小（大）元素，存放到排序序列的起始位置B.从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾C.以此类推，直到所有元素均排序完毕</description>
    </item>
    
    <item>
      <title>冒泡排序</title>
      <link>https://zfunnily.github.io/post/2021/03/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Tue, 23 Mar 2021 10:13:31 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/post/2021/03/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</guid>
      <description>sort排序冒泡排序选择排序插入排序快速排序希尔排序堆排序归并排序 概述 冒泡排序算法思想：1.比较相邻的元素。如果第一个比第二个大，就交换他们两个。2.对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数，然后将该数固定3.针对所有的元素重</description>
    </item>
    
    <item>
      <title>使用C/C&#43;&#43;实现atoi和itoa函数</title>
      <link>https://zfunnily.github.io/post/2021/03/%E4%BD%BF%E7%94%A8C-C&#43;&#43;%E5%AE%9E%E7%8E%B0atoi%E5%92%8Citoa%E5%87%BD%E6%95%B0/</link>
      <pubDate>Wed, 17 Mar 2021 16:43:20 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/post/2021/03/%E4%BD%BF%E7%94%A8C-C&#43;&#43;%E5%AE%9E%E7%8E%B0atoi%E5%92%8Citoa%E5%87%BD%E6%95%B0/</guid>
      <description>题目1： 把字符串转化为整数 有整数字符串，&amp;quot;13579&amp;quot;, 和 &amp;quot;246810&amp;quot;. 请写一个函数把这两个字符串转化为整数步骤： 先判断正负- 遍历字符串，转换字符为整数 //atoi.cc #include &amp;lt;stdio.h&amp;gt; int my_atoi(char *str) { bool bmin = false; int result = 0; //先判断正负 if ((*str &amp;gt; &#39;9&#39; || *str &amp;lt; &#39;0&#39;) &amp;amp;&amp;amp; (*str == &#39;+&#39; || *str == &#39;-&#39;)) { if (*str == &#39;-&#39;) bmin = true; str++; } while (*str != &#39;\0&#39;) { if (*str &amp;gt; &#39;9&#39; || *str &amp;lt;</description>
    </item>
    
    <item>
      <title>Lua调用C/C&#43;&#43;的动态库</title>
      <link>https://zfunnily.github.io/post/2021/02/Lua%E8%B0%83%E7%94%A8C-C&#43;&#43;%E7%9A%84%E5%8A%A8%E6%80%81%E5%BA%93/</link>
      <pubDate>Sat, 20 Feb 2021 11:11:51 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/post/2021/02/Lua%E8%B0%83%E7%94%A8C-C&#43;&#43;%E7%9A%84%E5%8A%A8%E6%80%81%E5%BA%93/</guid>
      <description>概述 最近在学习 云风的skynet库，想自定义一个模块，目标是使用lua调用C/C++所编写的库。 当我们需要在Lua里面调用c/c++函数时，所有的函数都必须满足以下函数签名： typedef int (*lua_CFunction) (lua_State *L); 换句话说，所有的函数必须接收一个lua_State作为参数，同时返回一个整数值。因为这个函数使用</description>
    </item>
    
    <item>
      <title>VScode调试Redis源码，指针显示的问题</title>
      <link>https://zfunnily.github.io/post/2021/01/VScode%E8%B0%83%E8%AF%95Redis%E6%BA%90%E7%A0%81%E6%8C%87%E9%92%88%E6%98%BE%E7%A4%BA%E7%9A%84%E9%97%AE%E9%A2%98/</link>
      <pubDate>Tue, 12 Jan 2021 14:17:22 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/post/2021/01/VScode%E8%B0%83%E8%AF%95Redis%E6%BA%90%E7%A0%81%E6%8C%87%E9%92%88%E6%98%BE%E7%A4%BA%E7%9A%84%E9%97%AE%E9%A2%98/</guid>
      <description>缘由 使用VScode的时候，断点看到指针显示的是一串地址，而不是指针指向的对象的值。上网找了一圈，没看到vscode有对应的插件来解决这个问题。vscode有对应的语法来解决这个问题。网上几乎都在说在监视栏添加下面的表达式可以解决问题， 可以查看int arr_name[10]的值：</description>
    </item>
    
    <item>
      <title>struct中为什么使用char[]而不用char*</title>
      <link>https://zfunnily.github.io/post/2021/01/struct%E4%B8%AD%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8char%E8%80%8C%E4%B8%8D%E7%94%A8char/</link>
      <pubDate>Tue, 05 Jan 2021 15:45:36 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/post/2021/01/struct%E4%B8%AD%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8char%E8%80%8C%E4%B8%8D%E7%94%A8char/</guid>
      <description>缘由 最近在看redis的源码，刚开始看sds，看到这块代码 struct __attribute__ ((__packed__)) sdshdr5 { unsigned char flags; /* 3 lsb of type, and 5 msb of string length */ char buf[]; }; 好奇为什么使用 char buf[],而不用char *buf，找到答案记录一下。 struct中的char*和char数组有什么区别 常用来构成缓冲区。比起指针，用空数组有这样的优势： 不需要</description>
    </item>
    
    <item>
      <title>最后一战-游戏场景服务器SS解析</title>
      <link>https://zfunnily.github.io/post/2021/01/%E6%9C%80%E5%90%8E%E4%B8%80%E6%88%98-%E6%B8%B8%E6%88%8F%E5%9C%BA%E6%99%AF%E6%9C%8D%E5%8A%A1%E5%99%A8SS%E8%A7%A3%E6%9E%90/</link>
      <pubDate>Sat, 02 Jan 2021 23:19:58 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/post/2021/01/%E6%9C%80%E5%90%8E%E4%B8%80%E6%88%98-%E6%B8%B8%E6%88%8F%E5%9C%BA%E6%99%AF%E6%9C%8D%E5%8A%A1%E5%99%A8SS%E8%A7%A3%E6%9E%90/</guid>
      <description>游戏场景服务器概况 指令对应的处理handle的文件：SSBattleMgr.cpp 创建战场 指令： eMsgToSSFromCS_CreateBattle- GC服务器发往SS fromCS 收到中心服务器CS创建站场的指令，在函数INT32 CSSBattleMgr::OnMsgFromCS_CreateBattle(const char* pData, int n32DataLength)中创建站场成功后，加入到战场管理器中: m_cAllBattleMap[pBattle-&amp;gt;GetBattleID()] = pBattle; 发送创建结果给CS服务器 CSSWorkThreadMgr::GetInstance().PostMsgToCS(sMsg, sMsg.mgsid()); 发送</description>
    </item>
    
    <item>
      <title>C&#43;&#43;：vector中的resize()函数 VS reserve()函数</title>
      <link>https://zfunnily.github.io/post/2020/12/C&#43;&#43;vector%E4%B8%AD%E7%9A%84resize%E5%87%BD%E6%95%B0-VS-reserve%E5%87%BD%E6%95%B0/</link>
      <pubDate>Fri, 25 Dec 2020 11:04:29 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/post/2020/12/C&#43;&#43;vector%E4%B8%AD%E7%9A%84resize%E5%87%BD%E6%95%B0-VS-reserve%E5%87%BD%E6%95%B0/</guid>
      <description>reserve void reserve (size_type n); reserver函数用来给vector预分配存储区大小，即capacity的值 ，但是没有给这段内存进行初始化。reserve 的参数n是推荐预分配内存的大小，实际分配的可能等于或大于这个值，即n大于capacity的值，就会reallocate内存 capacity的值会大</description>
    </item>
    
    <item>
      <title>最后一站源码分析(LastBattle)-登录流程(LS &amp; BS &amp; GS)</title>
      <link>https://zfunnily.github.io/post/2020/11/%E6%9C%80%E5%90%8E%E4%B8%80%E7%AB%99%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90LastBattle-%E7%99%BB%E5%BD%95%E6%B5%81%E7%A8%8BLS-BS-GS/</link>
      <pubDate>Fri, 20 Nov 2020 17:27:08 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/post/2020/11/%E6%9C%80%E5%90%8E%E4%B8%80%E7%AB%99%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90LastBattle-%E7%99%BB%E5%BD%95%E6%B5%81%E7%A8%8BLS-BS-GS/</guid>
      <description>登录流程 根据上一篇文章中的登录流程,我在工程中找到了相应的代码并记录了下来 登录服务代码解析 监听端口：49997 供BS服务连接监听端口：49996 供客户端连接 CIocpCtrl：IOCP控制类 多线程循环查询IOCP内部的网络事件,并分派处理.这里多个工作线程仅仅是将所有的网络事件放</description>
    </item>
    
    <item>
      <title>最后一站源码分析(LastBattle)-服务架构</title>
      <link>https://zfunnily.github.io/post/2020/11/%E6%9C%80%E5%90%8E%E4%B8%80%E7%AB%99%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90LastBattle-%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84/</link>
      <pubDate>Fri, 20 Nov 2020 17:24:32 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/post/2020/11/%E6%9C%80%E5%90%8E%E4%B8%80%E7%AB%99%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90LastBattle-%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84/</guid>
      <description>服务器架构简图如下: 连线说明： 实线：表示客户端登录流程，①②③④⑤表示登录流程，详细解释见下文。- 虚线：表示服务器间的连接，虚线箭头指向监听方。 架构说明： |英文名称|简称|中文名称|功能简介|单个大区需求数量|数量说明 |&amp;mdash;&amp;mdash; |GameClient|GC|游戏客户端|不解释|n|不超服</description>
    </item>
    
    <item>
      <title>最后一战安装部署笔记</title>
      <link>https://zfunnily.github.io/post/2020/11/%E6%9C%80%E5%90%8E%E4%B8%80%E6%88%98%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Mon, 16 Nov 2020 06:49:49 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/post/2020/11/%E6%9C%80%E5%90%8E%E4%B8%80%E6%88%98%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2%E7%AC%94%E8%AE%B0/</guid>
      <description>环境准备 win10服务器：vs2010 / 数据库 mysql5.7清华大学mysql镜像网站:https://mirrors.tuna.tsinghua.edu.cn/mysql/downloads/MySQL-5.7/客户端：unity3d 4.6 ,破解补丁 编译客户端 建议不要有其他的un</description>
    </item>
    
    <item>
      <title>Libevent定时器的实现</title>
      <link>https://zfunnily.github.io/post/2020/09/Libevent%E5%AE%9A%E6%97%B6%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Wed, 16 Sep 2020 23:20:28 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/post/2020/09/Libevent%E5%AE%9A%E6%97%B6%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0/</guid>
      <description>libevent 实现定时器流程 首先初始化libevent库，并保存返回的指针 struct event_base * base = event_init(); 实际上这一步相当于初始化一个Reactor实例；在初始化libevent后，就可以注册事件了。 初始化事件event，设置回调函数和关注的事件 ,事实上这等价于调用event_set(&amp;amp;ev, -1, 0, timer_cb, NULL); evtimer_set(&amp;amp;ev,</description>
    </item>
    
  </channel>
</rss>
