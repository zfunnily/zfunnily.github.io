<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>C/C&#43;&#43; on 留白</title>
    <link>https://zfunnily.github.io/tags/C/C&#43;&#43;/</link>
    <description>Recent content in C/C&#43;&#43; on 留白</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language><atom:link href="https://zfunnily.github.io/tags/C/C++/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>八个基础排序</title>
      <link>https://zfunnily.github.io/2021/03/sort/</link>
      <pubDate>Tue, 23 Mar 2021 10:13:31 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2021/03/sort/</guid>
      <description>sort排序 冒泡排序 选择排序 插入排序 快速排序 希尔排序 堆排序 归并排序 sort排序 std::sort( )函数是库函数提供的排序函数，必须包括头文件#include &amp;lt;algorithm&amp;gt;，它使用的排序方法是类似于快排的方法，时间复杂度为n*log2(n) Sort函数有三个参数：（第三个参数可</description>
    </item>
    
    <item>
      <title>《仙剑奇侠传》编译运行</title>
      <link>https://zfunnily.github.io/2021/03/gamexian/</link>
      <pubDate>Sun, 21 Mar 2021 10:44:58 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2021/03/gamexian/</guid>
      <description>概述 今天在github上找到了《仙剑奇侠传》的rpg单机游戏sdlpal，sdlpal 是一个开源项目，基于sdl把仙剑奇侠传重写了一遍。 下面是我的编译过程总结。 环境 win10- sdl1.2- sdlpal- vs2017- DirectX SDK10 下载sdlpal $ git clone https://github.com.cnpmjs.org/sdlpal/sdlpal.git 下载sdl1.2 $ git clone https://github.com.cnpmjs.org/libsdl-org/SDL-1.2.git sdlpal/3rd/SDL/ 下载 DirectX SDK10， 双击安装即可 编译sdlpal 打开解决</description>
    </item>
    
    <item>
      <title>C/C&#43;&#43; | 实现atoi和itoa函数</title>
      <link>https://zfunnily.github.io/2021/03/atoianditoa/</link>
      <pubDate>Wed, 17 Mar 2021 16:43:20 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2021/03/atoianditoa/</guid>
      <description>题目1： 把字符串转化为整数 有整数字符串，&amp;quot;13579&amp;quot;, 和 &amp;quot;246810&amp;quot;. 请写一个函数把这两个字符串转化为整数步骤： 先判断正负 遍历字符串，转换字符为整数 //atoi.cc #include &amp;lt;stdio.h&amp;gt; int my_atoi(char *str) { bool bmin = false; int result = 0; //先判断正负 if ((*str &amp;gt; &#39;9&#39; || *str &amp;lt; &#39;0&#39;) &amp;amp;&amp;amp; (*str == &#39;+&#39; || *str == &#39;-&#39;)) { if (*str == &#39;-&#39;) bmin = true; str++; } while (*str != &#39;\0&#39;) { if (*str &amp;gt; &#39;9&#39; || *str &amp;lt; &#39;0&#39;)</description>
    </item>
    
    <item>
      <title>协程解析一 | ucontext</title>
      <link>https://zfunnily.github.io/2021/03/coroutineone/</link>
      <pubDate>Tue, 09 Mar 2021 09:43:00 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2021/03/coroutineone/</guid>
      <description>概述 最近在研究协程的实现原理，看了云风的coroutine和腾讯的开源库libco后，原来要实现一个协程库也没那么难。我先来讲讲云风的coroutine库。他使用的是 uncontext来保存程序运行上下文，进而实现协程库，这个库很值深入了解一番，吃透了这个库，协程的原理也就了解了</description>
    </item>
    
    <item>
      <title>Lua | 调用C/C&#43;&#43;的动态库</title>
      <link>https://zfunnily.github.io/2021/02/dynamic/</link>
      <pubDate>Sat, 20 Feb 2021 11:11:51 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2021/02/dynamic/</guid>
      <description>概述 最近在学习 云风的skynet库，想自定义一个模块，目标是使用lua调用C/C++所编写的库。 当我们需要在Lua里面调用c/c++函数时，所有的函数都必须满足以下函数签名： typedef int (*lua_CFunction) (lua_State *L); 换句话说，所有的函数必须接收一个lua_State作为参数，同时返回一个整数值。因为这个函数使用</description>
    </item>
    
    <item>
      <title>汇编 | C/C&#43;&#43;调用汇编</title>
      <link>https://zfunnily.github.io/2021/02/compilation/</link>
      <pubDate>Mon, 01 Feb 2021 14:40:51 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2021/02/compilation/</guid>
      <description>概述 我使用AT&amp;amp;T的规范，在linux上完成 C和汇编的互相调用，并使用gcc编译成可执行文件。目标：汇编函数提供输出。类似C语言的函数 void hello_world(char* value) { printf(value); } 提供给C语言调用： int main() { hello_world(&amp;quot;hello world!\n&amp;quot;); } 搭建AT&amp;amp;T的环境 ubuntu16.04 或 ubuntu18.04- vscode- 文件后缀： .s- gcc 下载vscode插件GNU Assembler Language Support C代码生成为汇编</description>
    </item>
    
    <item>
      <title>C数组转化为Golang的切片类型</title>
      <link>https://zfunnily.github.io/2021/01/goslience/</link>
      <pubDate>Fri, 22 Jan 2021 15:56:40 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2021/01/goslience/</guid>
      <description>概述 最近在巩固cgo的基础知识，在网上看到一篇Go和C之间 字符串数组、切片类型转换的文章，让我想到我之前写的一篇在go中遍历C结构体数组的文章，让我有新的方法来解决之前的问题，把C的数组转化为Go的切片，对于文章的方法我直接”拿来主义“。 数组、字符串和切片 我们将一段特定长度的内存</description>
    </item>
    
    <item>
      <title>VScode | 调试Redis源码</title>
      <link>https://zfunnily.github.io/2021/01/vscodedebugredis/</link>
      <pubDate>Tue, 12 Jan 2021 14:25:29 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2021/01/vscodedebugredis/</guid>
      <description>环境 vscode- gcc5.4 ubuntu16.04 或者 ubuntu18.04 make 下载6.2版本. 我使用的是国内github镜像地址：github.com.cnpmjs.org，速度比较快。 $ git clone https://github.com.cnpmjs.org/redis/redis.git redis $ git checkout -b 6.2 remotes/origin/6.2 vscode不参与编译，只充当可视化的调试工具。 使用插件： C/C++ 先编译redis cd redis &amp;amp;&amp;amp; make -j4 打开redis目录后直接按F5，会出现选择启动</description>
    </item>
    
    <item>
      <title>VScode调试Redis源码，指针显示的问题</title>
      <link>https://zfunnily.github.io/2021/01/vscoderedis/</link>
      <pubDate>Tue, 12 Jan 2021 14:17:22 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2021/01/vscoderedis/</guid>
      <description>缘由 使用VScode的时候，断点看到指针显示的是一串地址，而不是指针指向的对象的值。上网找了一圈，没看到vscode有对应的插件来解决这个问题。vscode有对应的语法来解决这个问题。网上几乎都在说在监视栏添加下面的表达式可以解决问题， 可以查看int arr_name[10]的值：</description>
    </item>
    
    <item>
      <title>cgo | 遍历C结构体数组</title>
      <link>https://zfunnily.github.io/2021/01/cgostruct/</link>
      <pubDate>Mon, 11 Jan 2021 17:18:35 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2021/01/cgostruct/</guid>
      <description>缘由 现在有个应用场景，我们要在go中获取C结构体数组中的值。在C语言中，对于结构体数组，我们可以利用指针的偏移量来获取我们想要的值的位置。在go中我们怎么使用C指针和偏移量进行运算呢？下面的文字中C指的是C语言 利用cgo作为桥梁，遍历C结构体数组 unsafe.Pointer在C语</description>
    </item>
    
    <item>
      <title>Redis源码解析 | sds</title>
      <link>https://zfunnily.github.io/2021/01/sds/</link>
      <pubDate>Wed, 06 Jan 2021 14:20:23 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2021/01/sds/</guid>
      <description>SDS头文件及作用 sds.h: sds声明- sdsalloc.h： 为sds分配内存 源码文件sds.h中有这样一行代码 typedef char *sds; 很清晰、明了，sds其实就是char*。最新的6.2分支的代码： struct __attribute__ ((__packed__)) sdshdr5 {&amp;lt;!-- --&amp;gt; unsigned char flags; /* 3 lsb of type, and 5 msb of string length */ char buf[]; }; struct __attribute__ ((__packed__)) sdshdr8 {&amp;lt;!-- --&amp;gt; uint8_t len; /* used */ uint8_t alloc; /* excluding the header and null terminator */ unsigned char flags; /* 3 lsb of type,</description>
    </item>
    
    <item>
      <title>C/C&#43;&#43; | struct中使用char[]</title>
      <link>https://zfunnily.github.io/2021/01/chararray/</link>
      <pubDate>Tue, 05 Jan 2021 15:45:36 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2021/01/chararray/</guid>
      <description>缘由 最近在看redis的源码，刚开始看sds，看到这块代码 struct __attribute__ ((__packed__)) sdshdr5 { unsigned char flags; /* 3 lsb of type, and 5 msb of string length */ char buf[]; }; 好奇为什么使用 char buf[],而不用char *buf，找到答案记录一下。 struct中的char*和char数组有什么区别 常用来构成缓冲区。比起指针，用空数组有这样的优势： 不需要</description>
    </item>
    
    <item>
      <title>最后一战-游戏场景服务器SS解析</title>
      <link>https://zfunnily.github.io/2021/01/lastbattle/</link>
      <pubDate>Sat, 02 Jan 2021 23:19:58 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2021/01/lastbattle/</guid>
      <description>游戏场景服务器概况 指令对应的处理handle的文件：SSBattleMgr.cpp 创建战场 指令： eMsgToSSFromCS_CreateBattle GC服务器发往SS fromCS 收到中心服务器CS创建站场的指令，在函数INT32 CSSBattleMgr::OnMsgFromCS_CreateBattle(const char* pData, int n32DataLength)中创建站场成功后，加入到战场管理器中: m_cAllBattleMap[pBattle-&amp;gt;GetBattleID()] = pBattle; 发送创建结果给CS服务器 CSSWorkThreadMgr::GetInstance().PostMsgToCS(sMsg, sMsg.mgsid()); 发送</description>
    </item>
    
    <item>
      <title>一个reactor单线程网络库ccnet</title>
      <link>https://zfunnily.github.io/2020/12/%E4%B8%80%E4%B8%AAreactor%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%BD%91%E7%BB%9C%E5%BA%93ccnet/</link>
      <pubDate>Sun, 27 Dec 2020 18:41:25 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2020/12/%E4%B8%80%E4%B8%AAreactor%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%BD%91%E7%BB%9C%E5%BA%93ccnet/</guid>
      <description>缘由 最近在研究陈硕的网络库muduo，是一个基于reactor架构的网络库。我对网络库的感觉是易用，但是内容庞大，依赖颇多。比如boost网络库里面的一些语法让人生畏。关于reactor和proactor架构，还有select/poll/epoll网络模型方面的基础理论知识已经掌</description>
    </item>
    
    <item>
      <title>C&#43;&#43;：vector中的resize()函数 VS reserve()函数</title>
      <link>https://zfunnily.github.io/2020/12/C-vector%E4%B8%AD%E7%9A%84resize%E5%87%BD%E6%95%B0-VS-reserve%E5%87%BD%E6%95%B0/</link>
      <pubDate>Fri, 25 Dec 2020 11:04:29 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2020/12/C-vector%E4%B8%AD%E7%9A%84resize%E5%87%BD%E6%95%B0-VS-reserve%E5%87%BD%E6%95%B0/</guid>
      <description>reserve void reserve (size_type n); reserver函数用来给vector预分配存储区大小，即capacity的值 ，但是没有给这段内存进行初始化。reserve 的参数n是推荐预分配内存的大小，实际分配的可能等于或大于这个值，即n大于capacity的值，就会reallocate内存 capacity的值会大</description>
    </item>
    
    <item>
      <title>最后一站源码分析(LastBattle)-登录流程(LS &amp; BS &amp; GS)</title>
      <link>https://zfunnily.github.io/2020/11/%E6%9C%80%E5%90%8E%E4%B8%80%E7%AB%99%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90LastBattle-%E7%99%BB%E5%BD%95%E6%B5%81%E7%A8%8BLS-BS-GS/</link>
      <pubDate>Fri, 20 Nov 2020 17:27:08 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2020/11/%E6%9C%80%E5%90%8E%E4%B8%80%E7%AB%99%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90LastBattle-%E7%99%BB%E5%BD%95%E6%B5%81%E7%A8%8BLS-BS-GS/</guid>
      <description>登录流程 根据上一篇文章中的登录流程,我在工程中找到了相应的代码并记录了下来 登录服务代码解析 监听端口：49997 供BS服务连接监听端口：49996 供客户端连接 CIocpCtrl：IOCP控制类 多线程循环查询IOCP内部的网络事件,并分派处理.这里多个工作线程仅仅是将所有的网络事件放</description>
    </item>
    
    <item>
      <title>最后一站源码分析(LastBattle)-服务架构</title>
      <link>https://zfunnily.github.io/2020/11/%E6%9C%80%E5%90%8E%E4%B8%80%E7%AB%99%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90LastBattle-%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84/</link>
      <pubDate>Fri, 20 Nov 2020 17:24:32 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2020/11/%E6%9C%80%E5%90%8E%E4%B8%80%E7%AB%99%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90LastBattle-%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84/</guid>
      <description>服务器架构简图如下: 连线说明： 实线：表示客户端登录流程，①②③④⑤表示登录流程，详细解释见下文。- 虚线：表示服务器间的连接，虚线箭头指向监听方。 架构说明： |英文名称|简称|中文名称|功能简介|单个大区需求数量|数量说明 |&amp;mdash;&amp;mdash; |GameClient|GC|游戏客户端|不解释|n|不超服</description>
    </item>
    
    <item>
      <title>最后一战安装部署笔记</title>
      <link>https://zfunnily.github.io/2020/11/%E6%9C%80%E5%90%8E%E4%B8%80%E6%88%98%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Mon, 16 Nov 2020 06:49:49 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2020/11/%E6%9C%80%E5%90%8E%E4%B8%80%E6%88%98%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2%E7%AC%94%E8%AE%B0/</guid>
      <description>环境准备 win10服务器：vs2010 / 数据库 mysql5.7清华大学mysql镜像网站:https://mirrors.tuna.tsinghua.edu.cn/mysql/downloads/MySQL-5.7/客户端：unity3d 4.6 ,破解补丁 编译客户端 建议不要有其他的un</description>
    </item>
    
    <item>
      <title>cgo使用libevent库实现一个定时器</title>
      <link>https://zfunnily.github.io/2020/11/cgo%E4%BD%BF%E7%94%A8libevent%E5%BA%93%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%AE%9A%E6%97%B6%E5%99%A8/</link>
      <pubDate>Fri, 13 Nov 2020 16:40:42 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2020/11/cgo%E4%BD%BF%E7%94%A8libevent%E5%BA%93%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%AE%9A%E6%97%B6%E5%99%A8/</guid>
      <description>使用libevent库作为例子 下载 &amp;amp; 编译 &amp;amp; 安装libevent $ git clone https://github.com.cnpmjs.org/libevent/libevent.git $ cd libevent &amp;amp;&amp;amp; mkdir build &amp;amp;&amp;amp; cd build $ cmake .. $ make libevent实现的定时器 // main.cpp #include &amp;quot;event.h&amp;quot; struct event ev; struct timeval tv; void time_cb(evutil_socket_t fd, short event, void *argc) { printf(&amp;quot;timer wakeup\n&amp;quot;); event_add(&amp;amp;ev, &amp;amp;tv); // reschedule timer } int main() { struct event_base *base = event_base_new(); tv.tv_sec = 2; tv.tv_usec = 0; evtimer_set(&amp;amp;ev, time_cb, NULL); event_base_set(base, &amp;amp;ev); event_add(&amp;amp;ev, &amp;amp;tv); event_base_dispatch(base); event_base_free(base); } go调用libevent实现定时器 把编译好的头文件和库</description>
    </item>
    
    <item>
      <title>Libevent | 定时器</title>
      <link>https://zfunnily.github.io/2020/09/libeventimer/</link>
      <pubDate>Wed, 16 Sep 2020 23:20:28 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2020/09/libeventimer/</guid>
      <description>libevent 实现定时器流程 首先初始化libevent库，并保存返回的指针 struct event_base * base = event_init(); 实际上这一步相当于初始化一个Reactor实例；在初始化libevent后，就可以注册事件了。 初始化事件event，设置回调函数和关注的事件 ,事实上这等价于调用event_set(&amp;amp;ev, -1, 0, timer_cb, NULL); evtimer_set(&amp;amp;ev,</description>
    </item>
    
    <item>
      <title>licod | 安装和配置</title>
      <link>https://zfunnily.github.io/2020/08/licode/</link>
      <pubDate>Sun, 09 Aug 2020 09:34:36 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2020/08/licode/</guid>
      <description>拉取docker镜像并运行 licode官方提供了配置好的docker镜像，使用以下命令拉下来跑就行。 docker run --name licode -p 3000:3000 -p $MIN_PORT-$MAX_PORT:30000-30050/udp -p 3001:3001 -p 8080:8080 -e &amp;quot;MIN_PORT=30000&amp;quot; -e &amp;quot;MAX_PORT=30050&amp;quot; -e &amp;quot;PUBLIC_IP=your_ip_address&amp;quot; lynckia/licode 注意命令里的PUBLIC_IP要改为服务器的公网IP。 配置好之后，在地址栏输入ip:3001回车，chrome就会弹出是否允许摄像头麦克风那个</description>
    </item>
    
    <item>
      <title>owt-server | 编译运行</title>
      <link>https://zfunnily.github.io/2020/08/owtservercomplie/</link>
      <pubDate>Wed, 05 Aug 2020 09:47:22 +0000</pubDate>
      
      <guid>https://zfunnily.github.io/2020/08/owtservercomplie/</guid>
      <description>概述 owt是一套完整的webrtc视频会议系统。包含的功能模块有： 视频会议1. p2p 服务器是owt-server通过nodejs编写的webrtc信令。依赖是licode。licode依赖webrtc。客户端系列web/windows/linux/ios/android都有相应的sd</description>
    </item>
    
  </channel>
</rss>
