<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>读书笔记 on Zzz记忆</title><link>https://zfunnily.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</link><description>Recent content in 读书笔记 on Zzz记忆</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Sun, 11 Feb 2024 01:04:25 +0000</lastBuildDate><atom:link href="https://zfunnily.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/index.xml" rel="self" type="application/rss+xml"/><item><title>《Unity Shader入门精要》第八章笔记 | 透明度</title><link>https://zfunnily.github.io/2022/05/shaderalpha/</link><pubDate>Sat, 07 May 2022 17:17:18 +0800</pubDate><guid>https://zfunnily.github.io/2022/05/shaderalpha/</guid><description>渲染顺序 名称 队列索引号 描 述 Background 1000 这个渲染队列会在任何其他队列之前被渲染，我们通常使用该队列来渲染那些需要绘制在背景上的物体 Geometry 2000 默认的渲染队列，大多数物体都使用这个队列。不透明物体使用这个队列 AlphaTest 2450 需要透明</description></item><item><title>《Unity Shader入门精要》第八章笔记 | 透明度</title><link>https://zfunnily.github.io/2022/05/shaderalpha/</link><pubDate>Sat, 07 May 2022 17:17:18 +0800</pubDate><guid>https://zfunnily.github.io/2022/05/shaderalpha/</guid><description>渲染顺序 名称 队列索引号 描 述 Background 1000 这个渲染队列会在任何其他队列之前被渲染，我们通常使用该队列来渲染那些需要绘制在背景上的物体 Geometry 2000 默认的渲染队列，大多数物体都使用这个队列。不透明物体使用这个队列 AlphaTest 2450 需要透明</description></item><item><title>《Unity Shader入门精要》第六章笔记 | 基础光照</title><link>https://zfunnily.github.io/2022/05/shaderlighting/</link><pubDate>Sat, 07 May 2022 16:22:40 +0800</pubDate><guid>https://zfunnily.github.io/2022/05/shaderlighting/</guid><description>我们是如何看到这个世界的 光源: 在光学里，我们使用辐照度 （irradiance） 来量化光 物体的吸收和散射: 光线由光源发射出来后，就会与一些物体相交 着色: 根据材质属性（如漫反射属性等）、光源信息（如光源方</description></item><item><title>《Unity Shader入门精要》第六章笔记 | 基础光照</title><link>https://zfunnily.github.io/2022/05/shaderlighting/</link><pubDate>Sat, 07 May 2022 16:22:40 +0800</pubDate><guid>https://zfunnily.github.io/2022/05/shaderlighting/</guid><description>我们是如何看到这个世界的 光源: 在光学里，我们使用辐照度 （irradiance） 来量化光 物体的吸收和散射: 光线由光源发射出来后，就会与一些物体相交 着色: 根据材质属性（如漫反射属性等）、光源信息（如光源方</description></item><item><title>《Unity Shader入门精要》第五章笔记 | 开始shader练习</title><link>https://zfunnily.github.io/2022/05/shaderbase/</link><pubDate>Sat, 07 May 2022 10:22:33 +0800</pubDate><guid>https://zfunnily.github.io/2022/05/shaderbase/</guid><description>一个简单的顶点/片元着色器 代码 Shader &amp;#34;Unity Shaders Book/Chapter 5/Simple Shader&amp;#34; { Properties { // 声明一个Color类型的属性 _Color (&amp;#34;Color Tint&amp;#34;, Color) = (1.0,1.0,1.0,1.0) } SubShader { Pass { CGPROGRAM #pragma vertex vert #pragma fragment frag // 在Cg代码中，我们需要定义一个与属性名称和类型都匹配的变量 fixed4 _Color; // 使用一个结构体来定义</description></item><item><title>《Unity Shader入门精要》第五章笔记 | 开始shader练习</title><link>https://zfunnily.github.io/2022/05/shaderbase/</link><pubDate>Sat, 07 May 2022 10:22:33 +0800</pubDate><guid>https://zfunnily.github.io/2022/05/shaderbase/</guid><description>一个简单的顶点/片元着色器 代码 Shader &amp;#34;Unity Shaders Book/Chapter 5/Simple Shader&amp;#34; { Properties { // 声明一个Color类型的属性 _Color (&amp;#34;Color Tint&amp;#34;, Color) = (1.0,1.0,1.0,1.0) } SubShader { Pass { CGPROGRAM #pragma vertex vert #pragma fragment frag // 在Cg代码中，我们需要定义一个与属性名称和类型都匹配的变量 fixed4 _Color; // 使用一个结构体来定义</description></item><item><title>《Unity Shader入门精要》第四章笔记 | 学习Shader所需的数学基础</title><link>https://zfunnily.github.io/2022/04/shadermathematic/</link><pubDate>Sun, 10 Apr 2022 15:42:33 +0800</pubDate><guid>https://zfunnily.github.io/2022/04/shadermathematic/</guid><description>概述 在学习Shader的过程中，我们最常使用的就是矢量和矩阵（即数学的分支之一——线性代数）。 笛卡儿坐标系 我们使用数学绝大部分都是为了计算位置、距离和角度等变量。而这些计算大部分都是在笛卡儿坐标系 （C</description></item><item><title>《Unity Shader入门精要》第四章笔记 | 学习Shader所需的数学基础</title><link>https://zfunnily.github.io/2022/04/shadermathematic/</link><pubDate>Sun, 10 Apr 2022 15:42:33 +0800</pubDate><guid>https://zfunnily.github.io/2022/04/shadermathematic/</guid><description>概述 在学习Shader的过程中，我们最常使用的就是矢量和矩阵（即数学的分支之一——线性代数）。 笛卡儿坐标系 我们使用数学绝大部分都是为了计算位置、距离和角度等变量。而这些计算大部分都是在笛卡儿坐标系 （C</description></item><item><title>《Unity Shader入门精要》第三章笔记| UnityShader基础</title><link>https://zfunnily.github.io/2022/04/shaderbase/</link><pubDate>Sun, 10 Apr 2022 14:51:19 +0800</pubDate><guid>https://zfunnily.github.io/2022/04/shaderbase/</guid><description>材质 在Unity中我们需要配合使用材质 （Material） 和Unity Shader才能达到需要的效果。一个最常见的流程是 创建一个材质；活着导入一个材质 创建一个Unity Shader，并把它赋给上一步中</description></item><item><title>《Unity Shader入门精要》第三章笔记| UnityShader基础</title><link>https://zfunnily.github.io/2022/04/shaderbase/</link><pubDate>Sun, 10 Apr 2022 14:51:19 +0800</pubDate><guid>https://zfunnily.github.io/2022/04/shaderbase/</guid><description>材质 在Unity中我们需要配合使用材质 （Material） 和Unity Shader才能达到需要的效果。一个最常见的流程是 创建一个材质；活着导入一个材质 创建一个Unity Shader，并把它赋给上一步中</description></item><item><title>《Unity Shader入门精要》第二章笔记 | 渲染流水线</title><link>https://zfunnily.github.io/2022/04/shaderrenderpipline/</link><pubDate>Sat, 09 Apr 2022 11:55:55 +0800</pubDate><guid>https://zfunnily.github.io/2022/04/shaderrenderpipline/</guid><description>渲染流水线 Render-Time Rendering, Third Edition》一书中将一个渲染流程分成3个阶段：应用阶段（Application Stage） 、几何阶段（Geometry Stage） 、光栅化阶段（Rasterizer Stage） 。 应</description></item><item><title>《Unity Shader入门精要》第二章笔记 | 渲染流水线</title><link>https://zfunnily.github.io/2022/04/shaderrenderpipline/</link><pubDate>Sat, 09 Apr 2022 11:55:55 +0800</pubDate><guid>https://zfunnily.github.io/2022/04/shaderrenderpipline/</guid><description>渲染流水线 Render-Time Rendering, Third Edition》一书中将一个渲染流程分成3个阶段：应用阶段（Application Stage） 、几何阶段（Geometry Stage） 、光栅化阶段（Rasterizer Stage） 。 应</description></item></channel></rss>