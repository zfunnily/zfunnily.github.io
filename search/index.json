[{"content":"skynet启动一个C服务 查看怎么启动C服务的最好的办法是打断点，看源码。\n启动logger日志服务 我拿日志服务来举例子，怎么启动日志服务的呢？\n 传参数name = \u0026quot;logger\u0026quot;, param = null， struct skynet_context *ctx = skynet_context_new(config-\u0026gt;logservice, config-\u0026gt;logger);; 从modules服务模块中取出名字为 logger的服务, struct skynet_module * result = _query(name);; 如果找不到则从cpath目录中找对应的.so文件，打开服务，并且存储到modules模块中。使用的函数是static void * _try_open(struct modules *m, const char * name); 创建服务实例m-\u0026gt;create(),放到上下文skynet_context的inst中; 把skynet_context放到skynet_context list中， skynet_handle_register(ctx);; 创建logger服务对应的次级消息队列struct message_queue *queue，并且把消息队列push到全局消息队列中skynet_mq_create(ctx-\u0026gt;handle);，skynet_globalmq_push(queue);; 服务实例初始化m-\u0026gt;init(),int r = skynet_module_instance_init(mod, inst, ctx, param);  总结下来，启动一个服务的过程就是，1.获取服务;2.创建服务实例;3.创建服务对应的上下文，并且把上下文放到skynet_context list管理模块中;4.绑定次级消息队列与对应的服务;5.服务初始化; 这五步过程。\nsnlua服务 boostrap服务是通过snlua服务启动的，所以在启动boostrap服务的时候先把snlua服务启动了，并放在了modules模块中，snlua服务的主要作用是启动lua服务。\n 创建snlua服务，先调用 snlua_create，  struct snlua * snlua_create(void) { //初始化snlua结构 \tstruct snlua * l = skynet_malloc(sizeof(*l)); memset(l,0,sizeof(*l)); l-\u0026gt;mem_report = MEMORY_WARNING_REPORT; ... //初始化一个lua虚拟机 \tl-\u0026gt;L = lua_newstate(lalloc, l); ... return l; }  创建一个snlua结构，创建一个Lua虚拟机，内存分配指定的是lalloc，目的是为了监控Lua分配的内存。MEMORY_WARNING_REPORT为Lua服务的内存阀值，超过该值，会报警  snlua服务被创建后，初始化，调用的 snlua_init  int snlua_init(struct snlua *l, struct skynet_context *ctx, const char * args) { ... //指定回掉函数 \tskynet_callback(ctx, l , launch_cb); //取本地服务的句柄 \tconst char * self = skynet_command(ctx, \u0026#34;REG\u0026#34;, NULL); uint32_t handle_id = strtoul(self+1, NULL, 16); // it must be first message  //发送第一条消息，在launc_cb可见 \tskynet_send(ctx, 0, handle_id, PTYPE_TAG_DONTCOPY,0, tmp, sz); return 0; }  指定初始化的回调函数,launch_cb 取得本地服务句柄 向服务发送第一条消息, 打上PTYPE_TAG_DONTCOPY的tag，这表示skynet内部不会重新分配内存拷贝tmp。  launch_cb函数处理snlua服务收到自己给自己发送的第一条消息，删除回调函数，并且调用init_cb函数，前面删除了回调，后面必定会把回调函数给加上(下文启动lua服务的时候会在lua脚本里设置回调)，直接看init_cb函数的逻辑。 代码太长，我就只贴关键的代码：  static int init_cb(struct snlua *l, struct skynet_context *ctx, const char * args, size_t sz) { lua_State *L = l-\u0026gt;L; l-\u0026gt;ctx = ctx; lua_gc(L, LUA_GCSTOP, 0); ... //LUA_PATH：Lua搜索路径，在config.lua_path指定。 \tconst char *path = optstring(ctx, \u0026#34;lua_path\u0026#34;,\u0026#34;./lualib/?.lua;./lualib/?/init.lua\u0026#34;); lua_pushstring(L, path); lua_setglobal(L, \u0026#34;LUA_PATH\u0026#34;); //LUA_CPATH：C模块的搜索路径，在config.lua_cpath指定。 \tconst char *cpath = optstring(ctx, \u0026#34;lua_cpath\u0026#34;,\u0026#34;./luaclib/?.so\u0026#34;); lua_pushstring(L, cpath); lua_setglobal(L, \u0026#34;LUA_CPATH\u0026#34;); //LUA_SERVICE：Lua服务的搜索路径，在config.luaservice指定。 \tconst char *service = optstring(ctx, \u0026#34;luaservice\u0026#34;, \u0026#34;./service/?.lua\u0026#34;); lua_pushstring(L, service); lua_setglobal(L, \u0026#34;LUA_SERVICE\u0026#34;); //LUA_PRELOAD：预加载脚本，这些脚本会在所有服务开始之前执行，可以用它来初始化一些全局的设置。执行loader.lua，把要执行的脚本传进去，由loader去加载执行，skynet初始执行bootstrap.lua。  const char *preload = skynet_command(ctx, \u0026#34;GETENV\u0026#34;, \u0026#34;preload\u0026#34;); lua_pushstring(L, preload); lua_setglobal(L, \u0026#34;LUA_PRELOAD\u0026#34;); const char * loader = optstring(ctx, \u0026#34;lualoader\u0026#34;, \u0026#34;./lualib/loader.lua\u0026#34;); int r = luaL_loadfile(L,loader); ... lua_pushlstring(L, args, sz); r = lua_pcall(L,1,0,1); if (r != LUA_OK) { skynet_error(ctx, \u0026#34;lua loader error : %s\u0026#34;, lua_tostring(L, -1)); report_launcher_error(ctx); return 1; } ... lua_gc(L, LUA_GCRESTART, 0); return 0; } 总结一下init_cb做的事情，设置lua全局变量：\n LUA_PATH：Lua搜索路径，在config.lua_path指定。 LUA_CPATH：C模块的搜索路径，在config.lua_cpath指定。 LUA_SERVICE：Lua服务的搜索路径，在config.luaservice指定。 LUA_PRELOAD：预加载脚本，这些脚本会在所有服务开始之前执行，可以用它来初始化一些全局的设置。 执行loader.lua，把要执行的脚本传进去，由loader去加载执行，skynet初始执行bootstrap.lua.  最后一步执行loader.lua,这一步很重要, r = lua_pcall(L,1,0,1);, 初始执行boostrap.lua脚本文件中，skynet.start()的地方。其他lua服务的skynet.start()也是在这里调用的。\nboostrap服务 boostrap是引导服务，他是通过snlua服务启动的，属于lua服务。我们可以从boostrap.lua脚本看到该服务做的事情如下：\n 启动launcher服务，这个launcher服务为服务启动器 如果指定harborid，则说明这是一个主从分布式的skynet结构，不过skynet已经不推荐使用这种构架，略过。 调用skynet.newservice启动datacenterd服务 调用skynet.newservice启动service_mgr服务 调用skynet.newservice启动 start or main服务 ,这是我们逻辑的入口  skynet启动一个lua服务 我们知道了snlua服务和boostrap服务的启动， skynet.launch是创建服务的通用版本，要在Lua创建某个C写的服务，可以使用它。但如果要创建一个Lua服务，则应该使用skynet.newservice。\n如果我有在A服务创建B服务，则有：\n 调用skynet.newservice(B,...)这个函数使A阻塞; B服务创建成功，B.lua这个脚本被执行，skynet.start(function()...end)这个函数被调用，表示服务B启动，可以接收消息，此详细过程可以看snlua服务启动的最后一步执行loader.lua; 当skynet.start(function() ... end)这个函数执行完了之后A的skynet.newservice(B,...)才返回，并且A得到了B的句柄。  内部怎么实现的呢?\n skynet.newservice()函数实现  function skynet.newservice(name, ...) return skynet.call(\u0026#34;.launcher\u0026#34;, \u0026#34;lua\u0026#34; , \u0026#34;LAUNCH\u0026#34;, \u0026#34;snlua\u0026#34;, name, ...) end 调用的是.launcher服务的LAUNCH函数，参数是snlua name, .launcher服务收到了消息后的处理：\n--launcher.lua local function launch_service(service, ...) local param = table.concat({...}, \u0026#34; \u0026#34;) --创建一个服务，并返回服务句柄 local inst = skynet.launch(service, param) local session = skynet.context() --取一个resonse闭包，先存起来，等skynet.start返回再调用。 local response = skynet.response() if inst then services[inst] = service .. \u0026#34; \u0026#34; .. param instance[inst] = response launch_session[inst] = session else response(false) return end return inst end function command.LAUNCH(_, service, ...) launch_service(service, ...) return NORET end  实际上只用看launch_service函数即可, service=snlua param=服务名B 通过snlua创建lua服务B，并返回B的句柄 取一个resonse闭包，先存起来，等skynet.start返回再调用。  B服务创建后，调用B.lua脚本，调用脚本里的skynet.start函数\nfunction skynet.start(start_func) c.callback(skynet.dispatch_message) init_thread = skynet.timeout(0, function() skynet.init_service(start_func) init_thread = nil end) end  前文snlua启动的时候，在函数launch_cb中，删除了回调函数，这里c.callback,重新设置了收到消息后的回调。 c.callback,代码在lua-skynet.c中，，以后向这个服务发消息，skynet.dispatch_message就会被调用。  调用skynet.init_service(start_func):\nfunction skynet.init_service(start) local function main() skynet_require.init_all() start() end local ok, err = xpcall(main, traceback) if not ok then skynet.error(\u0026#34;init service failed: \u0026#34; .. tostring(err)) skynet.send(\u0026#34;.launcher\u0026#34;,\u0026#34;lua\u0026#34;, \u0026#34;ERROR\u0026#34;) skynet.exit() else skynet.send(\u0026#34;.launcher\u0026#34;,\u0026#34;lua\u0026#34;, \u0026#34;LAUNCHOK\u0026#34;) end end B服务在skynet.start调用完毕之后，会发送 LAUNCHOK消息：\nfunction command.LAUNCHOK(address) -- init notice local response = instance[address] if response then response(true, address) instance[address] = nil launch_session[address] = nil end return NORET end  从instance取出response函数，调用它，传入true表示成功，后面跟的address就是skynet.call的返回值，这样A服务终于从skynet.newservice返回，并得到了B的地址(句柄)。 所有经过skynet.newsevice创建的服务，都会记录在launcher服务中，launcher提供了些函数用于查询服务的状态。  为什么skynet.newservice阻塞 为什么A创建B服务的时候skynet.newservice会阻塞，并等到到B服务创建成功并返回句柄，才继续往下走，请看 skynet.call的代码\nfunction skynet.call(addr, typename, ...) local tag = session_coroutine_tracetag[running_thread] if tag then c.trace(tag, \u0026#34;call\u0026#34;, 2) c.send(addr, skynet.PTYPE_TRACE, 0, tag) end local p = proto[typename] local session = c.send(addr, p.id , nil , p.pack(...)) if session == nil then error(\u0026#34;call to invalid address \u0026#34; .. skynet.address(addr)) end return p.unpack(yield_call(addr, session)) end  c.send直接返回，阻塞在return p.unpack(yield_call(addr, session)) yield_call是挂起了当前协程  在B服务创建成功，并且调用skynet.repsonse()之后,往A服务发送了一个协议skynet.PTYPE_RESPONSE\nret = c.send(co_address, skynet.PTYPE_RESPONSE, co_session, pack(...)) A服务收到skynet.PTYPE_RESPONSE协议后,会回到yield_call挂起协程的地方\nlocal function raw_dispatch_message(prototype, msg, sz, session, source) -- skynet.PTYPE_RESPONSE = 1, read skynet.h if prototype == 1 then local co = session_id_coroutine[session] if co == \u0026#34;BREAK\u0026#34; then session_id_coroutine[session] = nil elseif co == nil then unknown_response(session, source, msg, sz) else local tag = session_coroutine_tracetag[co] if tag then c.trace(tag, \u0026#34;resume\u0026#34;) end session_id_coroutine[session] = nil -- 在这一步重新调用协程函数 suspend(co, coroutine_resume(co, true, msg, sz)) end ... end  这样就能解释为为什么skynet.newservice是阻塞的了。 同理skynet.call是阻塞的.  ","date":"2021-10-20T11:26:07+08:00","permalink":"https://example.com/p/skynet%E6%BA%90%E7%A0%81%E8%B5%8F%E6%9E%90%E5%9B%9B%E6%9C%8D%E5%8A%A1%E5%90%AF%E5%8A%A8/","title":"Skynet源码赏析四(服务启动)"},{"content":"module管理模块 我们所写的C服务编译成.so文件后放在cpath变量路径下，程序会加载路径cpath = root..\u0026quot;cservice/?.so\u0026quot;下的.so文件，通过static void * _try_open(struct modules *m, const char * name)函数第一次打开，然后被加载到全局变量static struct modules * M中。\nmodule对应的数据结构如下： //skynet_module.h struct skynet_module { const char * name; // C服务名称 \tvoid * module; // 访问so的dl句柄 \tskynet_dl_create create; // 绑定.so的 xxx_create 函数 \tskynet_dl_init init; // 绑定.so的 xxx_init 函数 \tskynet_dl_release release; // 绑定.so的 xxx_release 函数 \tskynet_dl_signal signal; // 绑定.so的 xxx_signal 函数 }; //skynet_modules.c #define MAX_MODULE_TYPE 32  struct modules { int count; // C服务数量 \tstruct spinlock lock; // 自旋锁 \tconst char * path; // C服务.so文件目录，由cpath变量控制置 \tstruct skynet_module m[MAX_MODULE_TYPE]; // C服务列表 }; 当要创建该类服务的实例时  从modules列表中取出该服务的skynet_module句柄, 然后调用m-\u0026gt;create()创建实例。 将实例inst赋值到新的skynet_context中。 将新的skynet_context注册到skynet_contextlist中 初始化inst实例m-\u0026gt;init()。 对应的代码如下  struct skynet_context * skynet_context_new(const char * name, const char *param) { struct skynet_module * mod = skynet_module_query(name); //1. 取出服务句柄  ... void *inst = skynet_module_instance_create(mod);//m-\u0026gt;create 创建实例 \tstruct skynet_context * ctx = skynet_malloc(sizeof(*ctx)); CHECKCALLING_INIT(ctx) ctx-\u0026gt;mod = mod; ctx-\u0026gt;instance = inst; //2. 将实例赋值懂啊 skynet_context中  ... ctx-\u0026gt;handle = 0;\tctx-\u0026gt;handle = skynet_handle_register(ctx); //3. 注册到skynet_context list中  ... // init function maybe use ctx-\u0026gt;handle, so it must init at last \tcontext_inc(); CHECKCALLING_BEGIN(ctx) int r = skynet_module_instance_init(mod, inst, ctx, param); //4.m-\u0026gt;init() \tCHECKCALLING_END(ctx) if (r == 0) { ... } else { ... } } skynet_context服务管理模块 创建一个新服务，首先要找到对应服务的modules，在创建并初始化modules之后绑定一个上下文skynet_context,skynet通过全局变量static struct handle_storage *H来管理服务。 主要的数据结构如下：\n//skynet_server.c struct skynet_context { void * instance; // m-create()创建的实例 \tstruct skynet_module * mod; // 引用mod服务的指针，方便 m 的init(),create()等函数调用 \tvoid * cb_ud; // 调用callback函数时，回传给callback的userdata，一般是instance指针  skynet_cb cb; // 服务的消息回调函数，一般在skynet_module的init函数里指定 \tstruct message_queue *queue; // 服务专属的次级消息队列 \tATOM_POINTER logfile; // 日志句柄 \tuint64_t cpu_cost;\t// in microsec \tuint64_t cpu_start;\t// in microsec \tchar result[32]; // 操作skynet_context的返回值，会写到这里 \tuint32_t handle; // 标识唯一context的服务id \tint session_id; // 在发出请求后，收到对方的返回消息时，通过session_id来匹配一个返回，对应哪个请求 \tATOM_INT ref; // 引用计数变量，当为0时，表示内存可以被释放 \tint message_count; // 消息数量 \tbool init; // 是否完成初始化 \tbool endless; // 消息是否堵住 \tbool profile; // 配合 cpu_cost 和 cpu_start使用  CHECKCALLING_DECL }; //skynet_handle.c struct handle_name { char * name; // 服务别名 \tuint32_t handle; // 标识唯一context的服务id }; struct handle_storage { struct rwlock lock; // 读写锁  uint32_t harbor; // harbor id \tuint32_t handle_index; // 创建下一个服务时，该服务的slot idx，一般会先判断该slot是否被占用 \tint slot_size; // slot的大小，一定是2^n，初始值是4 \tstruct skynet_context ** slot; // skynet_context list \tint name_cap; // 别名列表大小，大小为2^n \tint name_count; // 别名数量 \tstruct handle_name *name; // 别名列表 }; 消息与队列 在创建C服务module和对应的上下文skynet_context时，有一个对应的消息队列message_queue与之绑定, 最后把该消息队列push到全局队列中。 数据结构如下:\n//skynet_mq.c struct message_queue { struct spinlock lock; // 自旋锁 防止数据冲突 \tuint32_t handle; // 服务id 唯一 \tint cap; // 队列容量 \tint head; // 头部索引，当head=tail时会进行扩容。 \tint tail; // 尾部索引 \tint release; // 是否能释放消息 \tint in_global; // 是否在全局消息队列中，0表示不是，1表示是 \tint overload; // 是否过载 \tint overload_threshold; struct skynet_message *queue; // 消息内容 \tstruct message_queue *next; // 下一个次级消息队列 }; struct global_queue { struct message_queue *head; // 全局消息队列头部指针 \tstruct message_queue *tail; // 全局消息队列尾部指针 \tstruct spinlock lock; // 自旋锁 }; 消息通过函数struct message_queue * skynet_context_message_dispatch(struct skynet_monitor *sm, struct message_queue *q, int weight)来处理，处理过程如下：\n 从全局消息队列中取出一个次级消息队列, skynet_globalmq_pop();; 通过次级消息队列中的handle变量来获取对应服务的上下文， struct skynet_context * ctx = skynet_handle_grab(handle);; 调用回调函数，dispatch_message(ctx, \u0026amp;msg);  总结 本文从数据结构的层面，讲述了一个C服务的启动，以及消息的处理流程。\n","date":"2021-10-19T18:47:45+08:00","permalink":"https://example.com/p/skynet%E6%BA%90%E7%A0%81%E8%B5%8F%E6%9E%90%E4%BA%8C%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","title":"Skynet源码赏析二(基础数据结构)"},{"content":"入口文件 skynet_main.c\n加载配置 struct skynet_config config; config.thread = optint(\u0026#34;thread\u0026#34;,8); config.module_path = optstring(\u0026#34;cpath\u0026#34;,\u0026#34;./cservice/?.so\u0026#34;); config.harbor = optint(\u0026#34;harbor\u0026#34;, 1); config.bootstrap = optstring(\u0026#34;bootstrap\u0026#34;,\u0026#34;snlua bootstrap\u0026#34;); config.daemon = optstring(\u0026#34;daemon\u0026#34;, NULL); config.logger = optstring(\u0026#34;logger\u0026#34;, NULL); config.logservice = optstring(\u0026#34;logservice\u0026#34;, \u0026#34;logger\u0026#34;); config.profile = optboolean(\u0026#34;profile\u0026#34;, 1); 从上述代码可以看到，配置都已经加载到变量struct skynet_config config;中了。\n初始化  初始化skynet_context管理模块, skynet_handle_init(config-\u0026gt;harbor);; 初始化static struct global_queue *Q消息队列, skynet_mq_init();; 初始化static struct modules * M管理模块, skynet_module_init(config-\u0026gt;module_path);; 初始化定时器, skynet_timer_init();;  启动C服务  启动logger日志服务, struct skynet_context *ctx = skynet_context_new(config-\u0026gt;logservice, config-\u0026gt;logger);; 启动 snlua服务, ``; 通过snlua服务启动boostrap服务, bootstrap(ctx, config-\u0026gt;bootstrap);; 启动线程:   监听线程，检测线程是否阻塞。 create_thread(\u0026amp;pid[0], thread_monitor, m);; 启动定时器线程。create_thread(\u0026amp;pid[1], thread_timer, m);; 启动socket线程。create_thread(\u0026amp;pid[2], thread_socket, m); 启动工作线程，用于lua服务消息的调度。create_thread(\u0026amp;pid[i+3], thread_worker, \u0026amp;wp[i]);;  启动lua服务 默认启动的lua服务，在boostrap.lua文件中可以看到都是通过snlua服务启动的。\n 启动launch服务。 启动cdummy 启动cmaster 启动cslave \u0026hellip;  总结 本文简单讲述了skynet的启动流程，使用了那些数据结构，以及启了那些C服务和lua服务。后续将会讲解这些基础的数据结构和怎么启动C服务和lua服务。\n","date":"2021-10-19T17:28:45+08:00","permalink":"https://example.com/p/skynet%E6%BA%90%E7%A0%81%E8%B5%8F%E6%9E%90%E4%B8%80%E5%90%AF%E5%8A%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E8%BF%87%E7%A8%8B/","title":"Skynet源码赏析一(启动初始化的过程)"},{"content":"起因 今天用golang写一个调用外部shell脚本的程序，使用 exec.Command方法，这段脚本代码中包含了一个后台任务语句。 结果发生了一个问题：cmd.Output 始终不会返回，一直挂起。导致我的Go程序也挂起了。\n问题还原 //main.go package main import ( \u0026#34;fmt\u0026#34; \u0026#34;os/exec\u0026#34; ) func main() { cmd := exec.Command(\u0026#34;sh\u0026#34;, \u0026#34;test.sh\u0026#34;) out, err := cmd.Output() if err != nil { fmt.Errorf(err.Error()) return } print(fmt.Sprintf(\u0026#34;%s\u0026#34;, out)) } test.sh\n#!/bin/bash  ping localhost \u0026amp; 启动golang程序 go run main.go, 此时会发现cmd.Output()始终不会返回。如果在终端直接执行sh test.sh就会直接返回了。 是什么原因导致的这个问题？\n脚本执行方式 由于ping localhost会一直运行并且输出，我换了一个立即会结束的脚本:\n#!/bin/bash  ls -la  为什么会想到用立即结束的脚本来验证问题，是因为我写这个程序的需求是使用golang写一个web服务来执行脚本。有的脚本是立马n返回，有的是一直输出的。\n 改成上面后，cmd.Output() 立马就返回了，看来是因为脚本一直有输出，导致 cmd.OutPut()一直不返回。\n终端是如何把一个后台任务的输出显示在自己的输出中的？ 可以参考菜鸟教程：Shell输入/输出重定向\n引用里面的一段话： 大多数 UNIX 系统命令从你的终端接受输入并将所产生的输出发送回到您的终端。一个命令通常从一个叫标准输入的地方读取输入，默认情况下，这恰好是你的终端。同样，一个命令通常将其输出写入到标准输出，默认情况下，这也是你的终端。\n解读源码 Go 等待进程退出的代码 结合这段代码再回到开始的ping localhost \u0026amp;语句（它在被sh执行的脚本中）：\n其中state, err := c.Process.Wait()等待的是sh进程的结束，没问题，sh很快就退出了, 看到这段代码:\nvar copyError error for range c.goroutine { if err := \u0026lt;-c.errch; err != nil \u0026amp;\u0026amp; copyError == nil { copyError = err } } 这段代码会等待所有的 goroutines 退出，这些 goroutines 在干啥呢？可以再看下面这两段代码：\n也就是说，开了一个 goroutine去把数据从子进程那里把数据读回来。\n结论是什么？ cmd.Output() 会等待直接启动的那个进程的退出，并等待所有的连接标准输入/标准输出/标准错误管道全部关闭之后才会返回。只要这三者之一任意一个没有被关闭（而不是写没写/读没读），等待就会持续。\n标准输入：由于本文中的ping是后台任务，sh根本就没把标准输入传递给它，sh退出时就把exec.Command的标准输入管道（的读端）给关闭了。所以这儿的goroutine早就结束了。 标准输出/标准错误：仍然和ping连接在一起\n解决办法 那到底该怎么写呢，有两种思路\n 改脚本，可以把标准输出和标准错误重定向到文件中。还是参考菜鸟教程Shell输入/输出重定向  #!/bin/bash  #如果要保留输出，可以输出到文件 ping localhost \u0026gt; test.txt 2\u0026gt;\u0026amp;1 \u0026amp; #如果输出无用，直接丢弃 ping localhost \u0026gt; /dev/null 2\u0026gt;\u0026amp;1 \u0026amp; 改golang程序, 使用 cmd.Start() 替代 cmd.Output()  package main import ( \u0026#34;fmt\u0026#34; \u0026#34;os/exec\u0026#34; ) func main() { cmd := exec.Command(\u0026#34;sh\u0026#34;, \u0026#34;test.sh\u0026#34;) out:= cmd.Start() print(fmt.Sprintf(\u0026#34;%s\u0026#34;, out)) } Cmd的几个方法介绍,有阻塞和非阻塞的，按需使用。\nfunc Command(name string, arg ...string) *Cmd 方法返回一个*Cmd， 用于执行name指定的程序(携带arg参数) func (c *Cmd) Run() error 执行Cmd中包含的命令，阻塞直到命令执行完成 func (c *Cmd) Start() error 执行Cmd中包含的命令，该方法立即返回，并不等待命令执行完成 func (c *Cmd) Wait() error 该方法会阻塞直到Cmd中的命令执行完成，但该命令必须是被Start方法开始执行的 func (c *Cmd) Output() ([]byte, error) 执行Cmd中包含的命令，并返回标准输出的切片 func (c *Cmd) CombinedOutput() ([]byte, error) 执行Cmd中包含的命令，并返回标准输出与标准错误合并后的切片 func (c *Cmd) StdinPipe() (io.WriteCloser, error) 返回一个管道，该管道会在Cmd中的命令被启动后连接到其标准输入 func (c *Cmd) StdoutPipe() (io.ReadCloser, error) 返回一个管道，该管道会在Cmd中的命令被启动后连接到其标准输出 func (c *Cmd) StderrPipe() (io.ReadCloser, error) 返回一个管道，该管道会在Cmd中的命令被启动后连接到其标准错误 ","date":"2021-10-13T17:15:45+08:00","permalink":"https://example.com/p/golang%E8%B0%83%E7%94%A8%E5%B8%A6%E6%9C%89%E5%90%8E%E5%8F%B0%E8%BF%9B%E7%A8%8Bshell%E8%84%9A%E6%9C%AC%E5%8F%AF%E8%83%BD%E4%BC%9A%E8%A2%AB%E6%8C%82%E8%B5%B7/","title":"golang调用带有后台进程shell脚本可能会被挂起"},{"content":"缘由 英文像一座大山，下定决心想要跨过去，可迟迟不的法门。，今天看到一片文章怎么开始并坚持读英文原著, 里面有句话： \u0026ldquo;拖延症怎么坚持下去\u0026ndash;每天控制在10-20页，保持在一个阅读的状态是最重要的。\u0026rdquo; 看到这里 想到以前的n+1和日拱一卒，其实是一个意思。道理都懂，我是拖延症犯了。\n借鉴读取英文方法 读书的时候不能光看不过脑子。我认为比较有效的读书方法如下：\n 读完一段落后，思考作者主要讲的核心，以及核心之下有哪些分支 关键词要查出来。所谓的关键词是指，它决定了句子意思的词，尤其是动词之类的。 把不认识的词存字典里，第二天对照著文章再看一次。日积月累，你认识的词汇会越来越多。 每天控制在10-20页，保持在一个阅读的状态是最重要的。  读书笔记的写法：\n 不要狂抄句子，这个是看起来爽，实际是偷懒 把关键词，不懂的词写下来 用自己的话总价作者的意图，并且思考作者用什么论据支撑意图；然后，把它们有条理地写到本子上 如果你有拓展阅读、个人心得、疑问、都可以写在旁边  10-12 下定决心 今天是10-12号，按照上面的方法，坚持一个月。\n","date":"2021-10-12T14:36:25+08:00","permalink":"https://example.com/p/%E8%8B%B1%E8%AF%AD%E5%AD%A6%E4%B9%A0/","title":"英语学习"},{"content":"经济学入门 经济学原理 宏观+微观，[美] 曼昆（N.GregoryMankiw） ，北京大学出版社，【第一篇 导言；第4章、第6章；第10章、第11章；第23章、第24章；第25章】 牛奶可乐经济学，[美] 罗伯特·，弗兰克 著；闾佳 译，北京联合出版公司，【全书，以前五章为主】 经济学的思维方式，[美] 保罗·海恩（Paul Heyne），[美] 彼得·勃特克 等 著；史晨 译，机械工业出版社\n","date":"2021-09-14T19:06:01+08:00","permalink":"https://example.com/p/%E7%BB%8F%E6%B5%8E%E5%AD%A6%E4%B9%A6%E7%B1%8D/","title":"经济学书籍"},{"content":"三种实现FPS Controller的区别  Transform Translate 允许移动物理，但无物理碰撞 Rigid body + Capsule Collider 符合物理学 不会鬼穿墙 无法滞空运动 可与Physics Object 交互 Charactor Controller 不会鬼穿墙 提供的API相对多 无法与Physic objects互动 可以滞空运动(太空人) 提供多种运动效果例如 slopes steps 等  Rigid body + Capsule Collider 控制摄像头旋转 FPMouseLook.cs 跟main camera 绑定\nusing System.Collections; using System.Collections.Generic; using UnityEngine; using UnityEngine.UI; public class FPMouseLook : MonoBehaviour { private Transform cameraTransform; [SerializeField] private Transform characterTransform; private Vector3 cameraRotation; public float MouseSensitivity; public Vector2 MaxMinAngle; // Start is called before the first frame update  void Start() { cameraTransform = transform; } // Update is called once per frame  void Update() { var tmp_MouseX = Input.GetAxis(\u0026#34;Mouse X\u0026#34;); var tmp_MouseY = Input.GetAxis(\u0026#34;Mouse Y\u0026#34;); cameraRotation.x -= tmp_MouseY * MouseSensitivity;//MouseSensitivity=18  cameraRotation.y += tmp_MouseX * MouseSensitivity;//MouseSensitivity=18  cameraRotation.x = Mathf.Clamp(cameraRotation.x, MaxMinAngle.x, MaxMinAngle.y); cameraTransform.rotation = Quaternion.Euler(cameraRotation.x, cameraRotation.y, 0); characterTransform.rotation = Quaternion.Euler(0, cameraRotation.y, 0); } } 函数解析 Input.GetAxis 一、触屏类 1、Mouse X 鼠标沿屏幕X移动时触发 2、Mouse Y 鼠标沿屏幕Y移动时触发 3、Mouse ScrollWheel 鼠标滚轮滚动是触发 二、键盘类 1、Vertical 键盘按上或下键时触发 2、Horizontal 键盘按左或右键时触发\n使用示例：\nInput.GetAxis(\u0026quot;Mouse Y\u0026quot;);  返回值是一个数，正负代表方向\n Mathf.Clamp 函数定义：\nstatic function Clamp (value : float, min : float, max : float) : float 解释： 限制value的值在min和max之间， 如果value小于min，返回min。 如果value大于max，返回max，否则返回value\n控制降落 + 跳跃 FPMoveMent.cs\nusing System.Collections; using System.Collections.Generic; using UnityEngine; public class FPMoveMent : MonoBehaviour { //自由落体速度  public float Speed; public float grativty; //跳跃  public float JumpHeight; private Transform characterTransform; private Rigidbody characterRigidbody; private bool isGrounded = true; // Start is called before the first frame update  void Start() { characterTransform = transform; characterRigidbody = GetComponent\u0026lt;Rigidbody\u0026gt;(); } // Update is called once per frame  void Update() { } private void FixedUpdate() { Debug.Log(isGrounded); if (isGrounded) { var tmp_Horizontal = Input.GetAxis(\u0026#34;Horizontal\u0026#34;); var tmp_Vertical = Input.GetAxis(\u0026#34;Vertical\u0026#34;); var tmp_CurrentDirection = new Vector3(tmp_Horizontal, 0, tmp_Vertical); //自身坐标转化为世界坐标  tmp_CurrentDirection = characterTransform.TransformDirection(tmp_CurrentDirection); tmp_CurrentDirection *= Speed; var tmp_CurrentVelocity = characterRigidbody.velocity; var tmp_VelocityChange = tmp_CurrentDirection - tmp_CurrentVelocity; tmp_VelocityChange.y = 0; characterRigidbody.AddForce(tmp_VelocityChange, ForceMode.VelocityChange); Debug.Log(\u0026#34;button: \u0026#34; + Input.GetButtonDown(\u0026#34;Jump\u0026#34;)); if (Input.GetButtonDown(\u0026#34;Jump\u0026#34;)) { characterRigidbody.velocity = new Vector3(tmp_CurrentVelocity.x, CalculateJumpHeightSpeed(), tmp_CurrentVelocity.z); } } characterRigidbody.AddForce(new Vector3(0, -grativty * characterRigidbody.mass,0)); } private float CalculateJumpHeightSpeed() { return Mathf.Sqrt(2 * grativty * JumpHeight); } private void OnCollisionStay(Collision _other) { isGrounded = true; } private void OnCollisionExit(Collision _other) { isGrounded = false; } } 函数解析 OnCollisionStay()\nOnCollisionStay与OnCollisionEnter的区别 OnCollisionStay();\n 两者之间处在碰撞状态下 两者之间有相对移动的情况下才触发。  FixedUpdate   MonoBehaviour.Update 更新 当MonoBehaviour启用时，其Update在每一帧被调用。\n  MonoBehaviour.FixedUpdate 固定更新\n   当MonoBehaviour启用时，其 FixedUpdate在每一帧被调用。 处理Rigidbody时，需要用FixedUpdate代替Update。例如:给刚体加一个作用力时，你必须应用作用力在FixedUpdate里的固定帧，而不是Update中的帧。(两者帧长不同)  MonoBehaviour.LateUpdate 晚于更新   当Behaviour启用时，其LateUpdate在每一帧被调用。 LateUpdate是在所有Update函数调用后被调用。这可用于调整脚本执行顺序。例如:当物体在Update里移动时，跟随物体的相机可以在LateUpdate里实现。  Update和FixedUpdate的区别：   update跟当前平台的帧数有关，而FixedUpdate是真实时间，所以处理物理逻辑的时候要把代码放在FixedUpdate而不是Update. Update是在每次渲染新的一帧的时候才会调用，也就是说，这个函数的更新频率和设备的性能有关以及被渲染的物体（可以认为是三角形的数量）。在性能好的机器上可能fps 30，差的可能小些。这会导致同一个游戏在不同的机器上效果不一致，有的快有的慢。因为Update的执行间隔不一样了。 FixedUpdate，是在固定的时间间隔执行，不受游戏帧率的影响。有点想Tick。所以处理Rigidbody的时候最好用FixedUpdate。   PS：FixedUpdate的时间间隔可以在项目设置中更改，Edit-\u0026gt;ProjectSetting-\u0026gt;time 找到Fixedtimestep。就可以修改了。\n Update和LateUpdate的区别   在圣典里LateUpdate被解释成一句话：LateUpdate是在所有Update函数调用后被调用。这可用于调整脚本执行顺序。例如:当物体在Update里移动时，跟随物体的相机可以在LateUpdate里实现。这句我看了云里雾里的，后来看了别人的解释才明白过来。 LateUpdate是晚于所有Update执行的。例如：游戏中有2个脚步，脚步1含有Update和LateUpdate，脚步2含有Update，那么当游戏执行时，每一帧都是把2个脚步中的Update执行完后才执行LateUpdate 。虽然是在同一帧中执行的，但是Update会先执行，LateUpdate会晚执行。 现在假设有2个不同的脚本同时在Update中控制一个物体，那么当其中一个脚本改变物体方位、旋转或者其他参数时，另一个脚步也在改变这些东西，那么这个物体的方位、旋转就会出现一定的反复。如果还有个物体在Update中跟随这个物体移动、旋转的话，那跟随的物体就会出现抖动。 如果是在LateUpdate中跟随的话就会只跟随所有Update执行完后的最后位置、旋转，这样就防止了抖动。  参考： physicalSystyme.md\n移动 方案2 using System.Collections; using System.Collections.Generic; using UnityEngine; public class FPCharacterControllerMovement : MonoBehaviour { private CharacterController characterController; private Transform characterTransForm; private Vector3 movementDirection; public float MovementSpeed; public float Gravity = 9.8f; public float JumpHeight; private void Start() { characterController = GetComponent\u0026lt;CharacterController\u0026gt;(); // characterForm = GetComponent\u0026lt;Transform\u0026gt;();  characterTransForm = transform; } void Update() { Debug.Log(characterController.isGrounded); //如果在地面 则返回 true  if (characterController.isGrounded) { var tmp_Horizontal = Input.GetAxis(\u0026#34;Horizontal\u0026#34;); var tmp_Vertical = Input.GetAxis(\u0026#34;Vertical\u0026#34;); movementDirection = characterTransForm.TransformDirection(new Vector3(tmp_Horizontal, 0, tmp_Vertical)); // characterTransForm.LookAt(characterTransForm.position + tmp_MovementDirection);  // characterController.SimpleMove(movementDirection * Time.deltaTime * MovementSpeed);  if (Input.GetButtonDown(\u0026#34;Jump\u0026#34;)) { movementDirection.y = JumpHeight; } } movementDirection.y -= Gravity * Time.deltaTime; characterController.Move(movementDirection * Time.deltaTime * MovementSpeed);//不具备重力算法  } } shift 奔跑 + 下蹲 using System.Collections; using System.Collections.Generic; using UnityEngine; public class FPCharacterControllerMovement : MonoBehaviour { private CharacterController characterController; private Transform characterTransForm; private Vector3 movementDirection; public float MovementSpeed; //移动速度  public float Gravity = 9.8f; public float JumpHeight; //跳跃高度  public float SprintingSpeed = 8; public float WalkSpeed = 4; public float SprintingSpeedWhenCrouch = 4;//当下蹲时  public float WalkSpeedWhenCrouch = 2;//当下蹲时  public float CrouchHeight = 1f; //下蹲高度  private bool isCrouched; //是否下蹲  private float originHeight; //原来的高度  private void Start() { characterController = GetComponent\u0026lt;CharacterController\u0026gt;(); // characterForm = GetComponent\u0026lt;Transform\u0026gt;();  characterTransForm = transform; originHeight = characterController.height; isCrouched = false; } void Update() { Debug.Log(characterController.isGrounded); float currentSpeed = WalkSpeed; //如果在地面 则返回 true  if (characterController.isGrounded) { var tmp_Horizontal = Input.GetAxis(\u0026#34;Horizontal\u0026#34;); var tmp_Vertical = Input.GetAxis(\u0026#34;Vertical\u0026#34;); movementDirection = characterTransForm.TransformDirection(new Vector3(tmp_Horizontal, 0, tmp_Vertical)); // characterTransForm.LookAt(characterTransForm.position + tmp_MovementDirection);  // characterController.SimpleMove(movementDirection * Time.deltaTime * MovementSpeed);  if (Input.GetButtonDown(\u0026#34;Jump\u0026#34;)) { movementDirection.y = JumpHeight; } if (Input.GetKeyDown(KeyCode.C)) { var tmpCrouchHeight = isCrouched?originHeight:CrouchHeight ; StartCoroutine(DoCrouch(tmpCrouchHeight)); isCrouched = !isCrouched; } //shift奔跑  if (isCrouched) { currentSpeed = Input.GetKey(KeyCode.LeftShift) ? SprintingSpeedWhenCrouch : WalkSpeedWhenCrouch; } else { currentSpeed = Input.GetKey(KeyCode.LeftShift) ? SprintingSpeed : WalkSpeed; } } movementDirection.y -= Gravity * Time.deltaTime; characterController.Move(movementDirection * Time.deltaTime * currentSpeed);//不具备重力算法  } private IEnumerator DoCrouch(float target) { float tmp_CurrentHeight = 0; while(Mathf.Abs(characterController.height - target) \u0026gt; 0.1f) { yield return null; characterController.height = Mathf.SmoothDamp(characterController.height, target, ref tmp_CurrentHeight, Time.deltaTime * 5 ); } } } ","date":"2021-09-12T20:43:34+08:00","permalink":"https://example.com/p/fps%E6%B8%B8%E6%88%8F-%E5%AE%9E%E7%8E%B0%E7%A7%BB%E5%8A%A8%E5%8A%9F%E8%83%BD/","title":"FPS游戏 实现移动功能"},{"content":"介绍一个可以免费听音乐的方法 环境\n docker mac  安装 $ docker run -d -p 264:264 -p 9000:9000 -v $dir_name:/var/www/html/cache --name music oldiy/music-player-docker  $dir_name 是 你自己宿主机的目录。可以自定义\n 访问：127.0.0.1:264\n就可以放心使用， 同事推荐的，贼好用。\n","date":"2021-09-08T14:47:14+08:00","permalink":"https://example.com/p/%E5%85%8D%E8%B4%B9music/","title":"免费Music"},{"content":"Transform类 在unity中，把transform类理解为，transform类是在每个对象生成时自动附加的一个类。在Unity的视图中，点击Hierarchy中的对象，就可以在Inspector中可以看到存在Transform的组件。\n属性  Position（坐标） Rotation（旋转） Scale（缩放）  脚本中类中的方法就是对它们的改变。 而我们也可以在Scene中和Inspector中直接进行设置。\n修改属性 修改 Position\nvar pos =transform.position; transform.position.x; transform.position.y; transform.position.z; transform.position = new Vector3(1f,1f,1f); 修改Rotation\ntransform.localEulerAngles.x; transform.localEulerAngles.y; transform.localEulerAngles.z; transform.localEulerAngles = new Vector3(90f,0,0); rotation = new Rotation(x,y,z,w); //修改2： //如果物体面板Rotation (x=22.5,y=0,z=0) //用代码实现方法: transform.Rotate(22.5f,0,0); 修改Scale, 缩放,没有本地和世界分别\ntransform.localScale.x; transform.localScale.y; transform.localScale.z; transform.localScale = new Vector3(1f,1f,1f); 在Unity中不能对transform.position.x/y/z直接赋值的原因  Vector3是一个结构体，而position是一个自动实现的属性。 在C#里，结构体是值类型的，值类型在通过方法传递的时候，所传递的只是值的副本。C#的属性可以说是两个分别名为get和set的方法 当我们写出形如 transform.position.x = 1 这样的代码时，是在通过get方法得到position，然后修改position的x字段的值。 由于position是结构体类型的，get得到的也只是position的一个副本，而对这个副本所作出的任何修改，都对原positon没有任何影响，因此这样的修改是毫无意义的。  坐标系 A本地坐标 + A父物体世界坐标 = A在上一级节点的相对坐标 A本地坐标 + A父物体世界坐标 = 是以父物体为原点的坐标系中的坐标\n本地坐标  是相对于父亲节点的坐标系 本地都是对于根物体 通俗的讲,u3d可以把多个物体算成一个物体(父物体),而他的子物体就需要本地坐标系做了,就是参考父物体世界坐标+偏移  世界坐标 场景所有物体的位置以世界坐标(0,0,0)为原地的坐标系\n欧拉角  欧拉角由三个数字组成，每个数字代表环绕一个坐标轴旋转的角度。 它把一个转动分解成三个方向的转源动，可以用三个欧拉角表示一个转百动 R( θ度1, θ2, θ3 )。其中的θ1, θ2, θ3就是普通的角度，但是我们管知它们叫欧拉角。 围绕X轴旋转，即相当于翻滚机身（Roll）。横滚角 围绕Y轴旋转，即相当于机身俯仰（Pitch）。俯仰角 围绕Z轴旋转，即决定飞机头指向的方向，又叫偏航（Yaw）。导航角 欧拉角是一种旋转方式,例如要把物体旋转到某个方向,可以通过多种旋转方式达成:第一种方式我们可以称它为围绕Y轴的旋转：[Y]，第二种是旋转：[Z, X’]，第三种是旋转：[X, Z’]。 欧拉角背后的基本概念。你可以使用不同的方式得到同一个旋转——通过不同的转轴或者不同的旋转顺序。 Unity3d 通过[z,x,y]旋转,先绕z轴一个小角度,然后x轴小角度,然后y轴;按轴顺序重复绕,渐进达到最终姿态. 欧拉角按照旋转次序的不同被规定为十二种顺序：X‐Z‐X, X‐Y‐X, Y‐X‐Y, Y‐Z‐Y, Z‐Y‐Z, Z‐X‐Z, X‐Z‐Y, X‐Y‐Z, Y‐X‐Z, Y‐Z‐X, Z‐Y‐X, Z‐X‐Y。 欧拉表示有个致命的弱点，就是万向节死锁  跟欧拉角有关的函数 Quaternion.Euler 基本语法：\n（1）public static Quaternion Euler(Vector3 euler); （2）public static Quaternion Euler(float x, float y, float z); 功能说明：此方法用于返回欧拉角Vector3(x,y,z)对应的四元数Quaternion实例。\n四元数Quaternion(qx,qy,qz,qw)与其欧拉角eulerAngles(ex,ey,ez)之间的对应关系如下。\n","date":"2021-09-07T15:55:59+08:00","permalink":"https://example.com/p/u3d-transform%E7%B1%BB/","title":"U3D Transform类"},{"content":"vim 在退出输入模式的时候切换为原来的输入法 在敲代码的时候使用我们使用的英文，当遇到问题，我们需要搜索引擎的时候需要中文输入法，这个时候，自动切换输入法可以帮助我们节省手动切换输入法的时间。\n跟编辑器结合，主要是两种编辑器，一个是 idea 一个是 vscode\n在idea中使用 vim 插件：\n IdeaVim IdeaVimExtension  我们需要在 用户目录下创建 .ideavimrc 文件, 并输入以下内容\nset keep-english-in-normal set keep-english-in-normal-and-restore-in-insert $ source ~/.ideavimrc 重启 idea 可以看到效果了。\nIdeaVimExtension插件的文档： 为IdeaVim插件增加自动切换为英文输入法的功能 输入法自动切换功能不会默认启用 编辑器中normal模式下输入输入下面的指令以启用自动切换输入法功能：\n:set keep-english-in-normal 开启输入法自动切换功能 :set keep-english-in-normal-and-restore-in-insert 回到insert模式时恢复输入法 :set nokeep-english-in-normal-and-restore-in-insert 保留输入法自动切换功能，但是回到insert模式不恢复输入法 :set nokeep-english-in-normal 关闭输入法自动切换功能 也可以通过将set keep-english-in-normal[-and-restore-in-insert]加入到~/.ideavimrc文件中并重启IDE来启用插件功能。 注意:支持MacOS和Windows, 通过fcitx-remote支持Linux MacOS需要开启英语美国键盘或ABC键盘 Windows需要开启英语美国键盘 Linux需要使用fcitx输入法，通过fcitx-remote切换 在macOS中,normal模式的输入法可以通过keep_input_source_in_normal 来设置,例如let keep_input_source_in_normal=\u0026quot;com.apple.keylayout.ABC\u0026quot;\n在vscode中使用 vim 参考 vscode 插件： https://github.com/VSCodeVim/Vim#input-method\n环境  mac 下载 vscodevim插件 im-select  安装 im-select $ git clone https://github.com.cnpmjs.org/daipeihust/im-select.git $ mv im-select/im-select-mac/out/im-select /usr/local/bin/ $ chmod 777 /usr/local/bin/im-select 查看当前输入法\n$ /usr/local/bin/im-select com.apple.keylayout.ABC 全局配置 settings.json \u0026quot;vim.autoSwitchInputMethod.enable\u0026quot;: true, \u0026quot;vim.autoSwitchInputMethod.defaultIM\u0026quot;: \u0026quot;com.apple.keylayout.ABC\u0026quot;, \u0026quot;vim.autoSwitchInputMethod.obtainIMCmd\u0026quot;: \u0026quot;/usr/local/bin/im-select\u0026quot;, \u0026quot;vim.autoSwitchInputMethod.switchIMCmd\u0026quot;: \u0026quot;/usr/local/bin/im-select {im}\u0026quot; settings.json 参数解析:\n   参数 解析     vim.autoSwitchInputMethod.enable 控制是否自动切换   vim.autoSwitchInputMethod.defaultIM 默认的输入法，其实就是在Normal模式下需要输入法   vim.autoSwitchInputMethod.obtainIMCmd 获得当前输入法的命令   vim.autoSwitchInputMethod.switchIMCmd 切换输入法的命令，{im}代表要切换到输入法名，其实就是设置的defaultIM    至此 vscode vim 自动切换输入法就完成了。\n","date":"2021-09-07T10:46:58+08:00","permalink":"https://example.com/p/vim-%E8%BE%93%E5%85%A5%E6%A8%A1%E5%BC%8F-%E8%AF%AD%E8%A8%80%E6%94%B9%E5%8F%98/","title":"Vim 输入模式 语言改变"},{"content":"screen命令 screen 是一个非常有用的命令。应用场景：\n 单个 SSH 会话中使用多个 shell 窗口（会话）的能力 服务器开发，一个单独运行进程的窗口。可以避免单独再开一个窗口。 \u0026hellip;  screen使用 创建一个窗口 $ screen -S name 执行自己需要的命令\n$ ... 分离窗口 ctrl + A + D 重新连接到screen 如果只有一个会话可以直接使用 -r\n$ screen -r 如果有多个screen会话，可以使用 ls 参数列出\n$ screen -ls There is a screen on: 10698.ttys004.zqj\t(Detached) 1 Socket in /var/folders/kt/9s3ff1cs2tn93x3ndv9kdbn00000gn/T/.screen. 使用会话id还原会话\n$ screen -r 10698 使用name还原会话, 该 name是 上面 创建会话时使用的name: screen -S name\n$ screen -r -S name 终止会话  ctrl + D exit  help 如果要使用screen的所有功能可以参考手册。\n$ screen -help ","date":"2021-09-07T10:02:16+08:00","permalink":"https://example.com/p/linue-screen/","title":"linue Screen"},{"content":"U3D物理系统 刚体(Rigidbody)、碰撞体(Colliders)、触发器 参照 Unity 官方文档的以下几篇文章，重新进行了整理。 PhysicsOverview Rigidbody2D Rigidbody\n物理的碰撞条件 Unity3D内置物理引擎，可以模拟物理效果。典型的一个物理效果就是碰撞。 两个物体发生物理碰撞的必要条件是：两个物体都带有Collider（碰撞器）组件，其中一个物体带有Rigidbody（刚体）组件，并且是运动的物体带有Rigidbody组件。\nCollider，碰撞器组件 Collider，即碰撞器。这些碰撞器组件名字带2D的都是继承自Collider2D类，名字没带2D的都继承自Collider类，一般3D物体的使用Collider碰撞器，2D物体使用Collider2D碰撞器。\nRigidbody，刚体组件 Rigidbody，刚体组件，刚体能让你的游戏对象被物理引擎所控制，它能通过受到推力和扭力来实现真实的物理表现效果。 刚体受到力的作用，会改变运动状态。假设初始状态是禁止的，那么施加一个力之后，刚体会动起来。动起来的速度与刚体受到的力成正比，与刚体的质量成反比。\n// 获取刚体组件 Rigidbody rigidBody = gameObject.GetComponent\u0026lt;Rigidbody\u0026gt;(); // 给刚体一个向量为(1, 0, 0)的力 rigidBody.AddForce(new Vector3(1, 0, 0)); // 设置刚体的质量为1 rigidBody.mass = 1; // 给刚体设置速度 rigidBody.velocity = new Vector3(1, 0, 0); // 给刚体设置角速度 rigidBody.angularVelocity = new Vector3(0, 1, 0); // 设置刚体的空气阻力为0 rigidBody.drag = 0; // 设置刚体的角阻力为0.05f rigidBody.angularDrag = 0.05f; 上述属性除了可以用代码调节以外，还可以在inspector调节\nRigidbody有个Use Gravity属性，意思就是是否使用重力，默认是勾选着的，物体受到重力作用直接垂直往下掉了。\n碰撞器类型   Static Collider，静态碰撞器 静态碰撞器是指只挂了Collider而没挂Rigidbody的游戏对象。这类对象会保持静止或者很轻微的移动。这类碰撞器被刚体碰撞后不会移动。 皮皮：“难怪刚刚被撞的另一个球不会动，因为它是一个静态碰撞器。”\n  Rigidbody Collider，刚体碰撞器 刚体碰撞器是指既挂了Collider又挂了Rigidbody的游戏对象。运动的刚体碰撞器可以与静态碰撞器发生碰撞，两个刚体碰撞器之间也可以发生碰撞。如果刚体碰撞器禁止不动，强行移动静态碰撞器去碰刚体碰撞器，此时并不会发生碰撞，因为禁止的刚体碰撞器会进入休眠状态。\n  Kinematic Rigidbody Collider，运动学刚体碰撞器\n   运动学刚体碰撞器是指在刚体碰撞器的基础上，激活了Kinematic的游戏对象。 要移动这类游戏对象，要修改它的Transform组件（坐标或角度），而不能通过力。 运动学刚体碰撞器是个非常懒惰和霸道的家伙，它不受力、重力或扭矩的影响，它去碰别人，它自己不会受到反作用力。所以你可以把运动学刚体碰撞器看成一个所向披靡的碰撞器，谁遇到它都不是对手。 两个运动学刚体碰撞器相互碰撞会出现， 谁也不让谁，直接穿透过去。  碰撞事件 在MonoBehavior脚本中，我们可以通过OnCollisionEnter、OnCollisionStay、OnCollisionExit来处理收碰撞事件。其中collision参数是对方的碰撞器对象，脚本挂在两个碰撞体上都可以触发OnCollisionXXX。  private void OnCollisionEnter(Collision collision) { Debug.Log(\u0026#34;碰撞进入\u0026#34;); } private void OnCollisionStay(Collision collision) { Debug.Log(\u0026#34;碰撞中\u0026#34;); } private void OnCollisionExit(Collision collision) { Debug.Log(\u0026#34;碰撞结束\u0026#34;); } 假设碰撞开始，对撞机相交一段时间（几帧），一段时间后它们又分开了。这些事件是：\n OnCollisionEnter仅用于第一帧，并且直到OnCollisionExit之后再也不会触发 在整个持续时间内OnCollisionStay（所有帧） OnCollisionExit仅适用于最后一帧 到最后静止两者没有了相对运动，但是还处在碰撞状态，所以OnCollisionExit没有调用。(自己写代码验证) ? 怎样才能出触发 OnCollisionExit  触发器事件 有时候我们并不想产生物理碰撞的效果，但是又想检测碰撞器之间的碰撞事件，这个时候就可以使用触发器。 触发器其实是碰撞器，只是勾选了Is Trigger。 在MonoBehavior脚本中，我们可以通过OnTriggerEnter、OnTriggerStay、OnTriggerExit来处理收碰撞事件。  private void OnTriggerEnter(Collider other) { Debug.Log(\u0026#34;触发进入\u0026#34;); } private void OnTriggerStay(Collider other) { Debug.Log(\u0026#34;触发中\u0026#34;); } private void OnTriggerExit(Collider other) { Debug.Log(\u0026#34;触发结束\u0026#34;); } 想要产生触发器事件，两个碰撞器中至少要有一个勾选了Is Trigger，并且其中一个要带Rigidbody组件。 问：\u0026ldquo;触发器有什么应用吗？看起来不知道用在哪里。\u0026rdquo; 答：\u0026ldquo;举个简单的例子，你走近一个门的时候，要触发播放开门的动作，那么门就可以弄成触发器。门的碰撞体可以稍微调大一点，这样人就可以提前碰到触发器，触发开门动作。\u0026rdquo;\n射线碰撞检测 问：\u0026ldquo;可不可以实现一个鼠标拖动物体的功能，这样就可以直接用鼠标拖动喵星逃离兰姆达星系啦。\u0026rdquo; 答：\u0026ldquo;可以呀，原理很简单，点击鼠标左键，从摄像机的位置往里发射射线，检测到碰撞，则把碰撞体缓存到一个对象中，移动鼠标的时候，把鼠标坐标转成世界坐标赋值给刚刚的物体，实现鼠标抓取物体移动的效果，鼠标松开时，释放缓存对象。\u0026rdquo;  参考：https://bbs.huaweicloud.com/blogs/216695\n","date":"2021-09-06T11:23:30+08:00","permalink":"https://example.com/p/u3d-physicalsystem/","title":"U3D PhysicalSystem"},{"content":"重力摩托 自己在网上找的一个视频教程：https://www.bilibili.com/video/BV1ix411U7HD?p=2\n环境 Unity3D\n开始  新建一个2D项目  ","date":"2021-09-06T07:20:45+08:00","permalink":"https://example.com/p/%E9%87%8D%E5%8A%9B%E6%91%A9%E6%89%98%E9%A1%B9%E7%9B%AE/","title":"重力摩托项目"},{"content":"环境  CentOS 7.2.1511 Docker  我是用 docker 拉取镜像 CentOS 7.2.1511, 利用容器来作为我的开发环境。有条件的也可以用虚拟机或者实体机器。原理都一样。\n$ docker $ yum update \u0026amp;\u0026amp; yum install gcc gcc-c++ make zlib-devel.x86_6 下载依赖包 升级 gcc， 下载安装包下载依赖。\n$ wget http://ftp.gnu.org/gnu/gcc/gcc-4.9.3/gcc-4.9.3.tar.bz2 $ tar xfv gcc-4.9.3.tar.bz2 \u0026amp;\u0026amp; cd gcc-4.9.3 $ ./contrib/download_prerequisites 如果连接失败，无法下载的话，就打开此文件，手动下载下面5个文件，然后将文件放在gcc根目录，再屏蔽contrib/download_prerequisites文件里面的wget操作，再重新执行一次./contrib/download_prerequisites。这样的话，后面编译gcc时，这几个依赖库会自动先编译，不用自动手动一个个编译。\ncloog-0.18.1.tar.gz gmp-4.3.2.tar.bz2 isl-0.12.2.tar.bz2 mpc-0.8.1.tar.gz mpfr-2.4.2.tar.bz2 编译 创建编译目录，开始编译\n$ cd .. \u0026amp;\u0026amp; mkdir build-gcc \u0026amp;\u0026amp; cd build-gcc $ ../gcc-4.9.3/configure --prefix=/usr --mandir=/usr/share/man --infodir=/usr/share/info --enable-bootstrap --enable-shared --enable-threads=posix --enable-checking=release --with-system-zlib --enable-__cxa_atexit --disable-libunwind-exceptions --enable-gnu-unique-object --enable-linker-build-id --with-linker-hash-style=gnu --enable-languages=c,c++ --enable-plugin --enable-initfini-array --disable-libgcj --enable-gnu-indirect-function --with-tune=generic --disable-multilib $ make -j4 \u0026amp;\u0026amp; make install  编译时间有点长，请耐心等待\n 说明 gcc 编译配置参数说明:\n \u0026ndash;enable-languages: 指定 gcc 能编译哪些语言的文件，每种语言用逗号分隔, 例如 c,c++,Java \u0026ndash;disable-multilib: 默认gcc 能在32位系统上将代码编译成64位程序，或者在64位系统上编译成32位程序，如果加上这个编译选项则表示关闭这个gcc的交叉编译功能。  ","date":"2021-09-01T18:13:41+08:00","permalink":"https://example.com/p/centos7.2%E7%9A%84gcc4.8%E5%8D%87%E7%BA%A7%E4%B8%BA4.9/","title":"Centos7.2的gcc4.8升级为4.9"},{"content":"Except 参数 spawn 交互程序开始后面跟命令或者指定程序 expect 获取匹配信息匹配成功则执行expect后面的程序动作 send exp_send 用于发送指定的字符串信息 exp_continue 在expect中多次匹配就需要用到 send_user 用来打印输出 相当于shell中的echo exit 退出expect脚本 eof expect执行结束 退出 set 定义变量 puts 输出变量 set timeout 设置超时时间 log_user 是否开启日志 0/1 log_file 设置日志路径,log_user = 1时才有效 一个完整的示例 我是用skynet的debug_console作为示例:\n#!/usr/bin/expect set timeout 35 log_user 1 log_file colle1.log spawn nc 127.0.0.1 10001 expect \u0026#34;Welcome to skynet console\u0026#34; {send \u0026#34;mem\\n\u0026#34;} expect eof ","date":"2021-08-30T17:13:33+08:00","permalink":"https://example.com/p/shell-except-%E4%BD%BF%E7%94%A8/","title":"shell Except 使用"},{"content":"Text Text的属性 在 Unity 的 Hierarchy 面板上右键–\u0026gt;UI–\u0026gt;Text, 在 Inspector 面板上查看属性 属性\t功能\n Text\t需要显示的文本 Font\t显示文本的字体 如：微软雅黑，宋体等 Font Style\t显示文本的样式，有普通，粗体，斜体，粗体和斜体四种选项 Font Size\t显示字体的大小 Line Spacing\t行与行之间的垂直距离 Alignment\t文本的水平和垂直方向的对齐方式 Align by Geometry\t使用字形几何范围执行水平对齐，而不是字形度量 Horizontal Overflow\t用于处理文本宽度超出文本框的情况的方法，有 Wrap (隐藏)和Overflow (溢出)两个选项 Vertical Overflow\t用于处理文本高度超出文本框的情况的方法，有 Truncate (截断)和Overflow (溢出)两个选项 Best Fit\t忽略 Size 属性，将文本合适的显示在文本框内 Color\t文本的颜色 Material\t用来渲染文本的材质  其中水平溢出和垂直溢出的两个选项效果：\n Horizontal Overflow —— 水平溢出  Overflow Wrap   Vertical Overflow —— 垂直溢出  Truncate Overflow    字体 静态设置 我们想改变文本的字体的话，我们可以下载一些字体包导入到 Unity 中\n Assets 目录下新建一个文件夹 Fonts 用来专门存放字体 然后 Font 属性中选择你导入的字体包就行了，也可直接 拖动字体 添加引用  动态设置 我们可以使用代码动态的设置Text的各种属性\nusing UnityEngine; using UnityEngine.UI; public class Font : MonoBehaviour { public Text TestText; // Start is called before the first frame update  void Start() { TestText.fontSize = 14; TestText.fontStyle = FontStyle.Normal; TestText.color = UnityEngine.Color.blue; } // Update is called once per frame  void Update() { } } Image Image 组件是 UGUI 中最常用的组件。作用：控制/显示图片\nImage的属性 在 Unity 的 Hierarchy 面板上右键–\u0026gt;UI–\u0026gt;Image\n Source Image\t需要显示图片来源（文件引用） Color\t图片的颜色 Material\t渲染图像的材质 Raycast Target\t能否接收到射线检测 Image Type\t图片的排列类型 Simple (普通模式)，Sliced (九宫格)，Tiled (平铺),Filed (填充) Preserve Aspect\t使图片保留现有尺寸 Set Native Size\t将图像尺寸设置为原始图片的像素大小  图片导入设置  把图片放入工程目录。 为了在 Image 组件上使用我们想要的图片，我们需要将图片的纹理类型改为：Sprite/精灵，图片才可正常使用。 设置 Image 的 Source Image 属性, 找到我们导入的图片。  Image Type属性详解  Simple: 简单模式-Use Sprite Mesh：是否使用图片网格，勾选-此选项，我们的图片使用 Unity 帮我们生成的图片网格; Sliced: 九宫格模式 Sliced九宫切图。效果：保证(除中间部分)，其他切图部分被拉伸不变形; TiledL: 平铺模式 Filed: 填充，这个适合做技能冷却效果  Button Button 组件是一个按钮组件。它在我们开发中经常使用，通过点击按钮：执行某些事件，动作，切换状态等\nButton 属性 在Unity的 Hierarchy 面板上右键–\u0026gt;UI–\u0026gt;Button 一个Button对象比Image对象多了：\n Button 组件 Text 子物体   Interactable\t是否启用按钮，取消则按钮出去失效状态 Color\t图片的颜色 Transition\t按钮状态过渡的类型：None、 Color Tint 、 Sprotes Swap、Animation四种类型，默认为 Color Tint Navigation\t导航 On Click\t按钮点击事件的列表。点击后执行哪些函数，在这里可以手动添加  通过脚本，动态绑定监听函数:\n1 先获取到 目标对象的Button 组件 2 通过.onClick.Addlistener(函数) 的方式进行动态添加 3 如函数具有参数，可通过Lambda表达式 .onClick.AddListener(Lambda表达式) 动态添加 4 如函数具有参数，可通过委托 .onClick.AddListener(delegate {函数;}) 动态添加 Toggle \u0026ndash;开关 我们在项目开发的时候，有时需要一个按钮，来模拟 / 控制开关,此时，如果用 Button 的话，作为开发者还需要自己写一些判定逻辑,来告诉电脑，这个 Button 按钮是打开、还是关闭\n Create Toggle 创建开关组件: UI → Toggle 即可完成创建 Custom Template —— 可自定义调节模板: 可自由调节颜色/自由更换布局或是图片 Toggle 组件与 Button 不同之处   Graphic ：用来控制 Toggle 开关图片的显示/隐藏 2 IsOn ：用来表示 Toggle 开关状态 3 Group ：用来表示 Toggle 所属开关组/群  OnChangeValue —— 值改变时调用  Dropdown 下拉框\n创建布局  创建下拉菜单模板 右键层次列表→ UI → Dropdown 设置属性  Demo Script using System.Collections; using System.Collections.Generic; using UnityEngine; using UnityEngine.UI; public class DropDownTest : MonoBehaviour { public Dropdown dropDown; // Start is called before the first frame update void Start() { dropDown = GameObject.Find(\u0026quot;Dropdown\u0026quot;).GetComponent\u0026lt;Dropdown\u0026gt;(); //是否可以点击 dropDown.interactable = true; #region 添加下拉选项，，，设置文字，底图 //添加一个下拉选项 Dropdown.OptionData data = new Dropdown.OptionData(); data.text = \u0026quot;方案一\u0026quot;; //data.image = \u0026quot;指定一个图片做背景不指定则使用默认\u0026quot;； dropDown.options.Add(data); //另一种添加方式 , 不过用起来并不比第一个方便， List\u0026lt;Dropdown.OptionData\u0026gt; listOptions = new List\u0026lt;Dropdown.OptionData\u0026gt;(); listOptions.Add(new Dropdown.OptionData(\u0026quot;方案二\u0026quot;)); listOptions.Add(new Dropdown.OptionData(\u0026quot;方案三\u0026quot;)); dropDown.AddOptions(listOptions); //设置显示字体大小 dropDown.captionText.fontSize = 14; //dropDown.captionImage = \u0026quot;底图\u0026quot;; //设置要复制字体大小 dropDown.itemText.fontSize = 15; //dropDown.itemImage = \u0026quot;底图\u0026quot;; //PS：我一般是使用循环 使用第一种形式添加 #endregion #region 添加完成就可以使用了，那么当我们想要复用怎么办呢？，这时就用到了移除OptionData，下面的每个注释打开都是一个功能 //直接清理掉所有的下拉选项， // dropDown.ClearOptions(); //亲测不是很好用 //dropDown.options.Clear(); //对象池回收时，有下拉状态的，直接干掉... (在极限点击测试的情况下会出现) // if (dropDown.transform.childCount == 3) // { // Destroy(dropDown.transform.GetChild(2).gameObject); // } //移除指定数据 参数：OptionData // dropDown.options.Remove(data); //移除指定位置 参数:索引 // dropDown.options.RemoveAt(0); #endregion #region 添加监听函数 //当点击后值改变是触发 (切换下拉选项) dropDown.onValueChanged.AddListener((int v) =\u0026gt; ConsoleResult(v)); //若有多个，可以将自己当做参数传递进去，已做区分。 //dropDown.onValueChanged_1.AddListener((int v) =\u0026gt; OnValueChange(dropDown.gameobject,v)); #endregion } // Update is called once per frame void Update() { } public int ConsoleResult(int value) { UnityEngine.Debug.Log(\u0026quot;1231231\u0026quot;); UnityEngine.Debug.Log(value); switch (value) { case 0: UnityEngine.Debug.Log(\u0026quot;第一页\u0026quot;); break; case 1: UnityEngine.Debug.Log(\u0026quot;第二页\u0026quot;); break; case 2: UnityEngine.Debug.Log(\u0026quot;第三页\u0026quot;); break; } return 1; } } 这段代码的作用是\n 添加属性 绑定onValueChange事件 我试过使用Unity自带的On Value Change事件。但是不成功。 注意：需要另外再创建 右键-\u0026gt; UI -\u0026gt; Create Empty. 然后把脚本跟创建的该Empty 绑定。然后在Drop Down里选择 DropDown  注意事项  手动添加监听事件，需绑定动态方法（Unity会自动生成） 设置自己需要的默认项，默认为 0 ，当下拉菜单弹起时，默认就是第一项 下拉菜单的机制，就是已经被选中的选项，如果再次点击是不会调用函数方法的！！！ （也就是说，你已经选择了第一页，再次点击第一页，是不会调用任何函数的）  InputField 在 Unity 的 Hierarchy 面板上右键–\u0026gt;UI–\u0026gt;InputFiel\n Placeholder ：用来提示用户的占位符 Text ：用来输入内容  属性  TextComponent\t用来管理输入的文本组件 Text\t输入的内容 ( 我们可以在代码中用 InPutField.text 获取到 ) Character Limit\t字符限制类型，可以限制最大字符数的值。 Content Type\t内容类型，定义输入内容接受/限制的字符类型 Line Type\t行类型。单行、多行，多行回车换行 Placeholder\t占位符，用来提示输入的内容，当点击输入框后会隐藏 Caret Blink Rate\t输入框上的光标的闪烁频率 Selection Color\t选中文本的背景颜色 Hide Mobile Input (iOS only)\t隐藏移动输入内容，仅IOS有用  Content Type \u0026ndash;内容类型  Standard\t标准，可以输入任何字符 Auto corrected\t自动更正，可以自动更正用户输入，并建议输入内容 Integer Number\t整数，只允许输入整数 Decimal Number\t十进制数，仅允许输入数字和小数点后一位 Alphanumeric\t字母数字，允许字母和数字。无法输入符号 Name\t名称(支持中文)自动将每个单词的首字母大写。(用户可以使用Delete键绕过大小写规则 ) Email Address\t电子邮件地址，允许您输入最多包含一个@符号的字母数字字符串 Password\t密码：用 * 表示输入的字符，从而隐藏输入内容。(允许符号) Pin\t用 * 号表示输入的字符。仅允许输入整数 Custom\t自定义：允许自定义行类型、输入类型、默认键盘类型、字符验证  Line Type —— 行类型  Single Line\t单行 ：仅允许文本在一行上 Multi Line Submit\t多行自动换行 ：允许文本使用多行。仅在一行写满后使用新行 Multi Line Newline\t多行回车新建行 ：用户可以随时通过按 Enter 键来新建行，继续输入  Custom —— 自定义  Default\t目标平台的默认键盘 ASCLL Capable\t带标准ASCII键的键盘。 Numbers And Punctuation\t键盘与数字和标点符号键 URL\t键盘与URL输入键 Number Pad\t键盘与标准数字键 Phone Pad\t键盘与适合键入电话号码的布局 NamePhone Pad\t键盘与字母数字键 Email Address\t带有适合键入电子邮件地址的其他键的键盘 Nintendo Network Account\t带有网络账号键的键盘 Social\t键盘与常用于社交媒体上的符号键，如Twitter Search\t键盘上带有“.” 空格键旁边的键，适合键入搜索词  Exemple 实现一个小 Demo：获取用户的账号密码：简单的搭建一个用户输入界面\n 两个 InputField 输入框分别命名： Account 和 Password 一个 Button 按钮 将密码的输入框的Content Type 改为 Password  我用代码将组键和函数绑定\nusing System.Collections; using System.Collections.Generic; using UnityEngine; using UnityEngine.UI; public class EgInputField : MonoBehaviour { public InputField Account; //账号输入框 public InputField Password; //密码框 public Button LoginButton; //登录按钮 // Start is called before the first frame update void Start() { Account = GameObject.Find(\u0026quot;Account\u0026quot;).GetComponent\u0026lt;InputField\u0026gt;(); Password = GameObject.Find(\u0026quot;Password\u0026quot;).GetComponent\u0026lt;InputField\u0026gt;(); LoginButton.onClick.AddListener(Login); } public void Login() { UnityEngine.Debug.Log(\u0026quot;1231231\u0026quot;); print(\u0026quot;账号: \u0026quot; + Account.text + \u0026quot;; 密码: \u0026quot; + Account.text); } // Update is called once per frame } Raw Image Raw Image 组件是一个显示纹理贴图的组件，常用于与 RenderTexture 结合使用，映射相机画面 与 Image 组件的区别是：\n Image 显示Sprite 精灵图片； Raw Image 可以显示任何纹理贴图。( 如：Texture 、Render Texture )  Raw Image 属性 在Unity的 Hierarchy 面板上右键–\u0026gt;UI–\u0026gt;Raw Image\n Texture\t用于显示的纹理贴图的引用 Color\t图片的颜色 Material\t渲染图像的材质 Raycast Target\t能否接收到射线检测 UV Rect\t控制 UI 矩形内的图像偏移和大小  Texture Import Setting —— 图片导入设置 Canvas Scroll View Slider Scrollbar ","date":"2021-08-20T14:15:41+08:00","permalink":"https://example.com/p/u3d-ugui/","title":"U3D UGUI"},{"content":"概述 网上有很多golang操作redis的例子，我使用github.com/gomodule/redigo/redis包写一个关于redis分布式锁的问题。\nredis分布式锁 锁需要的几个组件\n 获取锁 删除锁  分布式锁还需要\n 给锁加上唯一id (只能获取和删除自己的锁) 给锁加上过期时间 (防止死锁)  golang代码 推荐使用redis的连接池\npool := redis.Pool{ MaxIdle: 8, MaxActive: 0, IdleTimeout: 100, Dial: func() (redis.Conn, error) { return redis.Dial(\u0026#34;tcp\u0026#34;, \u0026#34;127.0.0.1:6100\u0026#34;) }, } 通过lua脚本保证获取锁/加过期时间和获取锁的值/删除锁为原子操作\nvar ( updateLockExpireUidScript = redis.NewScript(1, ` local res = redis.call(\u0026#34;SETNX\u0026#34;, KEYS[1], ARGV[1]) if res == 1 then return redis.call(\u0026#34;EXPIRE\u0026#34;, KEYS[1], ARGV[2]) end return res `) deleteLockByUidScript = redis.NewScript(1, ` local res = redis.call(\u0026#34;GET\u0026#34;, KEYS[1]) if res == ARGV[1] then return redis.call(\u0026#34;DEL\u0026#34;, KEYS[1]) end return res `) ) golang完整代码\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;github.com/gomodule/redigo/redis\u0026#34; \u0026#34;time\u0026#34; ) func getLock(conn redis.Conn, key []string, uid int, expire int) bool { lock := false for !lock { res, err := updateLockExpireUidScript.Do(conn, key, uid, expire) if err != nil { fmt.Println(err.Error()) break } if res.(int64) == 1 { lock = true fmt.Println(\u0026#34;获取锁成功\u0026#34;) return true } } fmt.Println(\u0026#34;获取锁失败\u0026#34;) return false } func delLock(conn redis.Conn, key []string, uid int) bool { _, err := deleteLockByUidScript.Do(conn, key, uid) if err != nil { fmt.Println(\u0026#34;删除锁失败\u0026#34;) fmt.Println(err.Error()) return false } fmt.Println(\u0026#34;删除锁成功\u0026#34;) return true } var ( updateLockExpireUidScript = redis.NewScript(1, ` local res = redis.call(\u0026#34;SETNX\u0026#34;, KEYS[1], ARGV[1]) if res == 1 then return redis.call(\u0026#34;EXPIRE\u0026#34;, KEYS[1], ARGV[2]) end return res `) deleteLockByUidScript = redis.NewScript(1, ` local res = redis.call(\u0026#34;GET\u0026#34;, KEYS[1]) if res == ARGV[1] then return redis.call(\u0026#34;DEL\u0026#34;, KEYS[1]) end return res `) ) func main() { pool := redis.Pool{ MaxIdle: 8, MaxActive: 0, IdleTimeout: 100, Dial: func() (redis.Conn, error) { return redis.Dial(\u0026#34;tcp\u0026#34;, \u0026#34;127.0.0.1:6100\u0026#34;) }, } key := []string{\u0026#34;distribute\u0026#34;} uid := 1 expire := 20 fmt.Println(time.Now()) for i:= 1; i\u0026lt; 100; i++ { go func() { conn := pool.Get() if getLock(conn, key, uid, expire) { fmt.Println(\u0026#34;开始执行逻辑...\u0026#34;) fmt.Println(\u0026#34;逻辑结束，删除锁\u0026#34;) delLock(conn, key, uid) } }() } fmt.Println(time.Now()) time.Sleep(time.Second * 20) } ","date":"2021-06-03T15:57:14+08:00","permalink":"https://example.com/p/golang%E6%93%8D%E4%BD%9Credis/","title":"golang操作redis"},{"content":"自动寻路 有限状态机器 行为树 ","date":"2021-05-20T17:39:34+08:00","permalink":"https://example.com/p/auto_findroad/","title":"Auto_findroad"},{"content":"lua_next lua_next(L,index)：先把 表(lua栈 index所指的表), 的当前索引弹出，再把table 当前索引的值弹出，也就是先弹出 table的索引，再弹出table索引的值 举例：\nlocal t = { [\u0026quot;a\u0026quot;] = 1, [\u0026quot;b\u0026quot;] = 2, [\u0026quot;c\u0026quot;] = 3 } 使用lua_next遍历table t\nint traversing(lua_State *L) { lua_pushnil(L); /*此时栈的状态 ------- | -1 nil | -2 table NUMBER_TABLE ------- */ while (lua_next(L, -2)) { /*此时栈的状态 ------- | -1 value | -2 key | -3 table NUMBER_TABLE ------- */ if (lua_isnumber(L, -2)) printf(\u0026#34;nkey: %d\\t\u0026#34;, luaL_checkinteger(L, -2)); else if (lua_isstring(L, -2)) printf(\u0026#34;skey: %s\\t\u0026#34;, luaL_checkstring(L, -2)); if (lua_isnumber(L, -1)) printf(\u0026#34;nvalue: %d\\t\u0026#34;, luaL_checkinteger(L, -1)); else if (lua_isstring(L, -1)) printf(\u0026#34;svalue: %s\\t\u0026#34;, luaL_checkstring(L, -1)); /*此时栈的状态 ------- | -1 value | -2 key | -3 table NUMBER_TABLE ------- */ lua_pop(L, 1); /*此时栈的状态 ------- | -1 key | -2 table NUMBER_TABLE ------- */ } lua_pop(L, 1); /*此时栈的状态 ------- | -1 table NUMBER_TABLE ------- */ return 0; } lua_next(L, -2) 这个函数的工作过程是：\n 先从栈顶弹出一个 key 从栈指定位置的 table 里取下一对 key-value，先将 key 入栈,再将 value 入栈 如果第 2 步成功则返回非 0 值，否则返回 0，并且不向栈中压入任何值, 第 2 步中从 table 里取出\u0026quot;下一对 key-value\u0026ldquo;是相对于第 1 步中弹出的 key 的。table 里第一对 key-value 的前面没有数据，所以先用 lua_pushnil() 压入一个 nil 充当初始 key。  ","date":"2021-05-10T16:39:50+08:00","permalink":"https://example.com/p/lua-next-%E7%9A%84%E4%BD%BF%E7%94%A8/","title":"Lua next 的使用"},{"content":"lua_pop和lua_settop lua_settop 我们直接来看lua_settop，文档解释\n/* 设置栈的高度，如果之前的栈顶比新设置的更高，那么高出来的元素会被丢弃，反之压入nil来补足大小 假设栈里有2个元素。 如果index=0，那么移除栈上所有元素 如果index=1，移除栈顶一个元素 如果index=4，那么压入2个nil元素 */ void lua_settop (lua_State *L, int index); 使用代码测试\nint lua_test(lua_State *L) { int pop_num = lua_tointeger(L,1); printf(\u0026#34;pop_num= %d\\n\u0026#34;, pop_num); lua_settop(L,0); printf(\u0026#34;1-top %d\\r\\n\u0026#34;,lua_gettop(L)); lua_pushinteger(L,31); lua_pushinteger(L,32); lua_pushinteger(L,33); lua_pushinteger(L,34); printf(\u0026#34;2-top %d\\r\\n\u0026#34;,lua_gettop(L)); lua_pop(L,pop_num); lua_settop(L, -2); //清除一个栈顶  printf(\u0026#34;3-top %d\\r\\n\u0026#34;,lua_gettop(L)); printf(\u0026#34;栈底 %d\\r\\n\u0026#34;,lua_tointeger(L,1)); printf(\u0026#34;栈顶 %d\\r\\n\u0026#34;,lua_tointeger(L,-1)); return 0; } 输出\npop_num= 0 1-top 0 2-top 4 3-top 3 栈底 31 栈顶 33 总结lua_settop(L, idx)函数\n idx=0 栈中元素全部移除 idx\u0026gt;0 设置栈的高度，如果之前的栈顶比新设置的更高，那么高出来的元素会被丢弃，反之压入nil来补足大小 idx\u0026lt;0 idx=-1表示栈顶，栈不受影响；idx=-2表示清除一个栈顶元素,一次类推；  lua_pop 从代码里看到\n#define lua_pop(L,n)\tlua_settop(L, -(n)-1) 因为lua_pop是lua_settop宏定义, lua_pop(L,num)函数表示从栈顶开始移除。\n 当num\u0026gt;0时从栈顶移除指定个数 。 当num=0时栈不受影响 当num\u0026lt;0，当num=-1时栈中元素全部移除; num=-2表示清除一个栈顶元素,一次类推； 但是负数编号不能超出栈底的负数索引，超出会抛出异常  /** * 把给定索引处的 Lua 值转换为 lua_Integer 这样一个有符号整数类型 * 必须：数字/字符串类型数字 */ LUA_API lua_Integer lua_tointegerx (lua_State *L, int idx, int *pisnum) * idx = -1代表栈顶 * idx = 1 代表栈底 /** * 返回LUA 栈的个数 * 同时也是栈顶元素的索引，因为栈底是1 */ LUA_API int lua_gettop (lua_State *L) 参考链接：http://www.daileinote.com/computer/lua/17\n","date":"2021-05-10T15:57:03+08:00","permalink":"https://example.com/p/lua%E7%9A%84api/","title":"Lua的api"},{"content":"hugo 我用过的静态博客有hexo、jekyll和hugo，对比起来，hugo虽然没有hexo那样丰富的插件和主题，但是hugo生成文章的速度更快。我是一名go语言爱好者，而hugo是go语言开发的, jekyll是用ruby开发的。于是我选择了hugo。下面我把hugo的安装步骤记录下来，供后来者参考。\n环境  mac brew hugo  安装brew\n/bin/zsh -c \u0026quot;$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)\u0026quot; $ brew update  选择中科大源\n 安装hugo\n$ brew install hugo 使用 新建站点\n$ hugo new site myblog $ cd myblog 新建一个页面\n$ hugo new about.md 开始服务\n$ hugo server --buildDrafts 主题 我使用的主题是hugo-theme-stack 安装主题\ngit 部署到Github个人页面  在Github创建一个仓库，例如名字叫blog，可以是私有的，这个仓库用来存放网站内容和源文件 再创建一个名称为.github.io的仓库，username为GitHub用户名，这个仓库用于存放最终发布的网站内容 进入本地网站目录  $ cd \u0026lt;YOUR PROJECT\u0026gt; 关联远程blog仓库\n$ git remote add origin git@github.com:jeshs/blog.git 将本地网站全部内容推送到远程blog仓库\n$ git push -u origin master 关闭本地Hugo服务器Ctrl+C，然后删除本地网站目录下的public文件夹,创建public子模块，注意下面是一行命令，不是两行\n$ git submodule add -b master git@github.com:\u0026lt;USERNAME\u0026gt;/\u0026lt;USERNAME\u0026gt;.github.io.git public 然后就可以执行hugo命令，此命令会自动将网站静态内容生成到public文件夹，然后提交到远程blog仓库\nhugo cd public git status git add . git commit -m \u0026quot;first commit\u0026quot; git push -u orgin master 过一会就可以打开.github.io查看网站了 注意：本地网站是关联的blog仓库，本地网站下的public文件夹是以子模块的形式关联的github.io仓库，他们是相对独立的\n自动部署脚本 将以上步骤添加到自动执行脚本中deploy.sh，脚本commit提交信息会使用执行时的时间，将脚本放到网站项目路径下，写完博客后，双击运行即可自动部署发布\n#!/bin/bash echo -e \u0026quot;\\033[0;32mDeploying updates to GitHub...\\033[0m\u0026quot; # Build the project. hugo # if using a theme, replace with `hugo -t \u0026lt;YOURTHEME\u0026gt;` # Go To Public folder cd public # Add changes to git. git add . # Commit changes. msg=\u0026quot;rebuilding site `date`\u0026quot; if [ $# -eq 1 ] then msg=\u0026quot;$1\u0026quot; fi git commit -m \u0026quot;$msg\u0026quot; # Push source and build repos. git push origin master # Come Back up to the Project Root cd .. 给网站添加评论 Hugo支持Disqus评论，只需要在配置文件config.toml中设置disqusShortname = \u0026ldquo;disqusShortname\u0026rdquo;，如果没有disqusShortname，需要到Disqus官网注册一个账号，注册后添加一个网站，添加时会让填一个shortname，Disqus会生成一个shortname.disqus.com的网址，另外还需要把config.toml中的baseURL地址，也就是公网访问地址添加到Diqus的信任网址中，类似于互相添加信任\n","date":"2021-04-17T00:00:00Z","image":"https://example.com/helena-hertz-wWZzXlDpMog-unsplash.jpg","permalink":"https://example.com/p/hugo/","title":"Hugo"}]